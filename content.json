{"meta":{"title":"youmingsama","subtitle":"","description":null,"author":"youmingsama","url":"https://blog.youmingsama.cn","root":"/"},"pages":[{"title":"","date":"2023-06-23T07:25:57.142Z","updated":"2023-06-23T07:25:57.142Z","comments":true,"path":"manifest.json","permalink":"https://blog.youmingsama.cn/manifest.json","excerpt":"","text":"{\"name\":\"youmingsama\",\"short_name\":\"youmingsama\",\"theme_color\":\"var(--lyx-theme)\",\"background_color\":\"var(--lyx-theme)\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"/img/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"/img/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/img/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/180.png\",\"sizes\":\"180X180\",\"type\":\"image/png\"},{\"src\":\"/img/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/img/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"/img/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2023-06-23T07:25:57.142Z","updated":"2023-06-23T07:25:57.142Z","comments":true,"path":"package.json","permalink":"https://blog.youmingsama.cn/package.json","excerpt":"","text":"{\"name\":\"ariasakablog\",\"version\":\"1.0.17\",\"description\":\"SpeedUp!\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"author\":\"\",\"license\":\"ISC\"}"},{"title":"关于","date":"2021-03-30T15:57:51.000Z","updated":"2023-06-23T07:25:57.102Z","comments":true,"path":"about/index.html","permalink":"https://blog.youmingsama.cn/about/index.html","excerpt":"","text":""},{"title":"bangumis","date":"2022-07-16T10:35:32.000Z","updated":"2023-06-23T07:25:57.102Z","comments":true,"path":"bangumis/index.html","permalink":"https://blog.youmingsama.cn/bangumis/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-03T20:48:08.000Z","updated":"2023-06-23T07:25:57.102Z","comments":true,"path":"categories/index.html","permalink":"https://blog.youmingsama.cn/categories/index.html","excerpt":"","text":""},{"title":"朋友圈","date":"2022-01-29T15:23:17.000Z","updated":"2023-06-23T07:25:57.102Z","comments":true,"path":"fcircle/index.html","permalink":"https://blog.youmingsama.cn/fcircle/index.html","excerpt":"","text":"🎣 钓鱼 与主机通讯中…… var fdataUser = { apiurl: '' }"},{"title":"fontawesome对照","date":"2022-11-25T08:16:09.000Z","updated":"2023-06-23T07:25:57.102Z","comments":true,"path":"fontawesome/index.html","permalink":"https://blog.youmingsama.cn/fontawesome/index.html","excerpt":"","text":"window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"小空调","date":"2022-11-25T07:37:35.000Z","updated":"2023-06-23T07:25:57.142Z","comments":true,"path":"kongtiao/index.html","permalink":"https://blog.youmingsama.cn/kongtiao/index.html","excerpt":"","text":""},{"title":"声明","date":"2022-07-10T11:13:49.000Z","updated":"2023-06-23T07:25:57.142Z","comments":true,"path":"license/index.html","permalink":"https://blog.youmingsama.cn/license/index.html","excerpt":"","text":"Copyright© LYX 2022 声明 | 版权协议 为了保持文章质量，并保持互联网的开放共享精神，保持页面流量的稳定，综合考虑下本站的所有原创文章均采用cc协议中比较严格的创作共用-非商业性-禁止演绎 4.0 国际标准。这篇文章主要想能够更加清楚明白的介绍本站的协议标准和要求。方便您合理的使用本站的文章。 本站无广告嵌入和商业行为。违反协议的行为不仅会损害原作者的创作热情，而且会影响整个版权环境。强烈呼吁您能够在转载时遵守协议。遵守协议的行为几乎不会对您的目标产生负面影响，鼓励创作环境是每个创作者的期望。 博客的分类介绍 经验分享包含原创内容，原创内容的非商用转载必须为完整转载且标注出处的带有超链接功能的完整url链接（需能点击）或访问原文之类字样的超链接。 转载内容为转载内容，均标注了出处。建议使用原链接打开，尊重原作者。所有转载内容尽可能为完整转载（如果有部分内容有问题可能会由部分删减和补充）并进行样式调整以适合本博客。如果转载该部分内容需要联系原作者。 你可以做什么？ 只要您遵守本页的许可，您可以自由地共享文章的内容 — 在任何媒介以任何形式复制、发行本作品。并且无需通知作者。 你需要遵守什么样的许可？ 署名 您必须标注内容的来源，您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接提升阅读体验）。 禁止商用 本站内容免费向互联网所有用户提供，分享本站文章时禁止商业性使用、禁止在转载页面中插入广告（例如谷歌广告、百度广告）、禁止阅读的拦截行为（例如关注公众号、下载App后观看文章）。 禁止演绎 分享全部内容（无修改） 您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接） 分享部分截取内容或者衍生创作 目前本站全部原创文章的衍生品禁止公开分享和分发。如有更好的修改建议，可以在对应文章下留言。如有衍生创作需求，可以在评论中联系。 什么内容会被版权保护 包括但不限于： 文章封面图片 文章标题和正文 站点图片素材（不含主题自带素材） 例外情况 本着友好互相进步的原则，被本站友链收录的博客允许博客文章内容的衍生品的分享和分发，但仍需标注出处。 本着互联网开放精神，您可以在博客文章下方留言要求授权博文的衍生品的分享和分发，标注您的网站地址。 作者原创代码及网站源代码协议 网站所有代码采用MIT协议，如有不同，作者会进行标注 随便扒站吧！ 网站本身有关 本站已开启存储桶全站加速，接入了灵天盾CDN，请刷流量的耗子尾汁！！！"},{"title":"友链","date":"2022-07-03T20:40:57.000Z","updated":"2023-06-23T07:25:57.142Z","comments":true,"path":"links/index.html","permalink":"https://blog.youmingsama.cn/links/index.html","excerpt":"","text":"🎣 钓鱼 冰糖红茶 “冰糖红茶”博客魔改组织的大佬们 小冰【冰】 做个有梦想的人！ Akilar【糖】 期待您的光临！ 张洪Heo【红】 分享设计与科技生活 贰猹【茶】 用这生命中的每一秒，给自己一个不后悔的未来 我的信息Butterfly & MengDfluidvolantishtml12345- name: youmingsama link: https://yisous.xyz avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg descr: 人有悲欢离合 月有阴晴圆缺 siteshot: https://vercel.yisous.xyz/img/siteshot.png123456- &#123; title: &#x27;youmingsama&#x27;, intro: &#x27;人有悲欢离合 月有阴晴圆缺&#x27;, link: &#x27;https://yisous.xyz/&#x27;, image: &#x27;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&#x27;&#125;123456- title: youmingsama avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg url: https://yisous.xyz/ screenshot: https://yisous.xyz/img/siteshot.png keywords: 个人博客 description: 人有悲欢离合 月有阴晴圆缺1&lt;a href=&quot;https://yisous.xyz&quot;&gt;&lt;img src=&quot;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&quot; alt=&quot;avatar&quot;&gt;youmingsama&lt;/a&gt; 推荐标签衡量标准1.网站没有不良内容 2.文章质量较高 3.文章较多/或者质量过硬 如何申请友链？ 点下面的按钮！ 快速添加友链"},{"title":"","date":"2023-06-23T07:25:57.142Z","updated":"2023-06-23T07:25:57.142Z","comments":true,"path":"messageboard/index.html","permalink":"https://blog.youmingsama.cn/messageboard/index.html","excerpt":"","text":"说说你的建议吧... 你也可以私发我的邮件youmingsamada@outlook.com寻求帮助或者提供建议。 隐藏/显示弹幕（缓解卡顿） document.title = '留言板 | youmingsama';"},{"title":"好听的音乐","date":"2022-07-14T16:37:40.000Z","updated":"2023-06-23T07:25:57.142Z","comments":true,"path":"musics/index.html","permalink":"https://blog.youmingsama.cn/musics/index.html","excerpt":"","text":"好听的歌 歌曲排行榜 博主会每隔一段时间将自己近期爱听的歌排行在下面 2022-7 咕咕咕…"},{"title":"敲木鱼","date":"2022-11-25T08:16:09.000Z","updated":"2023-06-23T07:25:57.142Z","comments":true,"path":"muyu/index.html","permalink":"https://blog.youmingsama.cn/muyu/index.html","excerpt":"","text":"功德：0 功德+100 .muyu-layout { background: black; display: flex; width: 100%; border-radius: 20px; position: relative; justify-content: center; height: 90vh; align-items: center; } #muyu-box img { width: 250px; } #jishu-box{ top: 55px; position: absolute; } #muyu-box p { color: white; opacity: 0; font-size: 25px; } #jishu-box p { color: white; font-size: 30px; } var gongde = document.getElementById(\"gongde\"); var muyu = document.getElementById(\"muyu\"); var jishu = document.getElementById(\"jishu-box\"); var mp3Url = \"/music/muyu.mp3\"; var player = new Audio(mp3Url); var num = 0; muyu.addEventListener(\"click\", function () { num+=100; player.load(); player.play(); muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500); gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600); jishu.innerHTML = \"功德：\"+num+\"\"; });"},{"title":"分站","date":"2022-08-04T11:38:05.000Z","updated":"2023-06-23T07:25:57.142Z","comments":true,"path":"othersite/index.html","permalink":"https://blog.youmingsama.cn/othersite/index.html","excerpt":"","text":"一些博主搭建的其它的站点： PS：划掉的表示已挂 域名 用处 搭建原因 yisous.xyz 博客，也是主站（默认无www） 分享一些东西 oj.yisous.xyz OnlineJudge系统 用于自己练习信奥赛题目其实是搞来象征意义的 status.yisous.xyz 网站状态监控 用于监控网站的状态，基于uptimeRobot mc.yisous.xyz Minecraft服务器 用来联机玩，类似于粉丝服那种，还没弄好 tc.yisous.xyz Typecho测试站 看看typecho怎么样，搞来玩的，已经由Wordpress迁移至当前的Typecho，未来服务器文档之后可能会换用 yisous.tk/lyxop.xyz 短链接生成器 制作短链接，使用本站域名，技术有限，所以很丑 bbs.yisous.xyz LYXの论坛 交流一些事情，也可以闲聊，还没弄说是交流其实还是搞来象征意义搞来玩的 博主的一些域名 域名 用处 yisous.xyz 主要使用的域名，当时看到dynadot14块一年就买了，这个名字就是念起来顺口 lyxop.xyz 注册拿来给副站用的，使用blog.lyxop.xyz进入主站。由于域名续费太贵，所以打算以后换成yisous.tk，其余一样 ariasaka.top 在硅云白嫖的一个域名，后续可能会作为主域名使用 lyxoff2233.eu.org 以前的eu.org域名，还不错，后面要拿来想办法用一用 lyxofficial.eu.org 图一乐域名 yisous.tk 20年为了搭树莓派服搞的域名，可是树莓派没多久就被我超坏了，现在就买不起了，后来这个域名过期，现在又弄回来作为副站使用，使用blog.yisous.tk进入主站，www和根域名主站用于提供短域名服务（已挂）。 注意：本博客强制HTTPS，旧电脑可能会出现问题。 #article-container a:not(.post-meta__tags):not(img):not(a[data-fancybox]):hover{ border-radius: 6px; background-color: #425aef; text-decoration: none!important; color:#fff!important; border:none; box-shadow: #dadada 0 0 8px 2px; } #article-container a:not(.post-meta__tags):not(.headerlink):not(a[data-fancybox]){ /* padding:0 2px; */ /* text-decoration: 1px solid #425aef; */ /* text-decoration: underline; */ border-bottom: 2px solid #425aef; color:var(--font-color); padding:4px }"},{"title":"说说","date":"2023-06-23T07:25:57.146Z","updated":"2023-06-23T07:25:57.146Z","comments":true,"path":"speaks/index.html","permalink":"https://blog.youmingsama.cn/speaks/index.html","excerpt":"","text":"function doSpeaks() { document.title = '说说 | youmingsama'; bbtalk.init({ appId: \"\", appKey: \"\", serverURLs: '', pageSize:1919810 }) } document.addEventListener('DOMContentLoaded', (e) => { doSpeaks(); }) document.addEventListener('pjax:complete', (e) => { doSpeaks(); })"},{"title":"标签","date":"2022-07-03T20:51:29.000Z","updated":"2023-06-23T07:25:57.146Z","comments":true,"path":"tags/index.html","permalink":"https://blog.youmingsama.cn/tags/index.html","excerpt":"","text":""},{"title":"工具","date":"2022-07-13T15:23:02.000Z","updated":"2023-06-23T07:25:57.146Z","comments":true,"path":"tools/index.html","permalink":"https://blog.youmingsama.cn/tools/index.html","excerpt":"","text":"镜像站常用的PyPi/npm/SDK镜像站 TUNA 清华大学开源镜像站 豆瓣PYPI源 豆瓣PYPI镜像站 jsDelivr jsDelivr静态资源加速（GFW已墙） unpkg 另一个静态资源加速CDN（没墙） 资源下载类好用的资源下载/收录站 MSDN,我告诉你 微软MSDNED2K镜像收录站 唧唧Down 下载B站视频 无损生活 免费下载全网绝大部分无损音乐 百度网盘简易下载助手 特别好用的bd网盘破解器（不知道为什么公众号分享很怕敏感词） 日常工具常用日常工具 计时器 闹钟网计时器 图片系列关于图片的工具 Bigjpg 高清修复图片与降噪 waifu2x 高清修复图片与降噪，性能貌似好一点 jpgrm 高清修复图片与降噪 Sheilds 制作Github项目徽章 极简壁纸 海量高清壁纸美图&二次元图片 常用测试网站测试一些基础功能 还没做完呢 你瞅啥？还妹做完呢！"},{"title":"网站更新日志","date":"2022-07-02T19:56:00.000Z","updated":"2023-06-23T07:25:57.146Z","comments":true,"path":"update/index.html","permalink":"https://blog.youmingsama.cn/update/index.html","excerpt":"","text":"Acryple v1.0.0 2022-10-23 经过了深思熟虑，博客主题独立啦！ 现在的主题叫做Acryple，具体见： 引用站外地址 博客正式独立主题啦！ youmingsama 目前博客有： 更好的右键菜单 留言弹幕 博客设置（功能贼多大家自己看） 不错的UI，至今为止主css(style.css)有3k行 一些小功能比如公祭日弹窗自动欢迎等 大概就是这些了。 Acryple v1.0.110 2022-12-13 加入pwa 全站采用存储桶加速，可惜并没有卵用 很多资源转为了白嫖eleme 抛弃metingjs，目前aplayer的歌曲托管在eleme npm镜像中 友链添加随机头像 博客设置画饼的三个功能仍未修复 qwq 修复一些bug 大改swiper，参考自Leonus 完成Build101的大部分饼 修复了朋友圈爬取bug sw换回cyfan 套上了灵天盾亚太CDN 因为性能问题，移除了文章日历 给导航栏加上滚动动画（画饼） bb布局重构（画饼） 分类标签栏bug修复（画饼） 语雀云端写作（因bug已回滚） gulp（因bug已回滚） 文章进度显示（画饼） 修复pjax的bug 右键菜单功能完善 Acryple v1.0.101 2022-12-06 （PS：部分画大饼 壮举：适配pjax！！！ 修复黑幕的bug 修复评论弹幕dom错误，溢出的bug 弹幕换用swiper方案，并且优化样式 首页bb增加天数显示，以及换用swiper(预计) 修复一些bug（e.g.aplayer、博客设置 优化部分动画/样式 完善博客控制面板，仍有部分未完工 修复部分文章页面溢出的bug 悼念某人，banner换图 pace换用xlenco的胶囊方案 由于未知特性删除了pjax的加载动画，首次保留 部分资源换用缤纷云 换用空梦的sw 不断优化加载速度ing… 修复首页轮播bug(预计) 评论样式修改，预计添加用户tag功能 更换背景没有时效限制了 欢迎文本 左右栏切换 弹幕开关设置自动显隐 落樱特效 aplayer显隐功能 明暗模式自动切换、固定导航栏功能（预计） 边栏样式修改 修复点赞第一赞没反应的bug 修复ghactions部署没有npm缓存的bugtnnd我等十几分钟安装依赖等几个月了，结果是顺序反了 目前朋友圈后端出现了bug，导致不更新，请静待修复 Acryple v1.0.100 2022-12-04 修复部分bug（不，特性 优化部分动画/样式 修改右键菜单 重写博客设置，并将 rightside 的部分功能移动到博客设置中，灵感来源于ichika（未完工 支持隐藏 ASide 了 短暂变灰 修复公祭日js的bug 修复右键菜单在主页也能开启阅读模式的bug 优化手机端阅读体验，去卡片化 优化latex样式 修复部分分辨率下无导航栏的bug aplayer的体验更好了 优化部分样式，适配部分还未适配的黑暗模式 加了一个字体 重写分类和标签、归档页的样式，来源于ichika 优化页脚查看体验 优化网站性能 支持全屏 css 5k+ qpzc 解封辣！！！ 究极跳号？！CRT18:?! Acryple v1.0.92 修复部分bug（不，特性 优化部分样式 更改了博客设置的部分主题色 pages页面在Acrylic主题下的背景得到了改善 更改加载页面背景 重新进行部分断点 把博客api\\服务全部迁移到了另一个github账号~~(垃圾桶)~~上 优化搜索UI 对butterfly4.5.1进行了选择性同步(优化繁体字库) 疫情退退退awa Acryple v1.0.91 修复部分bug（不，特性 为APlayer进行完善 添加早报、木鱼、空调页面，参考Chuckle 更改关于页面，参考安知鱼的教程 尝试npm全站静态化，最终失败放弃qwq 优化sw，加载速度略有提升 新增文章统计 优化部分样式 Acryple v1.0.81 2022-11-23 修复部分bug（不，特性 优化性能问题，对弹幕进行了节流 添加APlayer，可惜没有pjax qwq 优化弹幕（更洪化了） 调整网站布局 修改一些样式 PS：在1.0.51偷偷加了一号字号你们发现没有(doge) Acryple v1.0.51 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 换用Twikoo-magic表情包 为了OI添加 KaTeX\\textbf{ \\KaTeX} KATE​X 修复跳转链接因原有bug被迫使原页面刷新的bug Acryple v1.0.14 2022-11-10 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 增加浏览器过期提醒以及banIE，参考chuckle以及b站 增加fps显示 评论表情添加颜文字 修复手机端侧边栏bug PS：作为一个萌新OIer依然没有考虑发oi文 ╮(╯▽╰)╭ 以前的更新日志哔哩哔哩 (゜-゜)つロ 干杯！ 2022 07-02 终于弄好网站了，庆祝一下🎉 Gitalk不知道为什么不显示出来… 07-03 小更新，修改细节 作者的Html实在太菜了，效果并不好 07-04 大更新 修改了很多ui 07-05 大更新 修改细节UI和友链部分，增加吐槽部分 07-06 小更新，做好一些功能并且写了第一篇文章 07-08 大更新，更改首页布局，增加首页分区 07-09 小更新，修改细节，适配手机端，修复bug，说说由Artitalk换为BBtalk 07-14 前面几天忘记写更新了，更新了很多UI和功能。。。 07-18 前面几天又忘记写更新了小小修改了一些布局，把鸽了很久的博客写完了并且还加了萌百的黑幕，没有你知道的太多了差评 07-22 前面几天又双忘记写更新了折腾了很多，加了自己的域名，把你知道的太多了弄出来了，并且修复了很多js的bug，把unpkg换成fastly.jsdelivr或者elemecdn，提升速度（竟然有人加了我友链，怎么知道这个网站的？） 08-12 前面几天又双叒忘记写更新了还是折腾了很多，按照冰糖红茶大佬们的方法加了不少东西，比如那个人潮汹涌模拟器（主页的）、文章点赞、无缝跳转等等，换成jsdelivr加速，同时也在最大化利用GoormIDE，不过在险些没有数据之后就尽可能迁移到了其它没有风险的平台。 08-25 最近在糖果屋群友们的建议和帮助下修改了很多功能,以后每隔一段时间都会写详细的日志而不是像前面简单概括了。 留言板的弹幕是真的像b站视频弹幕了，过一段时间修复了bug之后放教程 新增博客设置，做了一个极简风的主题，支持更换主题色，也可以换回之前的主题，可以禁用模糊效果和开启硬件加速提升性能 修复了部分排版bug，对safari进行了一些适应，感谢Apple Store和洪哥的帮助。 增加了hover的缩放效果，有层次感 优化动画 修复留言弹幕、右键菜单的bug并且把新版的代码更新到文章中 优化细节样式 新增最新文章标记 总算部署好朋友圈了！leancloud国内版垃圾！"},{"title":"早报","date":"2022-11-25T07:37:35.000Z","updated":"2023-06-23T07:25:57.146Z","comments":true,"path":"zaobao/index.html","permalink":"https://blog.youmingsama.cn/zaobao/index.html","excerpt":"","text":""}],"posts":[{"title":"rust学习资源与进阶资料","slug":"hello world/rust学习资源","date":"2022-11-08T00:00:00.000Z","updated":"2022-11-08T00:00:00.000Z","comments":true,"path":"posts/e0da0190/","link":"","permalink":"https://blog.youmingsama.cn/posts/e0da0190/","excerpt":"","text":"rust学习资源与进阶资料 2022/10/17 新增 smallnest/concurrency-programming-via-rust 《Rust 并发编程实战课》 2022/09/26 新增 Learn wgpu 中文版 , Vulkan Tutorial(Rust) 2022/08/24 新增 Rust 源码剖析 中文版 2022/08/24 新增 Boshen/javascript-parser-in-rust Writing a container in Rust 2022/07/05 新增 Visualizing memory layout of Rust’s data types 2022 年开源操作系统训练营 2022/07/02 新增 Building a Pixel Editor in Rust &amp; WebAssembly (and Javascript) Writing NES Emulator in Rust 2022/05/07 新增 Lisp interpreter in Rust 2022/05/07 新增 《Programming Rust, 2nd Edition》简单的翻译 和 rustlang-cn/Rustt 2022/04/25 新增一个链接 35 Rust Learning Resources Every Beginner Should Know in 2022 2022/04/19 新增一个进阶链接 Warrenren/inside-rust-std-library 2022/03/27 新增一个进阶链接 2022/03/15 新增一个基础链接 2022/03/13 新增一个进阶链接 2022/03/11 新增两个游戏开发相关的链接 基础 The Rust Programming Language 堪称 Rust 的 “The Book”，是目前最权威的 Rust 系统教程，入门必读，最近也更新到了 2021 版本。 中文版 (经常更新) rustwiki 中文版 Rust by Example 实例化的讲解方法，通过一个个可实际运行的例子去介绍 Rust 的特性和用法，有的时候，代码是最好的老师。 中文版 The Rust primer for beginners 给初学者的 Rust 中文教程。 Rust 入门秘籍 这是一本 Rust 的入门书籍，相比官方书籍《The Rust Programming Language》，本书要更详细、更具系统性，本书也尽量追求准确性。 Rust First Steps 微软的 Rust 教程，简短精炼，适合初学者。 官方中文 Rust Cookbook Rust 程序设计语言（Rust 官方教程简体中文版）的简要实例示例集合：展示了在 Rust 生态系统中，使用各类 crate 来完成常见编程任务的良好实践。 中文版 Rustlings 官方出品，涵盖大量小练习，打怪通关学习 Rust。 Jetbrains IDE 可以直接下载课程，编辑器内写代码做练习。 Learning Rust With Entirely Too Many Linked Lists 通过写双链表来学习 Rust Read Rust - Getting Started Read Rust 是一个集合了有价值的 Rust 文章 / 博客的网站，其中 Getting Started 部分有各种 Rust 知识点相关的十分优秀的文章。 Stanford CS 110L：Safety in Systems Programming This class is focused on safety and robustness in systems programming. We will use the Rust programming language as a vehicle to teach mental models and paradigms that have been shown to be helpful in preventing errors, and we will look at how these features have made their way back into C++. 2020 年课程的 B 站中文字幕版 2021 年课程主页、2022 年课程主页 Rust 语言圣经 (Rust 教程 Rust Course) rust-course 国人写的 Rust 教程，对 Rust 语言进行全面且深入的讲解，书中辅以生动的示例和习题。 Rust 官方文档中文教程 rust-lang-cn 组织翻译的官方文档，另外这个组织也翻译了很多 Rust 相关的书籍。 Visualizing memory layout of Rust’s data types 可视化了 Rust 的类型在内存中的布局，入门必看。 Rust 实践指南 zzy/rust-guide 《Rust 实践指南》，聚焦重要的主题，展示可能的解决方案。以开发中的实际问题为导向，以优雅的解决方案为目标，以完整的实例实践解决方案。 Bilibili：软件工艺师 微软 MVP，做了不少 C#、Go、Rust 的教程，其中 Rust 相关的有 Rust 编程语言入门教程 和 Rust Web 全栈开发教程 Rust Language Cheat Sheet quickref.me Rust cheatsheet quickref.me 是一个汇聚了大部分语言的语法索引页，其中也包含了 Rust, 可以帮助大家快速找到想用的语法。 rust-lang/api-guidelines 中文版：Rust API 编写指南 这是一组关于如何设计和呈现 Rust APIs 的建议。 这些建议主要由 Rust library 团队编写， 总结了 Rust 生态下构建标准库和其他 crates 的经验。 《Programming Rust, 2nd Edition》简单的翻译 第一版图灵社区有翻译：Rust 程序设计，第二版多了两章，可以考虑买第一版的电子版 pdf。 rustlang-cn/Rustt RustCn 翻译计划，翻译一些 Rust 的技术文章。 suhanyujie/article-transfer-rs 一些 Rust/Go 文章翻译 进阶 Rust Standard Library Reference The Rust Reference Rust 语言的 reference manual，你应该收藏好，以便于在对某个语言细节不清楚时在这里进行查阅。 中文版 The unsafe Book The Rustonomicon Rust 死灵书主要讲 Rust 高级特性，如何使用 unsafe Rust。 中文版 The Little Book of Rust Macros 对于 Rust 宏有详细的讲解，里面的注释很全面。 中文版 smallnest/concurrency-programming-via-rust 《Rust 并发编程实战课》 《Go 并发编程实战课》的作者鸟窝系统整理的 Rust 的并发编程的相关资料。主要是从入门入手，让大家了解和熟悉这些并发原语，在工作中用起来。 另外，mouse 姐姐也有相关的书将要出版《Rust Atomics and Locks: Low-Level Concurrency in Practice》。 Asynchronous Programming in Rust 不是很新的中文版 A Guide to Porting C/C++ to Rust The Rust FFI Omnibus 使用 Rust 编写代码用到其他语言的示例集合. 中文版 Jon Gjengset YouTube Channel (Crust of Rust Playlist) Rust Design Patterns 有许多问题具有共同的形式。由于事实上 Rust 并不完全是面向对象的，设计模式也与其他面向对象的编程语言不同。 细节不同的同时，因为他们有相同的形式，他们可以用同样的基本方法解决。 中文版 The Rust Performance Book 介绍很多优化 Rust 程序性能的工具、技巧、调试方法等方面的书。 Problem-solving with algorithms and data structures using Rust 国人写的一本 Rust 书籍，包括算法分析，基本数据结构和算法，外加一些实战。 Rust 源码剖析 中文版 国人写的一本 Rust 书籍，针对 Rust 语言本身和开源库的代码进行分析。 dtolnay/case-studies dtolnay 是 anyhow, thiserror, cxx 等库的作者，这是他对一些 tricky Rust code 的分析。 Bilibili：Databend Databend 社区持续做了不少 Rust 的公开课。仓库地址 Bilibili：爆米花胡了 这个 up 主做了很多 Rust 过程宏的视频教程。 Bilibili：喜欢历史的程序君 陈天在极客时间开了门 Rust 的课，同时也在持续输出一些 Rust 视频教程。 KAIST CS431: Concurrent Programming Github repo 本课程面向对并行计算机系统的现代理论和实践感兴趣的计算机科学（或相关学科）的高年级本科生（或研究生）。 Rust for the Polyglot Programmer 面对有经验的程序员的 Rust 指南。 High Assurance Rust: Developing Secure and Robust Software 本书介绍了如何构建我们可以合理信任 (justifiably trust) 的高性能软件。这意味着有足够的数据来支持对我们代码的功能和安全性的信心。可信性是高安全性 (high assurance) 软件的一个标志。 Warrenren/inside-rust-std-library 本书主要对 Rust 的标准库代码进行分析。按照内存相关，基本数据类型，ops Trait, Option 类型，Result 类型，Iterator，切片类型，智能指针类型等逐一进行源码分析。 有潜力的教程 Rust 101 Lecture Series 与伦敦帝国理工学院计算社会系合作的 Rust 系列讲座 Rust Lecture Series with Imperial College London’s Department of Computing Society Effective Rust 练习实战的小项目 知乎 - 学习 Rust 适合写什么练手项目？ Exercism.io course-rs/tokio-course 《Tokio 异步编程》翻译并扩展了 tokio 官网的教程， 深入讲述了如何编写 Rust 高并发异步程序 Github: cfsamson 这哥们喜欢用 Rust 实现一些小例子如：Futures、greenthreads、async、epoll 等。 Boshen/javascript-parser-in-rust [2022.08] A book on writing a JavaScript Parser in Rust 2022 年开源操作系统训练营 [2022.07] 教程共分为八章，主要展示如何从零开始，用 Rust 语言写一个基于 RISC-V 架构的类 Unix 内核。 Writing a container in Rust [2022.05] 用 Rust 写容器。 Lisp interpreter in Rust [2022.05] lisp-rs 项目用 Rust 实现了一个解释器，用于 Scheme 的一个小子集，即 Lisp 方言。 Implementing a size-bounded LRU cache with expiring entries for my DNS server (in Rust) [2022.03] 使用 Rust 实现一个有大小限制可过期的 LRU 缓存。 Implementing and Optimizing a Wordle Solver in Rust [2022.03] Jon Gjengset 的六小时一镜到底视频流教程，这次是实现一个 Wordle 求解器。 Writing a Programming Language (in Rust) [2022.02 updating] Implementing the NTFS filesystem in Rust [2022.02] Rust Latam: procedural macros workshop [2022.01 updating] 实战学习写 Rust 过程宏。 Rust Runtime 设计与实现 [2021.12] 系列文章主要介绍如何设计和实现一个基于 io-uring 的 Thread-per-core 模型的 Runtime。 Building a GUI app in Rust Building a web app in Rust [2021.10] 作者用 egui 库去实现了 newsapi 的客户端和网页端（WebAssembly）。 Rust 过程宏入门 (Risp (in (Rust) (Lisp))) [2021.07] Rust 实现 Lisp 解释器 Learning to Fly: Let’s simulate evolution in Rust! (pt 1) [2021.01] 利用神经网络和遗传算法创建一个进化模拟，并编译应用程序到 WebAssembly Building a Pixel Editor in Rust &amp; WebAssembly (and Javascript) [2020.08] 作者用 Rust 和 WebAssembly 做了个网页端的简陋版像素画板。 Writing NES Emulator in Rust [2020.08] Rust 实现 NES 模拟器，不过最后一章到现在还是 todo。 Building a DNS server in Rust [2020.06] pingCAP/talent-plan [2020.05] Rust 网络编程 TP 201: Practical Networked Applications in Rust TP 202: Distributed Systems in Rust Writing an OS in Rust 部分中文版 [2020.05] PNGme: An Intermediate Rust Project [2019.06] Implementing TCP [2019.05] 强烈推荐！Jon Gjengset 通过 Linux TUN/TAP 来实现 TCP 协议。三个视频加起来共 16 小时。 这个 up 主视频风格独特，内容有深度，录像不剪辑，每集时间巨长，好处就是可以了解一个完整项目的开发过程和解决问题的思路。 Learning Parser Combinators With Rust [2019.04] Build Your Own Shell using Rust [2018.11] So You Want to Build a Language VM [2018.07] 游戏开发相关 有哪些值得推荐的 Rust 游戏引擎或图形渲染库？ Rust GameDev WG Vulkan Tutorial(Rust) 这老哥给自己的 Vulkan Rust 绑定 vulkanalia 参考 Vulkan Tutorial 写的教程。 我们也可以用 ash 来参考着写，两个 Vulkan binding crate 语法很像。 The Ray Tracer Challenge [2022.02 updating] 这老哥用 Rust 从零写一个 Raytracer，并把 live coding 的过程也录制上传在系列视频链接 Vulkan with Rust by example 又是用 Rust 和 ash crate 来写 Vulkan 的一系列博文。 Ashen Aetna [2022.01 updating] 作者兴趣使然用 Rust 和 ash crate 来学习图形学的教程。 ash 是跨平台图形接口 Vulkan 的 Rust 绑定。 Unofficial Bevy Cheat Book Rust 游戏引擎 Bevy 的书。 中文版：Bevy 游戏引擎开发指南 Learn Wgpu 中文版 Wgpu 是 WebGPU API 规范的一个 Rust 实现。 WebGPU 是由 GPU for the Web Community Group 发布的一个规范。它的目的是允许网络代码以安全和可靠的方式访问 GPU 功能。 它通过模仿 Vulkan API，并将其转换为主机硬件使用的任何 API（DirectX、Metal、Vulkan）来实现。 很多 Rust 游戏引擎都基于这一层图形 HAL。 Tutorial: Writing a Tiny Rust Game Engine for Web [2022.01] Roguelike Tutorial in Rust + tcod [2020.04] Adventures in Rust: A Basic 2D Game [2018.02] 其他领域相关 The CLI Book The WebAssembly Book The Embedded Book An Experimental Course on Operating Systems Zero to Production in Rust (Building Backend Services) Rust 动态 This week in Rust Newsletter 每周更新一次，把最新的 Rust 资源推到你的邮箱，这是跟踪 Rust 最新技术与事件的好方法。 Discord Official Rust Community Server Official Rust Server Telegram Rust 众 飞书 Rust 中文社群 The Rust Sub Reddit Rust 语言开源杂志（2021）月刊 Rust 语言开源杂志（2022）季刊 各种汇总（Awesome 系列） Awesome Rust [A curated list of Rust code and resources] 针对 Rust 语言的 awesome lists，这里面汇集了各种各样的 Rust 库和资源，去参与或学习开源项目是当你入门后最好的进阶方法。 rust-learning 一个由社区维护的关于学习 Rust 的资源的汇总。 EthanYuan/Rust-Study-Resource 又是一个关于学习 Rust 的资源的汇总。 The Little Book of Rust Books Rust 相关书籍的汇总。 sger/RustBooks Rust 相关书籍的汇总。 sunface/fancy-rust Rust 酷库推荐。使用我们精心挑选的开源代码，让你的 Rust 项目 Fancy 起来！ EvanLi/Github-Ranking Github 中 Rust 库星星排名的 Top 100，每日刷新。 35 Rust Learning Resources Every Beginner Should Know in 2022 一篇推荐新手资源的文章 Podcast Rustacean Station Podcast RustTalk 主播：写代码的西瓜 Rust 语言中文社区 是一个相比干货分享的地方，偏文字，RustTalk 更侧重 “湿货”，不仅仅会介绍到 Rust 的设计理念，更多的回去挖掘 Rust 背后的奇人轶事。 博客 https://llever.com/ 包含很多 Rust 周报及相关博文的翻译，不过现在好像不更新了。 芽之家 同样是包含很多 Rust 周报及相关博文的翻译，同样好像不更新了😓 博客 RSS 名称 订阅链接 This Week in Rust https://this-week-in-rust.org/atom.xml Read Rust https://readrust.net/all/feed.rss Rust Reddit Hot https://reddit.0qz.fun/r/rust/hot.json Rust.cc https://rustcc.cn/rss Awesome Rust Weekly https://rust.libhunt.com/newsletter/feed Rust 精选 https://rustmagazine.github.io/rust_magazine_2021/rss.xml Rust on Medium https://medium.com/feed/tag/rust Rust GameDev WG https://gamedev.rs/rss.xml 知乎专栏 - 时光与精神小屋 https://rsshub.app/zhihu/zhuanlan/time-and-spirit-hut 酷熊 Amos fasterthanli https://fasterthanli.me/index.xml pretzelhammer/rust-blog https://www.ncameron.org/blog/rss/ Nick Cameron https://github.com/pretzelhammer/rust-blog/releases.atom FOLYD https://folyd.com/blog/feed.xml Alex Chi https://www.skyzh.dev/posts/index.xml 作为参考的学习路线 路线 1 Rust Study RoadMap 作者在文中提供了两种学习路线。 路线 2 通读 Rust by Example，把其中的例子都自己运行一遍，特别是对其中指出的错误用法也调试一遍。 通读 The Rust Programming Language，在进行了第一步后，已经基本对 Rust 的常用概念有所了解了，这个时候再读这本官方教程，进一步理解某些细节。 行了，到这一步后你就可以尝试做一个项目了，然后在做项目的过程中你一定会需要各种各样的库，请到 Crates 上搜索，寻找适合你需求的 crate，了解它们的用法，必要时查阅它们的源码。一开始写实际代码时，你肯定会很痛苦，Rust 编译器一定会不断地折磨你，这个时候不要放弃，返回去再看 Rust by Example 和 The Rust Programming Language，然后终有通过编译的那一刻，恭喜你，入坑了！ 常用站点 Crates Rust 类库 Docs.rs Rust 类库文档 Are we game yet 关于游戏开发 Are we web yet 关于 Web 开发 Are we (I)DE yet 关于 IDE rust-library-i18n Rust 中文文档，可以在 IDE 中使用 其他资料 The 10 books that helped me, as a hobbyist, on my journey to learn Rust to re-code a Django application Rustnote 某个网友的个人笔记 本文参考 https://rust-lang-cn.org/article/23 https://letsgetrusty.kartra.com/page/XDk8 https://rustcc.cn/ 本文转载转载自萤火之森","categories":[{"name":"print*,\"hello world!!!\"","slug":"print-hello-world","permalink":"https://blog.youmingsama.cn/categories/print-hello-world/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.youmingsama.cn/tags/rust/"}]},{"title":"新坑预定","slug":"摸鱼大师/新坑预定","date":"2021-08-01T00:00:00.000Z","updated":"2022-05-25T00:00:00.000Z","comments":true,"path":"posts/385296e3/","link":"","permalink":"https://blog.youmingsama.cn/posts/385296e3/","excerpt":"","text":"占位ing","categories":[{"name":"摸鱼大师","slug":"摸鱼大师","permalink":"https://blog.youmingsama.cn/categories/%E6%91%B8%E9%B1%BC%E5%A4%A7%E5%B8%88/"}],"tags":[{"name":"待定捏","slug":"待定捏","permalink":"https://blog.youmingsama.cn/tags/%E5%BE%85%E5%AE%9A%E6%8D%8F/"}]},{"title":"买耳机送老婆:水月雨ssp","slug":"摸鱼大师/水月雨ssp使用体验","date":"2021-08-01T00:00:00.000Z","updated":"2021-08-01T00:00:00.000Z","comments":true,"path":"posts/9e073fd6/","link":"","permalink":"https://blog.youmingsama.cn/posts/9e073fd6/","excerpt":"","text":"入门级HIFI：水月雨ssp上手指南（？ 水月雨一向以买老婆送耳机做为卖点之一，不过我这款便宜的ssp是不送立绘老婆的，毕竟他便宜嘛，之前朋友送过我我一条kxxs，这个是送水月娘的，便宜的ssp是没有老婆的各位。怎么？穷鬼不配拥有老婆（手动狗头），买这条耳机的初衷嘛，是在我的msrq被徒手掰断后，没错是徒手掰断。打算暂时选一款用来过渡的耳机，要求嘛？能以最便宜的加个能得到不错品质的耳机就再好不过了，不过在下实在没有勇气去尝试原道耳机（效果触发悔恨之泪），在打算上银船的情况下在官网恰好就逛到了ssp，做为ssr升级版，价格大概是银船的两倍=199.不知怎么回事就入手了（触发悔恨之类），可能是因为它盒子好看！！！！，盒子大概长下面这样。 关于听感表现嘛，个人感觉也就中规中矩，也就符合200这个价位耳机应该有的表现，并没有让我感到有任何超出200元耳机表现的地方，它的表现也就符合200元耳机最基本的要求，在前端设备是三灵3Mx的实际听感个人感觉高频真的超级刺耳，中频稍微给人的感觉会厚实一些，对于很多女声的表现上是不差的，啊，我这里听的是Aimer的六等星的夜。老早的歌了，Aimer天下第一。对于低频来说下潜比较好，听起来比较圆润，低频听起来的量感会比较足，官方也特意标注了女毒，不过啊女毒不至于，不过对于大多数女声的处理都挺不错的。嗯听一些ACG的是问题不大的。 花200软妹币买到了价值200软妹币的东西，不能说不亏，只能说血本无归。对于共产主义战士来说白嫖才是共产主义的终极目标。呜呜呜 今日的胜利水月娘的单方面胜利","categories":[{"name":"摸鱼大师","slug":"摸鱼大师","permalink":"https://blog.youmingsama.cn/categories/%E6%91%B8%E9%B1%BC%E5%A4%A7%E5%B8%88/"}],"tags":[{"name":"含泪入手","slug":"含泪入手","permalink":"https://blog.youmingsama.cn/tags/%E5%90%AB%E6%B3%AA%E5%85%A5%E6%89%8B/"},{"name":"水月雨","slug":"水月雨","permalink":"https://blog.youmingsama.cn/tags/%E6%B0%B4%E6%9C%88%E9%9B%A8/"}]},{"title":"京都读后感","slug":"虚假的文学少年/京都读后感","date":"2021-05-19T00:00:00.000Z","updated":"2021-05-19T00:00:00.000Z","comments":true,"path":"posts/bad5c14e/","link":"","permalink":"https://blog.youmingsama.cn/posts/bad5c14e/","excerpt":"","text":"川端康成的作品大概看的七七八八 差不多快看完了吧 雪国，千只鹤，古都这三本我是一起买的 说来惭愧雪国和千只鹤我早早就看完了 但是这本不到十万字的古都就被我将时间延长线将近拉长了一年 就是 各种各种事 即使闲置下来也没有想起这本大概只草草翻了几页的书 当目光偶然扫到它的时候 它已经被其他书挤到角落里了 当我再次打开它时候 很多东西不知道怎么说又无从说起 因为我其实并不明白也形容不出这是怎样一种感受 就像古都里所描绘的许多 花朵稀稀疏疏地飘落在樱花树下，有的还漂浮在池子的水面上。不过，大概也只有七八瓣的光景…… 关于千重子和苗子我也有很多很多话想说 好吧至少又可以水一篇博客了 在最后的最后这本书的末尾 千重子抓住红格子门，目送苗子远去。苗子始终没有回头。细小的雪花有些飘落在千重子的前发上，很快就消融了。大街还在沉睡中。 我想 可能京都再也找不到比这更好的宣传广告了","categories":[{"name":"文学","slug":"文学","permalink":"https://blog.youmingsama.cn/categories/%E6%96%87%E5%AD%A6/"}],"tags":[{"name":"文学","slug":"文学","permalink":"https://blog.youmingsama.cn/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"拆机翻车指南(","slug":"摸鱼大师/什么竟然翻车了？？","date":"2021-05-13T00:00:00.000Z","updated":"2021-05-13T00:00:00.000Z","comments":true,"path":"posts/2ad933a0/","link":"","permalink":"https://blog.youmingsama.cn/posts/2ad933a0/","excerpt":"","text":"我竟然翻车了！！！！！ 不得不感慨最近的天气可是真热阿，一摸散热精灵，吼，不愧是您阿散热精灵，哎呀，一边凉快去把你，说着我就拆开令人设计合力贴心的草工艺贴合后盖，说着清理大师翻出了它的清灰工具，艰难的打开坚硬的后盖准备来一次清理。 ps:三个月前刚显得慌，不知道抽什么分换了cpu风扇和显卡风扇，按理说说三个月后的今天也应该是洁净如新，但是打开后盖之后不得不感慨，不愧是您阿吸灰精灵 但是就向往昔无数次拆机一样，略显枯燥的熟悉的操作手法，呐动作就想像一个大师一样，最后合上后盖，一气呵成。当我觉得它应该理所当然的成功点亮时，它竟然开机自检的时候爆出了风扇90B的错误，经过仔细排查是cpu风扇它不转了！！！！！ 嗯难道是风扇没插，打开后盖，检查没问题阿，启动开机报错，打开后盖，报错。打开后盖，报错。打开后盖，报错。打开后盖，报错。 我武断的认为是风扇坏了，火速拿到售后处，扇，懂。经验老熟的师傅打开看了以下。嗯是要换风扇。但是没有现货，要过几天来拿。师傅下意识的问了以下插口是是不是三针的，我：对阿。师傅又象征性的看了以下，嗯那就是要换风扇了呢。我拿着插头若有所思，不知道在不在听师傅的话。阿不对是插头是4针的，我急忙看了以下接口啊有一个针被我同歪了，师傅给我拿了个镊子，让我轻轻的拨回来，我尝试了几下啊不行太难了，还是师傅您来您专业，师傅微微一笑，已经让人感受到了强者的气势，就想在维修和检查火箭最后发射前的例行检查，师傅的眼里有光。成了！！！ 果然在在成功的拨回后，这该死的cpu风扇它转了。 当然 最后一分钱没花！！！","categories":[{"name":"摸鱼大师","slug":"摸鱼大师","permalink":"https://blog.youmingsama.cn/categories/%E6%91%B8%E9%B1%BC%E5%A4%A7%E5%B8%88/"}],"tags":[{"name":"翻车","slug":"翻车","permalink":"https://blog.youmingsama.cn/tags/%E7%BF%BB%E8%BD%A6/"}]},{"title":"自定义化谷歌主题","slug":"摸鱼大师/谷歌摸鱼大法好","date":"2021-04-28T00:00:00.000Z","updated":"2021-04-28T00:00:00.000Z","comments":true,"path":"posts/63627b7c/","link":"","permalink":"https://blog.youmingsama.cn/posts/63627b7c/","excerpt":"","text":"自定义化谷歌主题 不管什么先来一句谷歌大法好坑定不会有问题，，天天对浏览器总有一天会审美疲劳，嗯对就像我，对这使用了很长的谷歌主题陷入了深深的沉思，有时候阿人心情不好的时候总想换个主题（？，比如说我，不过翻遍了谷歌商店都没有找到令我中意的主题，对于专业的强迫症人士来说一个让他看起来感到别扭的主题对它来说简直是一种另类的折磨，于是少年开始了自定义主题之旅。 那么应该如何开始呢 那当然是谷歌的文档阿，果不其然很快就能找到，介绍的超级详细，感觉完全不需要说一句废话，任何脱离官方文档的教程都是耍流氓， Chrome Theme Reference 既然知道了怎么制作主题，那就直接开始吧，当然更复杂的操作请自行摸索 第一步 新建文件夹，文件夹内定义mainifest.json 以我的主题为例内容是这样的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#123; &quot;name&quot;: &quot;youmingsama&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;description&quot;: &quot;夏日&quot;, &quot;manifest_version&quot;: 2, &quot;theme&quot;: &#123; &quot;images&quot;: &#123; &quot;theme_frame&quot;: &quot;images\\/theme_frame.png&quot;, &quot;theme_toolbar&quot;: &quot;images\\/theme_toolbar.png&quot;, &quot;theme_tab_background&quot;: &quot;images\\/theme_tab_background.png&quot;, &quot;theme_ntp_background&quot;: &quot;images\\/theme_ntp_background.png&quot; &#125;, &quot;colors&quot;: &#123; &quot;frame&quot;: [ 54, 48, 47 ], &quot;toolbar&quot;: [ 205, 210, 204 ], &quot;tab_text&quot;: [ 54, 48, 47 ], &quot;tab_background_text&quot;: [ 205, 210, 204 ], &quot;bookmark_text&quot;: [ 54, 48, 47 ], &quot;ntp_background&quot;: [ 255, 255, 255 ], &quot;ntp_text&quot;: [ 50, 50, 50 ], &quot;ntp_link&quot;: [ 6, 55, 116 ], &quot;button_background&quot;: [ 0, 0, 0, 0 ] &#125;, &quot;tints&quot;: &#123; &quot;buttons&quot;: [ 0.02, 0.07, 0.2 ] &#125;, &quot;properties&quot;: &#123; &quot;ntp_background_alignment&quot;: &quot;bottom&quot;, &quot;ntp_background_repeat&quot;: &quot;repeat&quot; &#125; &#125;&#125; 第二步 创建文件夹images 创建使用的图片，各个模块官方文档力都有介绍，这里就不在解释啦 第三部 打开谷歌开发这模式。在不济直接拖入就好啦，当然这里建议选择直接打包成可执行文件crx就好啦，如果直接拖拽的画可能会产生问题，如果拖拽的源文件的相对位置发生相对改变的时候，主题会加载失败，所以建议直接打包成可执行文件 可能会产生bug 因为没有对屏幕进行适配，在不同的屏幕下图片可能并不兼容，我这边是多屏，在我的竖屏上就出现了非常尴尬的画面，因为没有做适配，顶部会有一大段空白区域，查阅文档，也只有ntp_background_repeat这一个处理方法 ntp_background_repeat&quot; ntp_background_repeat&quot; : “no-repeat” This property element is used to control the repetition of the image element theme_ntp_background.It is specified as… “ntp_background_repeat” : &quot;VALUE&quot;In the place of VALUE you can enter either “repeat”, “no-repeat”, “repeat-x” or “repeat-y”. Depending upon the image you’ve created as the background you can choose to repeat the image along x-axis or y-axis or turn repeat off, since repeat is on by default! 于是我这边忘了取出上面一大部分空白区域，非常不情愿的用了 ntp_background_repeat&quot;: &quot;repeat,来遮盖住了尴尬的空白区域，但是不可避免的出现了图片重复。此乃下策！！！！如果有更好的解决方案请私信我。欧内该！！！ 效果图 以及并不完美的竖屏图","categories":[{"name":"摸鱼大师","slug":"摸鱼大师","permalink":"https://blog.youmingsama.cn/categories/%E6%91%B8%E9%B1%BC%E5%A4%A7%E5%B8%88/"}],"tags":[{"name":"谷歌","slug":"谷歌","permalink":"https://blog.youmingsama.cn/tags/%E8%B0%B7%E6%AD%8C/"}]},{"title":"并查集真的是太棒了","slug":"bug的炼金工坊/并查集真的是太棒了","date":"2021-04-23T00:00:00.000Z","updated":"2021-04-23T00:00:00.000Z","comments":true,"path":"posts/efa11b01/","link":"","permalink":"https://blog.youmingsama.cn/posts/efa11b01/","excerpt":"","text":"并查集真的是太棒了 这个月的leetcode简直就是查并集月啊，打卡没错一题，查并集？查并集？又是查并集！不会！不会！又不会！看题解！好耶我又会了？做题，我是废物。 之前在油管上看Robert Sedgewick巨，佬的视频，我觉得我行了（，但好像重来没有系统的整理过查并集和相关的知识。 在开始之前需要先了解一个概念 1. 动态连通性 并查集：并：合并，查：查找，集：集合。如果有下面的这样一个问题，问题的输入是一列整数对，其中每个类型都表示某种类型的对象，假如阿有一对整数p,q，就可以理解为p，q是相连的，我们假设相连是一种等价关系，就意味这有以下关系 自反性：p和p是相连的 对称性：如果p和q是相连的那么q和p也是相连的 传递性：如果p和q是相连的而且q和r是相连的那么p和也是相连的 等价关系能够把对象分为多个等价类，且两个对象相连时他们才属于同一个等价关系 目标：所以我们应该过滤掉没有意义的帧数对，也就是说如果所有的整数对都不能证明p和q是相连的，那么我们就把它输出，相反如果证明了是相连的那我们应该把他们忽略掉并继续处理下面的整数对。为了达到以上的效果我们需要用一个数据结构来保存这些整数对的信息，并来判断他们某一对象是否相连，于是我们把这个问题的通俗的叫做动态连通性问题 比如我们所熟知的网络，每时每刻就可能要处理数百万对象和数十亿次连接，所以我们需要一个算法帮我们快速的处理类似的问题。所以当我们处理两个可以连接的分量，那我们就可以把他加入到一个集合当中； 2.来设计算法思想 12345&gt;void UF(N)//初始化函数&gt;void unino(p,q)//添加连接&gt;int find(q)//查找所在的分量标识符&gt;bool connected(p,q)//判断是否存在于一个分量中&gt;int count()//计算连通分量的个数 于是我们就需要定义一种数据结果实现以上的思想因此我们需要 定义一种数据结构表示已知连接 实现以上方法 数据结构的性质将直接影响到算法的效率，我们可以用 触点为索引id[]做基本的数据结构来表示所有的分量 使用某个触点的名称做为分量的标识符，也因此每个分量都是由他的触点之一表示的 一开始每个触点都为一个独立的分量，所以我们把分量初始化为i 用find方法来判断它属于那个分量当中 coonected用来判断find(p)==find(q)，返回布尔值 unino用来连接连个这两个分量 3.先写个demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//// Created by youmingsama on 2021/4/22.//#include &quot;bits/stdc++.h&quot;using namespace std;int id[10000];int count1=0;int N=0;void UF(int id[],int *count,int N)&#123; *count=N; for (int i = 0; i &lt; N; ++i) &#123; id[i]=i; &#125;&#125;int count()&#123; return count1;&#125;int find(int p)&#123; while (p!=id[p])&#123; p=id[p]; &#125; return p;&#125;bool connected(int p,int q)&#123; return find(p)==find(q);&#125;void union1(int p, int q)&#123; int pRoot=find(p); int qRoot=find(q); if (pRoot==qRoot)&#123; return; &#125; id[pRoot]=qRoot; count1--;&#125;int main()&#123; int a[8],b[8]; int ans=6; cin&gt;&gt;N; UF(id,&amp;count1,N); for (int i = 0; i &lt; 8; ++i) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; int p=a[i]; int q=b[i]; if (connected(p,q)) continue; union1(p,q); cout&lt;&lt;p&lt;&lt;&quot;--&gt;&quot;&lt;&lt;q&lt;&lt;endl; &#125; cout&lt;&lt;count1; return 0;&#125; 关于不同的实现方法 对算法的核心处理无异于是对find函数和union，其他的函数都大同小异对算法的效率影响不大，所以这里我们重点来看find方法和union算法的实现 quick-find算法 一种实现方法是保证id[p]==id[q],这则说明当前p和q是连通的是属于同一个分量，也就说连通分量重的所有触点的id[]必须是相同的，这就意味着connected只需要判断id[p]==id[q]就能判断是否属于同一个连通分量。 如果属于同一个连通分量我们就不需要做任何操作，如果不是属于同一个连通分量我们就需要做连接操作啦。union(p,q)把两个分量合二为一就意味着id[]的值必须是相等的，等于两方任何一方的值(id[p] or id(q))。为此我们需要遍历数组把其中一个集合的id[]，变成另外一个集合的id[]值。 嘛简单整理以下就是： 12345678910111213141516&gt;find(p)&#123;&gt;return id[p]&gt;&#125;&gt;if connected(p,q)&gt;continue&gt;union(p,q)&#123;&gt;int pid=find(p);&gt;int pid=find(q);&gt;if pid==qid return;&gt;for i=0,i&lt;id.length;i++&#123; if (id[i]==pid)&#123; id[i]=qid; &#125; count--;&gt;&#125;&gt;&#125; 在qiuck算法中，find操作显然是很快的，因为它只需要访问id一次，但是对于处理较大型的问题，每一次执行unino都要扫描一id数组 如果使用quick-find算法来解决动态连通性问题最后只得到了一个连通分量，那么至少要调用N-1次union，那么数组访问至少要访问(N-4)(N-1),显然平方级别的在我们处理非常大型的项目上是很难接受的，所以我们需要更快的算法。 quick-union算法","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"}]},{"title":"碎碎念3","slug":"碎碎念/碎碎念three","date":"2021-04-11T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/2f9356bf/","link":"","permalink":"https://blog.youmingsama.cn/posts/2f9356bf/","excerpt":"","text":"","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://blog.youmingsama.cn/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://blog.youmingsama.cn/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"不知道在讲啥","slug":"不知道在讲啥","permalink":"https://blog.youmingsama.cn/tags/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%9C%A8%E8%AE%B2%E5%95%A5/"}]},{"title":"第一次的Cloudflare worker","slug":"hello world/clouldfare worker","date":"2021-03-07T00:00:00.000Z","updated":"2021-03-07T00:00:00.000Z","comments":true,"path":"posts/ea3732f5/","link":"","permalink":"https://blog.youmingsama.cn/posts/ea3732f5/","excerpt":"","text":"Cloudflare真好玩 在nisama强烈的推荐下我怀着好奇的心态开始了cloudflare的疯狂踩坑，无非是这一个月挺多了nisama关于‘啊无服务器实在是太爽啦’，‘白嫖真爽啊’，‘嗯，白嫖下次还白嫖’，Cloudflare（NYSE：NET）是一家总部位于旧金山的美国跨国科技企业，以向客户提供基于反向代理的内容分发网络（Content Delivery Network, CDN）及分布式域名解析服务（Distributed Domain Name Server）为主要业务。利用 Cloudflare 全球任播网络，Cloudflare可以帮助受保护站点抵御包拒绝服务攻击等网络攻击，确保该网站长期在线，同时提升网站的性能、加载速度以改善访客体验。嗯cloudflare是最富盛名的cdn服务商，不过虽然它很香但抵不住它贵啊，cloudflare上很多体验良好的服务都是收费的，当然一提到cdn最优秀的服务商当然是cloudflare（？当然对于cloudflare上提供的免费cdn当然没有逃过可爱的勤劳的中国人民撸羊毛的机会，于是你会简单不管是网站，各种稀奇古怪的应用甚至是各种梯子都在用cloudflare做CDN，毕竟入口带宽也是有限的，这就导致在用网高峰期甚至是日常使用的响应速度不尽如人意，当然也是因为毕竟也是国外的节点啦，下图为我2021年3月8日的测试结果。 1.1.1.1是一款免费的域名解析服务，也就是域名服务器，由CloudFlare与APNIC共同拥有与维护。该服务于2018年4月1日发表启用且被Cloudflare称为“互联网最快、以隐私优先的消费者端DNS服务”（the Internet’s fastest, privacy-first consumer DNS service） 当然做为一个正经人我并没有怎么薅过cloudflare的羊毛，当然让我对cloudflare直呼真香的也并他们的cdn而是他们的Cloudflare Workers！！不过在疯狂踩坑之前有必要了解一下和Cloudflare Workers有关的无服务器计算 关于这点我想cloudflare的文档提供了详细的解释 无服务器计算是一种按需提供后端服务的方法。无服务器架构允许用户编写和部署代码，而不必担心底层基础设施。从无服务器提供商获得后端服务的公司将根据其计算量来付费，而不必保留和支付固定数量的带宽或服务器，因为该服务可自动扩展。请注意，尽管称为无服务器，但它仍使用了物理服务器，只是开发人员不需要考虑它们的存在。 在Web早期，任何想要构建Web应用程序的人都必须拥有运行服务器所需的物理硬件，这是一项繁琐而昂贵的工作。 之后是云，可以远程租用固定数量的服务器或一定数量的服务器空间。租用这些固定服务器空间单元的开发人员和公司通常会过度购买，以确保流量或活动的激增不会因为超过每月限额而中断其应用程序。这意味着通常支付的大部分服务器空间都浪费了。云供应商已经引入了自动扩展模型来解决该问题，但是即使是自动扩展，也可能因为恶意活动激增（例如 DDoS 攻击）而产生非常昂贵的成本。 无服务器计算允许开发人员在灵活的“按需付费”的基础上购买后端服务，这意味着开发人员仅需为使用的服务付费。这就像从每月固定限额的手机数据套餐切换到只为实际使用的每个字节数据收费的套餐一样。 “无服务器”一词在某种程度上具有误导性，因为它仍然有服务器提供这些后端服务，但是所有服务器空间和基础设施问题都由提供商处理。无服务器意味着开发人员可以完全不用担心服务器。 什么是后端服务？前端和后端之间有什么区别？ 应用程序开发通常分为两个领域：前端和后端。前端是用户看到并与之交互的应用程序部分，例如视觉设计。后端是用户看不到的部分。其中包括应用程序文件所在的服务器以及持久存储用户数据和业务逻辑的数据库。 ![ 例如，我们可以想象一个卖音乐会门票的网站。当用户在浏览器窗口中键入请求时，浏览器会将请求发送到后端服务器，后端服务器以网站数据作为响应。然后，用户将看到网站的前端，该前端将包括文本、图像和供用户填写的表单字段。然后，用户可以与前端上的表单字段之一进行交互，以搜索他们喜欢的音乐表演。当用户单击“提交”时，这将触发另一个对后端的请求。后端代码检查其数据库，以查看是否存在具有该名称的表演者，如果存在，则会反馈下次表演的时间以及有多少可售的票。然后，后端会将数据传递回前端，前端将以用户能理解的方式显示结果。同样，当用户创建一个帐户并输入财务信息以购买票时，前端与后端之间将发生另一次来回通信。 无服务器计算可以提供什么样的后端服务？ 大多数无服务器提供商都为其客户提供数据库和存储服务，并且许多无服务器提供商还具有功能即服务（FaaS）平台，例如 Cloudflare Workers。这些平台可以在不存储任何数据的情况下在边缘执行代码。 无服务器计算的优势是什么？ 降低成本 – 无服务器计算通常具有很高的成本效益，因为传统的后端服务（服务器分配）云提供商经常导致用户为未使用的空间或空闲的 CPU 时间付费。 简化可扩展性 – 使用无服务器架构的开发人员不必担心扩展其代码的策略。无服务器供应商可按需处理所有扩展。 简化后端代码 – 使用 FaaS，开发人员可以创建简单的功能，这些功能独立地执行单个目的，例如进行 API 调用。 加快周转时间 – 无服务器架构可以大大缩短产品上市时间。开发人员无需通过复杂的部署过程实施错误修复和新功能，而是逐个添加和修改代码。 Cloudflare Workers 是什么？ Cloudflare Workers 是一个平台，用于使无服务器功能尽可能接近最终用户运行。本质上，无服务器代码本身是“缓存”在网络上的，并在收到正确类型的请求时运行。Cloudflare Workers 是根据 service workers API 用 JavaScript 编写的，这意味着它们可以使用 service workers 提供的所有功能。它们利用 Chrome V8 引擎执行。Cloudflare Workers 代码托管在 Cloudflare 遍布全球的庞大数据中心网络中。 Chrome V8，也称为“ V8”，是 Google 为编译、优化和执行 JavaScript 开发的 JavaScript 引擎。使用 V8 进行 JavaScript 代码执行，可大大减少 JavaScript workers 的启动时间，因此消除了大多数情况下的“冷启动”问题。V8 还进行了详细的安全漏洞分析，因此是安全运行 JavaScript 代码的理想选择。 什么是无服务器 JavaScript？ 无服务器 JavaScript 是包含全部或部分应用程序的 JavaScript 代码，仅在请求时运行，不在专有服务器上托管。它使开发人员能够构建在网络中运行的高性能、低延迟的无服务器应用程序，并避免了许多与其他无服务器应用程序相关的问题，例如冷启动。 无服务器 JavaScript 托管在边缘网络中或由 HTTP 缓存服务托管，后者存储内容以快速响应 HTTP 请求。开发人员可以编写和部署处理 HTTP 请求的 JavaScript 函数，在处理后再将请求一直传递到源站。 使用无服务器 JavaScript，可以通过在边缘运行代码来扩展现有应用程序的功能并改善用户体验，或者创建一个快速且高度可扩展的、全新的、完全无服务器的应用程序。Cloudflare Workers 就是无服务器 JavaScript 平台。 边缘计算是一种致力于使计算尽可能靠近数据源、以减少延迟和带宽使用的网络理念。简而言之，边缘计算意味着在云端运行更少的进程，将这些进程移动到本地，例如用户的计算机、IoT 设备或边缘服务器。将计算放到网络边缘可以最大程度地减少客户端和服务器之间必须进行的长距离通信量。 什么是 Varnish？ Varnish 是一个 Web 加速器，旨在加速 Web 应用程序并提高网站性能。它是一个缓存 HTTP 反向代理 ，这意味着它位于任何 Web 服务器的前端，并通过缓存或存储 Web 客户端经常请求的任何内容来加速往返于该服务器的 HTTP 流量。将 Varnish 配置语言（简称 VCL）与 Varnish 结合使用，开发人员就可以自定义 Varnish 如何管理 Web 请求。 在无服务器架构中使用 JavaScript 代替 VCL 有什么优势？ VCL 是一种配置语言，旨在使 Varnish 缓存易于配置；它不是一种成熟的编程语言。VCL 不够灵活，无法构建或扩展强大的应用程序。与 JavaScript 相比，它的功能有限。此外，VCL 不在 Varnish 实施之外使用，因此大多数开发人员都不熟悉 VCL。而 JavaScript 则应用广泛，并且已经广泛用于构建应用程序。在无服务器架构中使用 JavaScript 可使开发人员以他们熟悉的语言构建完整的应用程序。 无服务器 JavaScript 使更广泛的开发人员群体能够利用边缘上的无服务器计算，并允许这些开发人员构建更多种类的应用程序。 为什么使用无服务器 JavaScript 构建应用程序可以减少延迟？ 无服务器 JavaScript 在 HTTP 缓存网络中运行，该网络比源站上托管的代码更接近最终用户。因此，请求不必一路传递到源站再一路回传，应用程序对用户交互的响应速度更快。缓存网络在地理上分布的边缘位置越多，延迟时间就越短。 无服务器 JavaScript 何时运行？ 在无服务器模型中，应用程序被分解为函数，并且函数代码在响应某些事件时运行，在其他情况下不会运行。触发无服务器 JavaScript 执行的事件是 HTTP 请求。开发人员可以自定义其 JavaScript 函数响应的 HTTP 请求的类型，以及如何更改或实现 HTTP 请求。 什么是 HTTP 缓存？ HTTP 缓存是指服务器或浏览器保存对用户 HTTP 请求的响应的副本，以便更快答复以后的请求。CDN 服务器就是 HTTP 缓存的例子。一些 HTTP 缓存服务使开发人员可以自定义 HTTP 缓存如何为其应用程序运行。 Cloudflare 是一个 HTTP 缓存边缘网络，其中包含遍布世界各地的数据中心，它允许开发人员在网络边缘编写和部署自己的 JavaScript。在 Cloudflare 网络中，HTTP 缓存不在任何特定服务器中进行，而是在最接近 HTTP 请求来源的数据中心内进行。 与 service workers 相比，Cloudflare Workers 有何独特之处？ 使用 Cloudflare Workers 和使用 service workers 的一个主要区别是，service workers 是在客户端运行的，必须由用户的浏览器下载，而 Cloudflare Workers 在 Cloudflare 网络的边缘运行，介于用户和 Internet 的其余部分之间，有效地在网络内部运行。 什么是 service workers？ Service workers 是浏览器下载并运行以为用户创建自定义体验的脚本。Service workers 使在浏览器中实现推送通知、后台同步和脱机运行等功能成为可能。它们使用 JavaScript 编写，可以在 HTTP 请求到达 Internet 之前拦截、修改和响应请求。 Service worker 可以通过两种方式处理 HTTP 流量： Service workers 可以响应 HTTP 请求而无需联系 Web 服务器 Service workers 可以修改 HTTP 请求和响应 cloudflare worker使用教程 没有比官方文档更加详细的东西了，cloudflare文档本身内容就非常的详实，所以只需要仔细阅读cloudflare文档就能非常轻松的达到上手的程度，另一方面cloudflare worker本身使用就非常的简单，官方提供了多种语言可以供编写，JavaScript，rust，c，c++，python等等，所以对于绝大部分使用者来说语言都不会成为他们的障碍，当然官方首推是是JavaScript。 关于额度问题 关于这点我的回答是完全够用， 每天免费提供100000个请求 每天 100,000 次读取操作 每天 1,000 次写入、删除、列出操作 提供大概1GB的kv储存空间 另外付费版也就每月5dollar啦（，但是对于个人使用来看免费额度已经非常非常够用了，其次主要还是白嫖能带来满满的满足感（一拳一个白嫖怪）。 hello cloudflare worker 接下来我们可以基于以上来写一个非常非常简单的栗子。 API 比如说我们现在想要写一个每日可以返回bing壁纸的动态api，首先我们需要获取bing壁纸的url，打开f12就能很简单的获取到壁纸链接，这里我们就直接粗暴的直接打开worker，当然你也可以按照官方文档安装Workers CLI，按照官方的步骤一步一步的来，这里仅仅进行一个非常简单的演示，我们很容易就能编写到以下代码 1234567891011121314151617async function handleRequest(request) &#123; const req = request const urlStr = req.url const urlObj = new URL(urlStr) const path = urlObj.href.substr(urlObj.origin.length) const domain = (urlStr.split(&#x27;/&#x27;))[2] let day = 0 let destinationURL = &quot;&quot; try &#123; if (path.startsWith(&#x27;/bing&#x27;)) &#123; let day = urlObj.searchParams.get(&#x27;day&#x27;) const destination = await JSON.parse(await (await fetch(`https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=$&#123;day&#125;&amp;n=1`)).text())[&quot;images&quot;][0][&quot;url&quot;] destinationURL = `https://cn.bing.com/$&#123;destination&#125;` return fetch(destinationURL) &#125; finally&#123; console.log(&quot;error&quot;) &#125; 这里的fetch()是 XMLHttpRequest 的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。 然后直接吧这段代码粘贴到worker里面就行啦 创建worker的时候会自动分配一个子域名，当然支持自定义域名，具体请参考文档 然后访问子域名/bing就好啦，可以看到状态码是200，这里我的子域名是https://empty-credit-b440.youmingsama.workers.dev/ 于是就可以得到https://empty-credit-b440.youmingsama.workers.dev/bing 就得到了我们想要的图片啦 于是下面几个api，实现几乎的原理和bing大同小异 获取bing的每日一图 https://empty-credit-b440.youmingsama.workers.dev/bing 获取bing图片信息 https://empty-credit-b440.youmingsama.workers.dev/mbing 默认返回json格式 返回一张随机生成的动漫人物头像 https://empty-credit-b440.youmingsama.workers.dev/suijilaopo 随机返回一言: https://empty-credit-b440.youmingsama.workers.dev/hitokoto 默认返回txt格式 今日网抑云 https://empty-credit-b440.youmingsama.workers.dev/wangyiyun 默认返回txt格式 反代网站：*************************************************************************************************（高度加密） cloudflare大法好 worker加上kv储存可玩性可拓展性非常强，这里演示的API仅仅是一种最简单的使用方法，不仅仅是网站，各种快速搭建的应用，cloudflare更让我们看到了无限的可能。 所以白嫖大法好","categories":[{"name":"print*,\"hello world!!!\"","slug":"print-hello-world","permalink":"https://blog.youmingsama.cn/categories/print-hello-world/"}],"tags":[{"name":"cloudflare","slug":"cloudflare","permalink":"https://blog.youmingsama.cn/tags/cloudflare/"}]},{"title":"简单聊聊http","slug":"hello world/http","date":"2021-03-04T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/60b00a8/","link":"","permalink":"https://blog.youmingsama.cn/posts/60b00a8/","excerpt":"","text":"那就来简单的聊聊http吧 http（Hypertext Transfer Protocol）超文本传输协议，简单的来概况就是一个简单的请求响应协议，我们熟悉的web就是建立再一个http上的王国。 超文本传输协议是约定俗成的叫法更加正确的叫法应该称作：超文本转移协议 来聊聊URI和URL URI（uniform Resoutce Identifier）即统一资源标识符，URL(uniform Resoutce Locator),即统一资源定位符，鸡蛋但来说我们日常再浏览器地址栏输入的一般开始就是URL当然也是一个URI，通过这个我们就可以定位到我们需要查找的资源 URL和URI并没有严格的区分，但是URL是URI的一个子集，也就是是每个URL都是一个URI但是每个URI不一定三个URL，因为URI还包括一个URN（统一资源名称）的子类，URN只是用来命名资源而并非定位资源，几乎自会在极少数情况下使用 来聊聊http的历史演变和发展历程 一.HTTP/0.9 HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。 最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。 1GET /index.html 上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。 协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。 123&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 服务器发送完毕，就关闭TCP连接。 二 HTTP/1.0 1996年5月，HTTP/1.0 版本发布，内容大大增加。 首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。 其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。 再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。 其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。 2.1请求格式 下面是一个1.0版的HTTP请求的例子。 123GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */* 可以看到，这个格式与0.9版有很大变化。 第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。 2.2 回应格式 服务器的回应如下。 12345678910HTTP/1.0 200 OK Content-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 回应的格式是&quot;头信息 + 一个空行（\\r\\n） + 数据&quot;。其中，第一行是&quot;协议版本 + 状态码（status code） + 状态描述&quot;。 2.3 Content-Type 字段 关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。 下面是一些常见的Content-Type字段的值。 text/plain text/html text/css image/jpeg image/png image/svg+xml audio/mp4 video/mp4 application/javascript application/pdf application/zip application/atom+xml 这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。 除了预定义的类型，厂商也可以自定义类型。 1application/vnd.debian.binary-package 上面的类型表明，发送的是Debian系统的二进制数据包。 MIME type还可以在尾部使用分号，添加参数。 1Content-Type: text/html; charset=utf-8 上面的类型表明，发送的是网页，而且编码是UTF-8。 客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。 1Accept: */* 上面代码中，客户端声明自己可以接受任何格式的数据。 MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。 123&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;!-- 等同于 --&gt;&lt;meta charset=&quot;utf-8&quot; /&gt; 2.4 Content-Encoding 字段 由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。 123Content-Encoding: gzipContent-Encoding: compressContent-Encoding: deflate 客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。 1Accept-Encoding: gzip, deflate 2.5缺点 HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。 TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。 为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。 1Connection: keep-alive 这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。 1Connection: keep-alive 一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 三、HTTP/1.1 1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议。 3.1 持久连接 1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。 1Connection: close 目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。 3.2 管道机制 1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。 3.3 Content-Length 字段 一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。 1Content-Length: 3495 上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。 在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。 3.4 分块传输编码 使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。 对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用&quot;流模式&quot;（stream）取代&quot;缓存模式&quot;（buffer）。 因此，1.1版规定可以不使用Content-Length字段，而使用&quot;分块传输编码&quot;（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。 1Transfer-Encoding: chunked 每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。 1234567891011121314151617HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked25This is the data in the first chunk1Cand this is the second one3con8sequence0 3.5 其他功能 1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。 另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。 1Host: www.example.com 有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。 3.6 缺点 虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为&quot;队头堵塞&quot;（Head-of-line blocking）。 为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。 四、SPDY 协议 2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。 这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。 五、HTTP/2 HTTP/2 诞生于 8 年前 Google 一封 SPDY 协议白皮书。5 年前，RFC7540 和 RFC7541 的发布正式确立了 HTTP/2。5 年过去了，支持 HTTP/2 的浏览器的市场占有率达到了 96.88%。 5.1 二进制协议 HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;（frame）：头信息帧和数据帧。 二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。 5.2 多工 HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了&quot;队头堵塞&quot;。 举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。 这样双向的、实时的通信，就叫做多工（Multiplexing）。 5.3 数据流 因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 5.4 头信息压缩 HTTP/1.1 时代，消息本体已经用 gzip 进行了压缩、或者二进制文件（如 woff 字体等）也内置了压缩格式。但是，响应头、状态码并没有经过任何压缩、直接使用明文传输，对于不会经常变动的如 User-Agent、Cookie、状态码等每次请求会造成数百字节流量的浪费。 HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 5.5 服务器推送 HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。 对http的展望 虽然目前http2再目前的浏览器市场占有决定碾压的优势，http3的诞生也让人们对未来发展充满了憧憬，HTTP/3 和 HTTP/2 以及 HTTP/1.1 最大的不同应该是 HTTP/3 颠覆了 HTTP 使用 TCP 的「传统」，新版的UDP会更加快速稳定，也会更加安全。 链接 五分钟看懂http3 什么是http3","categories":[{"name":"print*,\"hello world!!!\"","slug":"print-hello-world","permalink":"https://blog.youmingsama.cn/categories/print-hello-world/"}],"tags":[{"name":"http","slug":"http","permalink":"https://blog.youmingsama.cn/tags/http/"}]},{"title":"滑动窗口不也挺好的嘛","slug":"bug的炼金工坊/滑动窗口","date":"2021-02-04T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/de1f8121/","link":"","permalink":"https://blog.youmingsama.cn/posts/de1f8121/","excerpt":"","text":"滑动窗口不也挺好的吗.jpg 这个月大胆预测一波，这个月可能是leetcode的滑动窗口月，先提前开个坑（，毕竟上个月的查并集月已经在写了已经在写了（雾。 643. 子数组最大平均数 I 给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。 示例： 123输入：[1,12,-5,-6,50,3], k = 4输出：12.75解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 提示： 1 &lt;= k &lt;= n &lt;= 30,000。 所给数据范围 [-10,000，10,000]。 非常典型的滑动窗口类型题目，不过暴力嘛很容易超时，当然如果你之前做过滑动窗口类型的题目的话，这题肯定一眼就看出来了.jpg。当然代码也在意料之中的很简单。 1234567891011121314class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; int sum=0; for (int i=0;i&lt;k;i++)&#123; sum+=nums[i]; &#125; double maxsum=sum; for (int i=k;i&lt;nums.length;i++)&#123; sum=sum+nums[i]-nums[i-k]; maxsum=Math.max(sum,maxsum); &#125; return maxsum/k; &#125;&#125; 1208. 尽可能使字符串相等 给你两个长度相同的字符串，s 和 t。 将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。 用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。 如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。 如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。 示例 1： 123输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, cost = 3输出：3解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。 示例 2： 123输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, cost = 3输出：1解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。 示例 3： 123输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, cost = 0输出：1解释：你无法作出任何改动，所以最大长度为 1。 提示： 1 &lt;= s.length, t.length &lt;= 10^5 0 &lt;= maxCost &lt;= 10^6 s 和 t 都只含小写英文字母。 这题也是滑动窗口类型的题耶，滑动窗口月实锤！！！！，这题也是滑动窗口诶，这题的滑动窗口使用双指针来维护，right指针不变，让left指针来缩小范围即可，简单题我重拳出击，困难题我唯唯诺诺（。 123456789101112131415class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; int cost = 0, right = 0, left = 0, maxLength = 0; while (right &lt; s.length()) &#123; cost += Math.abs(s.charAt(right) - t.charAt(right)); while (cost &gt; maxCost) &#123;//如果条件不满足 cost -= Math.abs(s.charAt(left) - t.charAt(left)); left++; &#125; maxLength = Math.max(maxLength, right - left + 1); right++; &#125; return maxLength; &#125;&#125; ps：有人指出这题严格来说不算是滑动窗口，严格来说应该是双指针，两者的区别在于「滑动窗口」是一类问题本身，「双指针」是解决一类二分查找问题的通用优化方法。或者说滑动窗口」本身并不是解决问题的一种方法（或者说算法），它其实就是这个问题本身。我们需要做的是寻找合适的数据结构来「维护」这个「滑动窗口」，比如说第一题典型的滑动窗口 1423. 可获得的最大点数 几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例 1： 123输入：cardPoints = [1,2,3,4,5,6,1], k = 3输出：12解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 123输入：cardPoints = [2,2,2], k = 2输出：4解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。 示例 3： 123输入：cardPoints = [9,7,7,9,7,7,9], k = 7输出：55解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。 示例 4： 123输入：cardPoints = [1,1000,1], k = 1输出：1解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5： 12输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3输出：202 提示： 1 &lt;= cardPoints.length &lt;= 10^5 1 &lt;= cardPoints[i] &lt;= 10^4 1 &lt;= k &lt;= cardPoints.length emmmmm这题我一开始就陷入了误区，慌慌忙忙开始敲代码，这题既然求最大的点数之和，我们只需要维护最小的滑动窗口就行了，知道了这点之后就变得很简单了 12345678910111213141516171819class Solution &#123; public int maxScore(int[] cardPoints, int k) &#123; int n = cardPoints.length; // 滑动窗口大小为 n-k int windowSize = n - k; // 选前 n-k 个作为初始值 int sum = 0; for (int i = 0; i &lt; windowSize; ++i) &#123; sum += cardPoints[i]; &#125; int minSum = sum; for (int i = windowSize; i &lt; n; ++i) &#123; // 滑动窗口每向右移动一格，增加从右侧进入窗口的元素值，并减少从左侧离开窗口的元素值 sum += cardPoints[i] - cardPoints[i - windowSize]; minSum = Math.min(minSum, sum); &#125; return Arrays.stream(cardPoints).sum() - minSum; &#125;&#125; 978. 最长湍流子数组 当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组： 若 i &lt;= k &lt; j，当 k 为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]； 或 若 i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k 为奇数时， A[k] &lt; A[k+1]。 也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。 返回 A 的最大湍流子数组的长度。 示例 1： 123输入：[9,4,2,10,7,8,8,1,9]输出：5解释：(A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5]) 示例 2： 12输入：[4,8,12,16]输出：2 示例 3： 12输入：[100]输出：1 提示： 1 &lt;= A.length &lt;= 40000 0 &lt;= A[i] &lt;= 10^9 这题我们根据定义可能会存在arr[right-1]&lt;arr[right]&amp;&amp;arr[right]&gt;arr[right+1]或者arr[right-1]&gt;arr[right]&amp;&amp;arr[right]&lt;arr[right-1]，这两种情况需要把right向右移动一个单位，此外当无法满足这两种情况时需要另left=right。 当窗口的长度为1时，需要把left和right都右移一个单位 123456789101112131415161718192021222324252627class Solution &#123; public int maxTurbulenceSize(int[] arr) &#123; int n = arr.length; int ret = 1; int left = 0, right = 0; while (right &lt; n - 1) &#123; if (left == right) &#123; if (arr[left] == arr[left + 1]) &#123; left++; &#125; right++; &#125; else &#123; if (arr[right - 1] &lt; arr[right] &amp;&amp; arr[right] &gt; arr[right + 1]) &#123; right++; &#125; else if (arr[right - 1] &gt; arr[right] &amp;&amp; arr[right] &lt; arr[right + 1]) &#123; right++; &#125; else &#123; left = right; &#125; &#125; ret = Math.max(ret, right - left + 1); &#125; return ret; &#125;&#125; 485. 最大连续 1 的个数 给定一个二进制数组， 计算其中最大连续 1 的个数。 示例： 123输入：[1,1,0,1,1,1]输出：3解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3. 提示： 输入的数组只包含 0 和 1 。 输入数组的长度是正整数，且不超过 10,000。 这题有了上面几题的经验和模板应该很容易看出来了.jpg 12345678910111213141516class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int left = 0, right = 0; int ans = 0; while (right &lt; nums.length) &#123; if (nums[right] == 1) &#123; right++; &#125; else &#123; right++; left = right; &#125; ans = Math.max(ans, right - left); &#125; return ans; &#125;&#125; 1004. 最大连续1的个数 III 给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。 返回仅包含 1 的最长（连续）子数组的长度。 示例 1： 12345输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2输出：6解释： [1,1,1,0,0,1,1,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2： 12345输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3输出：10解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 10。 提示： 1 &lt;= A.length &lt;= 20000 0 &lt;= K &lt;= A.length A[i] 为 0 或 1 这题看了半天没想到怎么用滑动数组，这里其实不用去计算1的数量，我们只需要去维护0的数量小于2的滑动窗口就好了,想通了这一点之后就变得很简单了，代码的话是常规滑动数组的写法，也没什么好说的，总之就是很简单.jpg 123456789101112131415161718class Solution &#123; public int longestOnes(int[] A, int K) &#123; int n = A.length; int left = 0, lsum = 0, rsum = 0; int ans = 0; for (int right = 0; right &lt; n; ++right) &#123; rsum += 1 - A[right]; while (lsum &lt; rsum - K) &#123; lsum += 1 - A[left]; ++left; &#125; ans = Math.max(ans, right - left + 1); &#125; return ans; &#125;&#125; 1052. 爱生气的书店老板 今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。 在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。 请你返回这一天营业下来，最多有多少客户能够感到满意的数量。 示例： 12345输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3输出：16解释：书店老板在最后 3 分钟保持冷静。感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16. 提示： 1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000 0 &lt;= customers[i] &lt;= 1000 0 &lt;= grumpy[i] &lt;= 1 这题也是典型的滑动窗口，这题灵活的运用了数组customer和grumpy的关系，代码实现倒是很简单，弹前提是活用customer和grumpy的关系，代码实现倒是很常规 123456789101112131415161718192021class Solution &#123; public int maxSatisfied(int[] customers, int[] grumpy, int X) &#123; int total = 0; int n = customers.length; for (int i = 0; i &lt; n; i++) &#123; if (grumpy[i] == 0) &#123; total += customers[i]; &#125; &#125; int increase = 0; for (int i = 0; i &lt; X; i++) &#123; increase += customers[i] * grumpy[i]; &#125; int maxIncrease = increase; for (int i = X; i &lt; n; i++) &#123; increase = increase - customers[i - X] * grumpy[i - X] + customers[i] * grumpy[i]; maxIncrease = Math.max(maxIncrease, increase); &#125; return total + maxIncrease; &#125;&#125; 这是二月最后一道滑动窗口题啦，这我我最后的波纹啦，jojo！！！！ 395. 至少有 K 个重复字符的最长子串 给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。 示例 1： 123输入：s = &quot;aaabb&quot;, k = 3输出：3解释：最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。 示例 2： 123输入：s = &quot;ababbc&quot;, k = 2输出：5解释：最长子串为 &quot;ababb&quot; ，其中 &#x27;a&#x27; 重复了 2 次， &#x27;b&#x27; 重复了 3 次。 提示： 1 &lt;= s.length &lt;= 104 s 仅由小写英文字母组成 1 &lt;= k &lt;= 105 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int longestSubstring(String s, int k) &#123; int ans = 0; int len = s.length(); char[] cs = s.toCharArray(); int[] cnt = new int[26]; for (int curKind = 1; curKind &lt;= 26; curKind++) &#123; //对于限定的字符数量的条件下进行滑动窗口 Arrays.fill(cnt, 0); int left = 0, right = 0; //totalKind:窗口内所有字符类型数量，sumKind:窗口内满足出现次数不少于k的字符类型数量 int totalKind = 0, sumKind = 0; while (right &lt; len)&#123; int rightIndex = cs[right] - &#x27;a&#x27;; cnt[rightIndex]++; if (cnt[rightIndex] == 1) totalKind++; if (cnt[rightIndex] == k) sumKind++; //当总字符种类数量不满足限定的字符种类数量，需要被迫移动左指针来减少总字符种类数量 while (totalKind &gt; curKind) &#123; int leftIndex = cs[left] - &#x27;a&#x27;; if (cnt[leftIndex] == 1) totalKind--; if (cnt[leftIndex] == k) sumKind--; cnt[leftIndex]--; left++; &#125; if (totalKind == sumKind) ans = Math.max(ans, right - left + 1); //主动移动右指针 right++; &#125; &#125; return ans; &#125;&#125; 嗯这的确是leetcode本月最后一道滑动窗口题，二月最后一道滑动窗口题发出了它最后的波纹，二月的题我几乎每道题都打了，注意是几乎是几乎，也就是说还有几道因为大过年的懒得刷，还有令我唯唯诺诺的困难题，嗯！！！二月勋章没拿到呢！！！！","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.youmingsama.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"蒟蒻弱弱弱弱弱","slug":"蒟蒻弱弱弱弱弱","permalink":"https://blog.youmingsama.cn/tags/%E8%92%9F%E8%92%BB%E5%BC%B1%E5%BC%B1%E5%BC%B1%E5%BC%B1%E5%BC%B1/"}]},{"title":"Sissy Sky","slug":"Roman/Sissy sky","date":"2020-12-09T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/a79ea1c9/","link":"","permalink":"https://blog.youmingsama.cn/posts/a79ea1c9/","excerpt":"","text":"好久时间没有看过柯南了！！！78仍然在那里水剧情，水一集，两集，三集…几百集，熟练的打开b站，鼠标滑轮不停往下滑，粗暴的划过1000多集，熟悉的单元剧，熟悉的柯学，熟悉的情节，但是唯一不同的是片尾曲！！！！是片尾曲！！！！突然的插播一句，这次bilibili动画大选我们的haibara ai是第八诶，反观其他的柯学人物，emmmmm，哦原来是需要从下往上划啊（。灰原哀？那个无情的搜索引擎？任劳任怨的工具人？啊，sherry！！嗯没错就是她","categories":[{"name":"Roman","slug":"Roman","permalink":"https://blog.youmingsama.cn/categories/Roman/"}],"tags":[{"name":"歌歌","slug":"歌歌","permalink":"https://blog.youmingsama.cn/tags/%E6%AD%8C%E6%AD%8C/"}]},{"title":"朝と夜の物語","slug":"Roman/朝と夜の物語","date":"2020-12-09T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/43fc1bb6/","link":"","permalink":"https://blog.youmingsama.cn/posts/43fc1bb6/","excerpt":"","text":"","categories":[{"name":"Roman","slug":"Roman","permalink":"https://blog.youmingsama.cn/categories/Roman/"}],"tags":[{"name":"物语系列","slug":"物语系列","permalink":"https://blog.youmingsama.cn/tags/%E7%89%A9%E8%AF%AD%E7%B3%BB%E5%88%97/"}]},{"title":"哀酱","slug":"呐！/我哀美如画","date":"2020-12-09T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/d015c452/","link":"","permalink":"https://blog.youmingsama.cn/posts/d015c452/","excerpt":"","text":"","categories":[{"name":"呐！","slug":"呐！","permalink":"https://blog.youmingsama.cn/categories/%E5%91%90%EF%BC%81/"}],"tags":[{"name":"jpg","slug":"jpg","permalink":"https://blog.youmingsama.cn/tags/jpg/"}]},{"title":"杂谈：异度之刃2","slug":"game/杂谈：异度之刃2","date":"2020-12-08T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/929895af/","link":"","permalink":"https://blog.youmingsama.cn/posts/929895af/","excerpt":"","text":"youmingsamakkskkksk 回航","categories":[{"name":"游戏","slug":"游戏","permalink":"https://blog.youmingsama.cn/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://blog.youmingsama.cn/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"杂谈：异度之刃2","slug":"硬件改装/杂谈：异度之刃2","date":"2020-12-08T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/929895af/","link":"","permalink":"https://blog.youmingsama.cn/posts/929895af/","excerpt":"","text":"youmingsamakkskkksk","categories":[{"name":"游戏","slug":"游戏","permalink":"https://blog.youmingsama.cn/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://blog.youmingsama.cn/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"java多线程原理篇大概","slug":"hello world/java多线程原理篇大概","date":"2020-11-08T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/7126b21b/","link":"","permalink":"https://blog.youmingsama.cn/posts/7126b21b/","excerpt":"","text":"这大概是传说中的原理篇 当然其中会参杂一些其他的东西，（失礼了 1.先来看看Java内存模型 线程间如何通信？即：线程之间以何种机制来交换信息 线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序 有两种并发模型可以解决这两个问题： 消息传递并发模型 共享内存并发模型 这两种模型之间的区别如下表所示： 我们看出来了在Java中，使用的是共享内存并发模型。 Java内存模型的抽象结构 运行时内存的划分 先谈一下运行时数据区，下面这张图相信大家一点都不陌生： 对于每一个线程来说，栈都是私有的，而堆是共有的。 也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量。 所以，内存可见性是针对的共享变量。 既然堆是共享的，为什么在堆中会有内存不可见问题？ 这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为cpu访问缓存区比访问内存要快得多。 线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。 Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。JMM的抽象示意图如图所示： 从图中可以看出： 1. 所有的共享变量都存在主内存中。 2. 每个线程都保存了一份该线程使用到的共享变量的副本。 3. 如果线程A与线程B之间要通信的话，必须经历下面2个步骤： 1. 线程A将本地内存A中更新过的共享变量刷新到主内存中去。 2. 线程B到主内存中去读取线程A之前已经更新过的共享变量。 所以，线程A无法直接访问线程B的工作内存，线程间通信必须经过主内存。 注意，根据JMM的规定，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。 所以线程B并不是直接去主内存中读取共享变量的值，而是先在本地内存B中找到这个共享变量，发现这个共享变量已经被更新了，然后本地内存B去主内存中读取这个共享变量的新值，并拷贝到本地内存B中，最后线程B再读取本地内存B中的新值。 那么怎么知道这个共享变量的被其他线程更新了呢？这就是JMM的功劳了，也是JMM存在的必要性之一。JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。 Java中的volatile关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized关键字不仅保证可见性，同时也保证了原子性（互斥性）。在更底层，JMM通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员的方便理解，提出了happens-before，它更加的简单易懂，从而避免了去理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。 JMM与Java内存区域划分的区别与联系 上面两小节分别提到了JMM和Java运行时内存区域的划分，这两者既有差别又有联系： 区别 两者是不同的概念层次。JMM是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。 联系 都存在私有数据区域和共享数据区域。一般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。 实际上，他们表达的是同一种含义，这里不做区分。 2.重排序和happens-before 什么是重排序？ 计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。 为什么指令重排序可以提高性能？ 简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，流水线技术产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。 但是，流水线技术最害怕中断，恢复中断的代价是比较大的，所以我们要想尽办法不让流水线中断。指令重排就是减少中断的一种技术。 我们分析一下下面这个代码的执行情况： 12a = b + c;d = e - f ; 先加载b、c（注意，即有可能先加载b，也有可能先加载c），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。 为了减少这个停顿，我们可以先加载e和f,然后再去加载add(b,c),这样做对程序（串行）是没有影响的,但却减少了停顿。既然add(b,c)需要停顿，那还不如去做一些有意义的事情。 综上所述，指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。 指令重排一般分为以下三种： 编译器优化重排 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令并行重排 现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。 内存系统重排 由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。 指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。 顺序一致性模型与JMM的保证 顺序一致性模型是一个理论参考模型，内存模型在设计的时候都会以顺序一致性内存模型作为参考。 数据竞争与顺序一致性 当程序未正确同步的时候，就可能存在数据竞争。 数据竞争：在一个线程中写一个变量，在另一个线程读同一个变量，并且写和读没有通过同步来排序。 如果程序中包含了数据竞争，那么运行的结果往往充满了不确定性，比如读发生在了写之前，可能就会读到错误的值；如果一个线程程序能够正确同步，那么就不存在数据竞争。 Java内存模型（JMM）对于正确同步多线程程序的内存一致性做了以下保证： 如果程序是正确同步的，程序的执行将具有顺序一致性。 即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。 这里的同步包括了使用volatile、final、synchronized等关键字来实现多线程下的同步。 如果程序员没有正确使用volatile、final、synchronized，那么即便是使用了同步（单线程下的同步），JMM也不会有内存可见性的保证，可能会导致你的程序出错，并且具有不可重现性，很难排查。 所以如何正确使用volatile、final、synchronized，是我们应该去了解的。后面会有专门的章节介绍这几个关键字的内存语义及使用。 顺序一致性模型 顺序一致性内存模型是一个理想化的理论参考模型，它为我们提供了极强的内存可见性保证。 顺序一致性模型有两大特性： 一个线程中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。 不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是原子性的，且立刻对所有线程可见。 关于原子操作这里先不做阐述 为了理解这两个特性，我们举个例子，假设有两个线程A和B并发执行，线程A有3个操作，他们在程序中的顺序是A1-&gt;A2-&gt;A3，线程B也有3个操作，B1-&gt;B2-&gt;B3。 假设正确使用了同步，A线程的3个操作执行后释放锁，B线程获取同一个锁。那么在顺序一致性模型中的执行效果如下所示： 操作的执行整体上有序，并且两个线程都只能看到这个执行顺序。 假设没有使用同步，那么在顺序一致性模型中的执行效果如下所示： 操作的执行整体上无序，但是两个线程都只能看到这个执行顺序。之所以可以得到这个保证，是因为顺序一致性模型中的每个操作必须立即对任意线程可见。 但是JMM没有这样的保证。 比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，这个写操作根本没有被当前线程所执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才对其他线程可见。在这种情况下，当前线程和其他线程看到的执行顺序是不一样的。 JMM中同步程序的顺序一致性效果 在顺序一致性模型中，所有操作完全按照程序的顺序串行执行。但是JMM中，临界区内（同步块或同步方法中）的代码可以发生重排序（但不允许临界区内的代码“逃逸”到临界区之外，因为会破坏锁的内存语义）。 虽然线程A在临界区做了重排序，但是因为锁的特性，线程B无法观察到线程A在临界区的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。 同时，JMM会在退出临界区和进入临界区做特殊的处理，使得在临界区内程序获得与顺序一致性模型相同的内存视图。 由此可见，JMM的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门。 JMM中未同步程序的顺序一致性效果 对于未同步的多线程程序，JMM只提供最小安全性：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。 为了实现这个安全性，JVM在堆上分配对象时，首先会对内存空间清零，然后才会在上面分配对象（这两个操作是同步的）。 JMM没有保证未同步程序的执行结果与该程序在顺序一致性中执行结果一致。因为如果要保证执行结果一致，那么JMM需要禁止大量的优化，对程序的执行性能会产生很大的影响。 未同步程序在JMM和顺序一致性内存模型中的执行特性有如下差异： 1. 顺序一致性保证单线程内的操作会按程序的顺序执行；JMM不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是JMM保证单线程下的重排序不影响执行结果） 2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。（因为JMM不保证所有操作立即可见） 3. JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读写操作都具有原子性。 happens-before 什么是happens-before? 一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。 JMM考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。 而对于程序员，JMM提供了happens-before规则（JSR-133规范），满足了程序员的需求——**简单易懂，并且提供了足够强的内存可见性保证。**换言之，程序员只要遵循happens-before规则，那他写的程序就能保证在JMM中具有强的内存可见性。 JMM使用happens-before的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证。 happens-before关系的定义如下： 1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 2. 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。 happens-before关系本质上和as-if-serial语义是一回事。 as-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。 总之，如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。 天然的happens-before关系 在Java中，有以下天然的happens-before关系： 程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start规则：如果线程A执行操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作、 join规则：如果线程A执行操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 举例： 1234int a = 1; // A操作int b = 2; // B操作int sum = a + b;// C 操作System.out.println(sum); 根据以上介绍的happens-before规则，假如只有一个线程，那么不难得出： 1231&gt; A happens-before B 2&gt; B happens-before C 3&gt; A happens-before C 注意，真正在执行指令的时候，其实JVM有可能对操作A &amp; B进行重排序，因为无论先执行A还是B，他们都对对方是可见的，并且不影响执行结果。 如果这里发生了重排序，这在视觉上违背了happens-before原则，但是JMM是允许这样的重排序的。 所以，我们只关心happens-before规则，不用关心JVM到底是怎样执行的。只要确定操作A happens-before操作B就行了。 重排序有两类，JMM对这两类重排序有不同的策略： 会改变程序执行结果的重排序，比如 A -&gt; C，JMM要求编译器和处理器都不许禁止这种重排序。 不会改变程序执行结果的重排序，比如 A -&gt; B，JMM对编译器和处理器不做要求，允许这种重排序。 3.Volatile 之前在我们有说过要好好来聊聊Volatile，由于上次篇幅有限所以就不了了之了（毕竟上次写了一万多字啊 嗯现在我们来看看Volatile Volatile是什么啊，我们为什么要用Volatile，仔细想想啊如果有时我们只是 为了简单的读写一两个实例字段而使用同步的话看起来好像有点划不来。毕竟什么地方能出错呢，可是现代处理器和编译器出错的可能非常大。 原因如下： 有处理器的计算机能够暂时在寄存器或者本地缓存中保存内存值，于是造成的结果就是运行在不同的处理器上的线程可能看到的是同一个内存位置会有不同的值。 虽然我们可以改变指令的顺序使吞吐量达到最大化，编译器不会选择可能改变代码语义的顺序，但是编译器有一个假定，认为只有在代码中有显式修改指令时才会改变，然而，特殊情况是，内存值有可能被线程改变。 这种时候我们使用锁来保护可能会被多线程访问的代码，这个时候这种问题显然不存在。Volatile则为实例字段的同步访问供了一种免锁机制。 内存可见性 在Java内存模型那一章我们介绍了JMM有一个主内存，每个线程有自己私有的工作内存，工作内存中保存了一些变量在主内存的拷贝。 内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。 之前说了两个概念 重排序 为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。 happens-before规则 是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。 那么问题来了Volatile的呢 volatile的内存语义 在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能： 保证变量的内存可见性 禁止volatile变量与普通变量重排序（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”） 内存可见性 以一段示例代码开始： 123456789101112131415public class VolatileExample &#123; int a = 0; volatile boolean flag = false; public void writer() &#123; a = 1; // step 1 flag = true; // step 2 &#125; public void reader() &#123; if (flag) &#123; // step 3 System.out.println(a); // step 4 &#125; &#125;&#125; 在这段代码里，我们使用volatile关键字修饰了一个boolean类型的变量flag。 所谓内存可见性，指的是当一个线程对volatile修饰的变量进行写操作（比如step 2）时，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对volatile修饰的变量进行读操作（比如step 3）时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。 在这一点上，volatile与锁具有相同的内存效果，volatile变量的写和锁的释放具有相同的内存语义，volatile变量的读和锁的获取具有相同的内存语义。 假设在时间线上，线程A先自行方法writer方法，线程B后执行reader方法。那必然会有下图： 而如果flag变量没有用volatile修饰，在step 2，线程A的本地内存里面的变量就不会立即更新到主内存，那随后线程B也同样不会去主内存拿最新的值，仍然使用线程B本地内存缓存的变量的值a = 0，flag = false 禁止重排序 在JSR-133之前的旧的Java内存模型中，是允许volatile变量与普通变量重排序的。那上面的案例中，可能就会被重排序成下列时序来执行： 线程A写volatile变量，step 2，设置flag为true； 线程B读同一个volatile，step 3，读取到flag为true； 线程B读普通变量，step 4，读取到 a = 0； 线程A修改普通变量，step 1，设置 a = 1； 可见，如果volatile变量与普通变量发生了重排序，虽然volatile变量能保证内存可见性，也可能导致普通变量读取错误。 所以在旧的内存模型中，volatile的写-读就不能与锁的释放-获取具有相同的内存语义了。为了提供一种比锁更轻量级的线程间的通信机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序。 编译器还好说，JVM是怎么还能限制处理器的重排序的呢？它是通过内存屏障来实现的。 什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用： 阻止屏障两侧的指令重排序； 强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。 注意这里的缓存主要指的是CPU缓存，如L1，L2等 编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个比较保守的JMM内存屏障插入策略，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是： 在每个volatile写操作前插入一个StoreStore屏障； 在每个volatile写操作后插入一个StoreLoad屏障； 在每个volatile读操作后插入一个LoadLoad屏障； 在每个volatile读操作后再插入一个LoadStore屏障。 大概示意图是这个样子： 再逐个解释一下这几个屏障。注：下述Load代表读操作，Store代表写操作 LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，这个屏障会吧Store1强制刷新到内存，保证Store1的写入操作对其它处理器可见。 LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能 对于连续多个volatile变量读或者连续多个volatile变量写，编译器做了一定的优化来提高性能，比如： 第一个volatile读; LoadLoad屏障； 第二个volatile读； LoadStore屏障 再介绍一下volatile与普通变量的重排序规则: 如果第一个操作是volatile读，那无论第二个操作是什么，都不能重排序； 如果第二个操作是volatile写，那无论第一个操作是什么，都不能重排序； 如果第一个操作是volatile写，第二个操作是volatile读，那不能重排序。 举个例子，我们在案例中step 1，是普通变量的写，step 2是volatile变量的写，那符合第2个规则，这两个steps不能重排序。而step 3是volatile变量读，step 4是普通变量读，符合第1个规则，同样不能重排序。 但如果是下列情况：第一个操作是普通变量读，第二个操作是volatile变量读，那是可以重排序的： 1234567// 声明变量int a = 0; // 声明普通变量volatile boolean flag = false; // 声明volatile变量// 以下两个变量的读操作是可以重排序的int i = a; // 普通变量读boolean j = flag; // volatile变量读 volatile的用途 从volatile的内存语义上来看，volatile可以保证内存可见性且禁止重排序。 在保证内存可见性这一点上，volatile有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁可以保证整个临界区代码的执行具有原子性。所以在功能上，锁比volatile更强大；在性能上，volatile更有优势。 在禁止重排序这一点上，volatile也是非常有用的。比如我们熟悉的单例模式，其中有一种实现方式是“双重锁检查”，比如这样的代码： 12345678910111213141516public class Singleton &#123; private static Singleton instance; // 不使用volatile关键字 // 双重锁检验 public static Singleton getInstance() &#123; if (instance == null) &#123; // 第7行 synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); // 第10行 &#125; &#125; &#125; return instance; &#125;&#125; 如果这里的变量声明不使用volatile关键字，是可能会发生错误的。它可能会被重排序： 1234567891011instance = new Singleton(); // 第10行// 可以分解为以下三个步骤1 memory=allocate();// 分配内存 相当于c的malloc2 ctorInstanc(memory) //初始化对象3 s=memory //设置s指向刚分配的地址// 上述三个步骤可能会被重排序为 1-3-2，也就是：1 memory=allocate();// 分配内存 相当于c的malloc3 s=memory //设置s指向刚分配的地址2 ctorInstanc(memory) //初始化对象 而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候另一个线程B执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！ 所以JSR-133对volatile做了增强后，volatile的禁止重排序功能还是非常有用的。 总之说了半天我们终于磕到锁了 首先需要明确的一点是：Java多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁。 还有一点需要注意的是，我们常听到的类锁其实也是对象锁。 Java类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁。 Synchronized关键字 说到锁，我们通常会谈到synchronized这个关键字。它翻译成中文就是“同步”的意思。 我们通常使用synchronized关键字来给一段代码或一个方法上锁。它通常有以下三种形式： 1234567891011121314151617// 关键字在实例方法上，锁为当前实例public synchronized void instanceLock() &#123; // code&#125;// 关键字在静态方法上，锁为当前Class对象public static synchronized void classLock() &#123; // code&#125;// 关键字在代码块上，锁为括号里面的对象public void blockLock() &#123; Object o = new Object(); synchronized (o) &#123; // code &#125;&#125; 我们这里介绍一下“临界区”的概念。所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。在上面的例子中，如果synchronized关键字在方法上，那临界区就是整个方法内部。而如果是使用synchronized代码块，那临界区就指的是代码块内部的区域。 通过上面的例子我们可以看到，下面这两个写法其实是等价的作用： 1234567891011// 关键字在实例方法上，锁为当前实例public synchronized void instanceLock() &#123; // code&#125;// 关键字在代码块上，锁为括号里面的对象public void blockLock() &#123; synchronized (this) &#123; // code &#125;&#125; 同理，下面这两个方法也应该是等价的： 1234567891011// 关键字在静态方法上，锁为当前Class对象public static synchronized void classLock() &#123; // code&#125;// 关键字在代码块上，锁为括号里面的对象public void blockLock() &#123; synchronized (this.getClass()) &#123; // code &#125;&#125; 几种锁 Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是： 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态 无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，这里就不再进行赘述。 几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。 关于锁降级有两点说明： 1.不同于大部分文章说锁不能降级，实际上HotSpot JVM 是支持锁降级的 2.上面提到的Stop The World期间，以及安全点，这些知识是属于JVM的知识范畴，本文不做细讲。 下面分别介绍这几种锁以及它们之间的升级。 youmingsama编辑中 呐呐呐youmingsama持续编辑中绘麻天下第一！！！是的呢 ！！！！","categories":[{"name":"print*,\"hello world!!!\"","slug":"print-hello-world","permalink":"https://blog.youmingsama.cn/categories/print-hello-world/"}],"tags":[{"name":"java!!!","slug":"java","permalink":"https://blog.youmingsama.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.youmingsama.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"golang杂耍大师混乱的笔记","slug":"hello world/golang杂耍大师混乱的笔记","date":"2020-05-04T00:00:00.000Z","updated":"2020-05-04T00:00:00.000Z","comments":true,"path":"posts/8f098f8e/","link":"","permalink":"https://blog.youmingsama.cn/posts/8f098f8e/","excerpt":"","text":"本文截选至the way to go 中文版 从字符串中读取内容 函数 strings.NewReader(str) 用于生成一个 Reader 并读取字符串中的内容，然后返回指向该 Reader 的指针，从其它类型读取内容的函数还有： Read() 从 []byte 中读取内容。 ReadByte() 和 ReadRune() 从字符串中读取下一个 byte 或者 rune。 字符串与其它类型的转换 与字符串相关的类型转换都是通过 strconv 包实现的。 该包包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：strconv.IntSize。 任何类型 T 转换为字符串总是成功的。 针对从数字类型转换到字符串，Go 提供了以下函数： strconv.Itoa(i int) string 返回数字 i 所表示的字符串类型的十进制数。 strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string 将 64 位浮点型的数字转换为字符串，其中 fmt 表示格式（其值可以是 'b'、'e'、'f' 或 'g'），prec 表示精度，bitSize 则使用 32 表示 float32，用 64 表示 float64。 将字符串转换为其它类型 tp 并不总是可能的，可能会在运行时抛出错误 parsing &quot;…&quot;: invalid argument。 针对从字符串类型转换为数字类型，Go 提供了以下函数： strconv.Atoi(s string) (i int, err error) 将字符串转换为 int 型。 strconv.ParseFloat(s string, bitSize int) (f float64, err error) 将字符串转换为 float64 型。 利用多返回值的特性，这些函数会返回 2 个值，第 1 个是转换后的结果（如果转换成功），第 2 个是可能出现的错误，因此，我们一般使用以下形式来进行从字符串到其它类型的转换： 1val, err = strconv.Atoi(s) 时间和日期 time 包为我们提供了一个数据类型 time.Time（作为值使用）以及显示和测量时间和日期的功能函数。 当前时间可以使用 time.Now() 获取，或者使用 t.Day()、t.Minute() 等等来获取时间的一部分；你甚至可以自定义时间格式化字符串，例如： fmt.Printf(&quot;%02d.%02d.%4d\\n&quot;, t.Day(), t.Month(), t.Year()) 将会输出 21.07.2011。 Duration 类型表示两个连续时刻所相差的纳秒数，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。 包中的一个预定义函数 func (t Time) Format(layout string) string 可以根据一个格式化字符串来将一个时间 t 转换为相应格式的字符串，你可以使用一些预定义的格式，如：time.ANSIC 或 time.RFC822。 一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，这听起来很奇怪，但看下面这个例子你就会一目了然： 1fmt.Println(t.Format(&quot;02 Jan 2006 15:04&quot;)) 输出： 121 Jul 2011 10:31 其它有关时间操作的文档请参阅 官方文档 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot; &quot;time&quot;)var week time.Durationfunc main() &#123; t := time.Now() fmt.Println(t) // e.g. Wed Dec 21 09:52:14 +0100 RST 2011 fmt.Printf(&quot;%02d.%02d.%4d\\n&quot;, t.Day(), t.Month(), t.Year()) // 21.12.2011 t = time.Now().UTC() fmt.Println(t) // Wed Dec 21 08:52:14 +0000 UTC 2011 fmt.Println(time.Now()) // Wed Dec 21 09:52:14 +0100 RST 2011 // calculating times: week = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec week_from_now := t.Add(time.Duration(week)) fmt.Println(week_from_now) // Wed Dec 28 08:52:14 +0000 UTC 2011 // formatting times: fmt.Println(t.Format(time.RFC822)) // 21 Dec 11 0852 UTC fmt.Println(t.Format(time.ANSIC)) // Wed Dec 21 08:56:34 2011 // The time must be 2006-01-02 15:04:05 fmt.Println(t.Format(&quot;02 Jan 2006 15:04&quot;)) // 21 Dec 2011 08:52 s := t.Format(&quot;20060102&quot;) fmt.Println(t, &quot;=&gt;&quot;, s) // Wed Dec 21 08:52:14 +0000 UTC 2011 =&gt; 20111221&#125; 输出的结果已经写在每行 // 的后面。 如果你需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 time.After 或者 time.Ticker 另外，time.Sleep（d Duration） 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。 测试多返回值函数的错误 Go 语言的函数经常使用两个返回值来表示执行是否成功：返回某个值以及 true 表示成功；返回零值（或 nil）和 false 表示失败（第 4.4 节）。当不使用 true 或 false 的时候，也可以使用一个 error 类型的变量来代替作为第二个返回值：成功执行的话，error 的值为 nil，否则就会包含相应的错误信息（Go 语言中的错误类型为 error: var err error，我们将会在第 13 章进行更多地讨论）。这样一来，就很明显需要用一个 if 语句来测试执行结果；由于其符号的原因，这样的形式又称之为 comma,ok 模式（pattern）。 在第 4.7 节的程序 string_conversion.go 中，函数 strconv.Atoi 的作用是将一个字符串转换为一个整数。之前我们忽略了相关的错误检查： 1anInt, _ = strconv.Atoi(origStr) 如果 origStr 不能被转换为整数，anInt 的值会变成 0 而 _ 无视了错误，程序会继续运行。 这样做是非常不好的：程序应该在最接近的位置检查所有相关的错误，至少需要暗示用户有错误发生并对函数进行返回，甚至中断程序。 我们在第二个版本中对代码进行了改进： 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)func main() &#123; var orig string = &quot;ABC&quot; // var an int var newS string // var err error fmt.Printf(&quot;The size of ints is: %d\\n&quot;, strconv.IntSize) // anInt, err = strconv.Atoi(origStr) an, err := strconv.Atoi(orig) if err != nil &#123; fmt.Printf(&quot;orig %s is not an integer - exiting with error\\n&quot;, orig) return &#125; fmt.Printf(&quot;The integer is %d\\n&quot;, an) an = an + 5 newS = strconv.Itoa(an) fmt.Printf(&quot;The new string is: %s\\n&quot;, newS)&#125; 这是测试 err 变量是否包含一个真正的错误（if err != nil）的习惯用法。如果确实存在错误，则会打印相应的错误信息然后通过 return 提前结束函数的执行。我们还可以使用携带返回值的 return 形式，例如 return err。这样一来，函数的调用者就可以检查函数执行过程中是否存在错误了。 习惯用法 123456value, err := pack1.Function1(param1)if err != nil &#123; fmt.Printf(&quot;An error occured in pack1.Function1 with parameter %v&quot;, param1) return err&#125;// 未发生错误，继续执行： 由于本例的函数调用者属于 main 函数，所以程序会直接停止运行。 如果我们想要在错误发生的同时终止程序的运行，我们可以使用 os 包的 Exit 函数： 习惯用法 1234if err != nil &#123; fmt.Printf(&quot;Program stopping with error %v&quot;, err) os.Exit(1)&#125; （此处的退出代码 1 可以使用外部脚本获取到） 有时候，你会发现这种习惯用法被连续重复地使用在某段代码中。 当没有错误发生时，代码继续运行就是唯一要做的事情，所以 if 语句块后面不需要使用 else 分支。 示例 2：我们尝试通过 os.Open 方法打开一个名为 name 的只读文件： 123456f, err := os.Open(name)if err != nil &#123; return err&#125;doSomething(f) // 当没有错误发生时，文件对象被传入到某个函数中doSomething 示例 3：可以将错误的获取放置在 if 语句的初始化部分： 习惯用法 1234if err := file.Chmod(0664); err != nil &#123; fmt.Println(err) return err&#125; 示例 4：或者将 ok-pattern 的获取放置在 if 语句的初始化部分，然后进行判断： 习惯用法 123if value, ok := readData(); ok &#123;…&#125; 注意事项 如果您像下面一样，没有为多返回值的函数准备足够的变量来存放结果： 123456789func mySqrt(f float64) (v float64, ok bool) &#123; if f &lt; 0 &#123; return &#125; // error case return math.Sqrt(f),true&#125;func main() &#123; t := mySqrt(25.0) fmt.Println(t)&#125; 您会得到一个编译错误：multiple-value mySqrt() in single-value context。 正确的做法是： 12t, ok := mySqrt(25.0)if ok &#123; fmt.Println(t) &#125; 注意事项 2 当您将字符串转换为整数时，且确定转换一定能够成功时，可以将 Atoi 函数进行一层忽略错误的封装： 1234func atoi (s string) (n int) &#123; n, _ = strconv.Atoi(s) return&#125; 实际上，fmt 包最简单的打印函数也有 2 个返回值： 1count, err := fmt.Println(x) // number of bytes printed, nil or 0, error 当打印到控制台时，可以将该函数返回的错误忽略；但当输出到文件流、网络流等具有不确定因素的输出对象时，应该始终检查是否有错误发生 or-range 结构 这是 Go 特有的一种的迭代结构，您会发现它在许多情况下都非常有用。它可以迭代任何一个集合（包括数组和 map，详见第 7 和 8 章）。语法上很类似其它语言中 foreach 语句，但您依旧可以获得每次迭代所对应的索引。一般形式为：for ix, val := range coll &#123; &#125;。 要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值（译者注：如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值）。一个字符串是 Unicode 编码的字符（或称之为 rune）集合，因此您也可以用它迭代字符串： 123for pos, char := range str &#123;...&#125; 每个 rune 字符和索引在 for-range 循环中是一一对应的。它能够自动根据 UTF-8 规则识别 Unicode 编码的字符。 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; str := &quot;Go is a beautiful language!&quot; fmt.Printf(&quot;The length of str is: %d\\n&quot;, len(str)) for pos, char := range str &#123; fmt.Printf(&quot;Character on position %d is: %c \\n&quot;, pos, char) &#125; fmt.Println() str2 := &quot;Chinese: 日本語&quot; fmt.Printf(&quot;The length of str2 is: %d\\n&quot;, len(str2)) for pos, char := range str2 &#123; fmt.Printf(&quot;character %c starts at byte position %d\\n&quot;, char, pos) &#125; fmt.Println() fmt.Println(&quot;index int(rune) rune char bytes&quot;) for index, rune := range str2 &#123; fmt.Printf(&quot;%-2d %d %U &#x27;%c&#x27; % X\\n&quot;, index, rune, rune, rune, []byte(string(rune))) &#125;&#125; 输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556The length of str is: 27Character on position 0 is: G Character on position 1 is: o Character on position 2 is: Character on position 3 is: i Character on position 4 is: s Character on position 5 is: Character on position 6 is: a Character on position 7 is: Character on position 8 is: b Character on position 9 is: e Character on position 10 is: a Character on position 11 is: u Character on position 12 is: t Character on position 13 is: i Character on position 14 is: f Character on position 15 is: u Character on position 16 is: l Character on position 17 is: Character on position 18 is: l Character on position 19 is: a Character on position 20 is: n Character on position 21 is: g Character on position 22 is: u Character on position 23 is: a Character on position 24 is: g Character on position 25 is: e Character on position 26 is: ! The length of str2 is: 18character C starts at byte position 0character h starts at byte position 1character i starts at byte position 2character n starts at byte position 3character e starts at byte position 4character s starts at byte position 5character e starts at byte position 6character : starts at byte position 7character starts at byte position 8character 日 starts at byte position 9character 本 starts at byte position 12character 語 starts at byte position 15index int(rune) rune char bytes0 67 U+0043 &#x27;C&#x27; 431 104 U+0068 &#x27;h&#x27; 682 105 U+0069 &#x27;i&#x27; 693 110 U+006E &#x27;n&#x27; 6E4 101 U+0065 &#x27;e&#x27; 655 115 U+0073 &#x27;s&#x27; 736 101 U+0065 &#x27;e&#x27; 657 58 U+003A &#x27;:&#x27; 3A8 32 U+0020 &#x27; &#x27; 209 26085 U+65E5 &#x27;日&#x27; E6 97 A512 26412 U+672C &#x27;本&#x27; E6 9C AC15 35486 U+8A9E &#x27;語&#x27; E8 AA 9E 请将输出结果和进行对比。 我们可以看到，常用英文字符使用 1 个字节表示，而汉字（严格来说，“Chinese: 日本語”的Chinese应该是Japanese**）使用 3 个字符表示。 命名的返回值（named return variables） 如下 里的函数带有一个 int 参数，返回两个 int 值；其中一个函数的返回值在函数调用时就已经被赋予了一个初始零值。 getX2AndX3 与 getX2AndX3_2 两个函数演示了如何使用非命名返回值与命名返回值的特性。当需要返回多个非命名返回值时，需要使用 () 把它们括起来，比如 (int, int)。 命名返回值作为结果形参（result parameters）被初始化为相应类型的零值，当需要返回的时候，我们只需要一条简单的不带参数的return语句。需要注意的是，即使只有一个命名返回值，也需要使用 () 括起来 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;var num int = 10var numx2, numx3 intfunc main() &#123; numx2, numx3 = getX2AndX3(num) PrintValues() numx2, numx3 = getX2AndX3_2(num) PrintValues()&#125;func PrintValues() &#123; fmt.Printf(&quot;num = %d, 2x num = %d, 3x num = %d\\n&quot;, num, numx2, numx3)&#125;func getX2AndX3(input int) (int, int) &#123; return 2 * input, 3 * input&#125;func getX2AndX3_2(input int) (x2 int, x3 int) &#123; x2 = 2 * input x3 = 3 * input // return x2, x3 return&#125; 输出结果： 12num = 10, 2x num = 20, 3x num = 30 num = 10, 2x num = 20, 3x num = 30 警告： return 或 return var 都是可以的。 不过 return var = expression（表达式） 会引发一个编译错误：syntax error: unexpected =, expecting semicolon or newline or &#125;。 即使函数使用了命名返回值，你依旧可以无视它而返回明确的值。 任何一个非命名返回值（使用非命名返回值是很糟的编程习惯）在 return 语句里面都要明确指出包含返回值的变量或是一个可计算的值（就像上面警告所指出的那样）。 尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。 改变外部变量（outside variable） 传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 return 返回。如下的例子，reply 是一个指向 int 变量的指针，通过这个指针，我们在函数内修改了这个 int 变量的数值。 1234567891011121314151617package mainimport ( &quot;fmt&quot;)// this function changes reply:func Multiply(a, b int, reply *int) &#123; *reply = a * b&#125;func main() &#123; n := 0 reply := &amp;n Multiply(10, 5, reply) fmt.Println(&quot;Multiply:&quot;, *reply) // Multiply: 50&#125; 这仅仅是个指导性的例子，当需要在函数内改变一个占用内存比较大的变量时，性能优势就更加明显了。然而，如果不小心使用的话，传递一个指针很容易引发一些不确定的事，所以，我们要十分小心那些可以改变外部变量的函数，在必要时，需要添加注释以便其他人能够更加清楚的知道函数里面到底发生了什么。 defer 和追踪 关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。 关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源。 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; function1()&#125;func function1() &#123; fmt.Printf(&quot;In function1 at the top\\n&quot;) defer function2() fmt.Printf(&quot;In function1 at the bottom!\\n&quot;)&#125;func function2() &#123; fmt.Printf(&quot;Function2: Deferred until the end of the calling function!&quot;)&#125; 输出： 123In Function1 at the topIn Function1 at the bottom!Function2: Deferred until the end of the calling function! 请将 defer 关键字去掉并对比输出结果。 使用 defer 的语句同样可以接受参数，下面这个例子就会在执行 defer 语句时打印 0： 123456func a() &#123; i := 0 defer fmt.Println(i) i++ return&#125; 当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）： 12345func f() &#123; for i := 0; i &lt; 5; i++ &#123; defer fmt.Printf(&quot;%d &quot;, i) &#125;&#125; 上面的代码将会输出：4 3 2 1 0。 关键字 defer 允许我们进行一些函数执行完成后的收尾工作，例如： 关闭文件流 12// open a file defer file.Close() 解锁一个加锁的资源 12mu.Lock() defer mu.Unlock() 打印最终报告 12printHeader() defer printFooter() 关闭数据库链接 12// open a database connection defer disconnectFromDB() 合理使用 defer 语句能够使得代码更加简洁。 以下代码模拟了上面描述的第 4 种情况： 123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;func main() &#123; doDBOperations()&#125;func connectToDB() &#123; fmt.Println(&quot;ok, connected to db&quot;)&#125;func disconnectFromDB() &#123; fmt.Println(&quot;ok, disconnected from db&quot;)&#125;func doDBOperations() &#123; connectToDB() fmt.Println(&quot;Defering the database disconnect.&quot;) defer disconnectFromDB() //function called here with defer fmt.Println(&quot;Doing some DB operations ...&quot;) fmt.Println(&quot;Oops! some crash or network error ...&quot;) fmt.Println(&quot;Returning from function here!&quot;) return //terminate the program // deferred function executed here just before actually returning, even if // there is a return or abnormal termination before&#125; 输出： 123456ok, connected to dbDefering the database disconnect.Doing some DB operations ...Oops! some crash or network error ...Returning from function here!ok, disconnected from db 使用 defer 语句实现代码追踪 一个基础但十分实用的实现代码执行追踪的方案就是在进入和离开某个函数打印相关的消息，即可以提炼为下面两个函数： 12func trace(s string) &#123; fmt.Println(&quot;entering:&quot;, s) &#125;func untrace(s string) &#123; fmt.Println(&quot;leaving:&quot;, s) &#125; 以下代码展示了何时调用这两个函数： 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func trace(s string) &#123; fmt.Println(&quot;entering:&quot;, s) &#125;func untrace(s string) &#123; fmt.Println(&quot;leaving:&quot;, s) &#125;func a() &#123; trace(&quot;a&quot;) defer untrace(&quot;a&quot;) fmt.Println(&quot;in a&quot;)&#125;func b() &#123; trace(&quot;b&quot;) defer untrace(&quot;b&quot;) fmt.Println(&quot;in b&quot;) a()&#125;func main() &#123; b()&#125; 输出： 123456entering: bin bentering: ain aleaving: aleaving: b 上面的代码还可以修改为更加简便的版本 123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;func trace(s string) string &#123; fmt.Println(&quot;entering:&quot;, s) return s&#125;func un(s string) &#123; fmt.Println(&quot;leaving:&quot;, s)&#125;func a() &#123; defer un(trace(&quot;a&quot;)) fmt.Println(&quot;in a&quot;)&#125;func b() &#123; defer un(trace(&quot;b&quot;)) fmt.Println(&quot;in b&quot;) a()&#125;func main() &#123; b()&#125; 使用 defer 语句来记录函数的参数与返回值 下面的代码展示了另一种在调试时使用 defer 语句的手法： 1234567891011121314151617package mainimport ( &quot;io&quot; &quot;log&quot;)func func1(s string) (n int, err error) &#123; defer func() &#123; log.Printf(&quot;func1(%q) = %d, %v&quot;, s, n, err) &#125;() return 7, io.EOF&#125;func main() &#123; func1(&quot;Go&quot;)&#125; 输出： 1Output: 2011/10/04 10:46:11 func1(&quot;Go&quot;) = 7, EOF 将函数作为参数 函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，一般称之为回调。下面是一个将函数作为参数的简单例子（function_parameter.go）： 1234567891011121314151617package mainimport ( &quot;fmt&quot;)func main() &#123; callback(1, Add)&#125;func Add(a, b int) &#123; fmt.Printf(&quot;The sum of %d and %d is: %d\\n&quot;, a, b, a+b)&#125;func callback(y int, f func(int, int)) &#123; f(y, 2) // this becomes Add(1, 2)&#125; 输出： 1The sum of 1 and 2 is: 3 将函数作为返回值 在程序 function_return.go 中我们将会看到函数 Add2 和 Adder 均会返回签名为 func(b int) int 的函数： 12func Add2() (func(b int) int)func Adder(a int) (func(b int) int) 函数 Add2 不接受任何参数，但函数 Adder 接受一个 int 类型的整数作为参数。 我们也可以将 Adder 返回的函数存到变量中（function_return.go）。 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; // make an Add2 function, give it a name p2, and call it: p2 := Add2() fmt.Printf(&quot;Call Add2 for 3 gives: %v\\n&quot;, p2(3)) // make a special Adder function, a gets value 2: TwoAdder := Adder(2) fmt.Printf(&quot;The result is: %v\\n&quot;, TwoAdder(3))&#125;func Add2() func(b int) int &#123; return func(b int) int &#123; return b + 2 &#125;&#125;func Adder(a int) func(b int) int &#123; return func(b int) int &#123; return a + b &#125;&#125; 输出： 12Call Add2 for 3 gives: 5The result is: 5 下例为一个略微不同的实现（function_closure.go）： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; var f = Adder() fmt.Print(f(1), &quot; - &quot;) fmt.Print(f(20), &quot; - &quot;) fmt.Print(f(300))&#125;func Adder() func(int) int &#123; var x int return func(delta int) int &#123; x += delta return x &#125;&#125; 函数 Adder() 现在被赋值到变量 f 中（类型为 func(int) int）。 输出： 11 - 21 - 321 三次调用函数 f 的过程中函数 Adder() 中变量 delta 的值分别为：1、20 和 300。 我们可以看到，在多次调用中，变量 x 的值是被保留的，即 0 + 1 = 1，然后 1 + 20 = 21，最后 21 + 300 = 321：闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 这些局部变量同样可以是参数，例如之前例子中的 Adder(as int)。 这些例子清楚地展示了如何在 Go 语言中使用闭包。 在闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的： 123456var g intgo func(i int) &#123; s := 0 for j := 0; j &lt; i; j++ &#123; s += j &#125; g = s&#125;(1000) // Passes argument 1000 to the function literal. 这样闭包函数就能够被应用到整个集合的元素上，并修改它们的值。然后这些变量就可以用于表示或计算全局或平均值。 通过内存缓存来提升性能 当在进行大量的计算时，提升性能最直接有效的一种方式就是避免重复计算。通过在内存中缓存和重复利用相同计算的结果，称之为内存缓存。最明显的例子就是生成斐波那契数列的程序（详见第 6.6 和 6.11 节）： 要计算数列中第 n 个数字，需要先得到之前两个数的值，但很明显绝大多数情况下前两个数的值都是已经计算过的。即每个更后面的数都是基于之前计算结果的重复计算。 而我们要做就是将第 n 个数的值存在数组中索引为 n 的位置（详见第 7 章），然后在数组中查找是否已经计算过，如果没有找到，则再进行计算。 程序 Listing 6.17 - fibonacci_memoization.go 就是依照这个原则实现的，下面是计算到第 40 位数字的性能对比： 普通写法：4.730270 秒 内存缓存：0.001000 秒 内存缓存的优势显而易见，而且您还可以将它应用到其它类型的计算中，例如使用 map（详见第 7 章）而不是数组或切片： 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;time&quot;)const LIM = 41var fibs [LIM]uint64func main() &#123; var result uint64 = 0 start := time.Now() for i := 0; i &lt; LIM; i++ &#123; result = fibonacci(i) fmt.Printf(&quot;fibonacci(%d) is: %d\\n&quot;, i, result) &#125; end := time.Now() delta := end.Sub(start) fmt.Printf(&quot;longCalculation took this amount of time: %s\\n&quot;, delta)&#125;func fibonacci(n int) (res uint64) &#123; // memoization: check if fibonacci(n) is already known in array: if fibs[n] != 0 &#123; res = fibs[n] return &#125; if n &lt;= 1 &#123; res = 1 &#125; else &#123; res = fibonacci(n-1) + fibonacci(n-2) &#125; fibs[n] = res return&#125; 内存缓存的技术在使用计算成本相对昂贵的函数时非常有用（不仅限于例子中的递归），譬如大量进行相同参数的运算。这种技术还可以应用于纯函数中，即相同输入必定获得相同输出的函数。 声明、初始化和 make 概念 map 是引用类型，可以使用如下声明： 12var map1 map[keytype]valuetypevar map1 map[string]int （[keytype] 和 valuetype 之间允许有空格，但是 gofmt 移除了空格） 在声明的时候不需要知道 map 的长度，map 是可以动态增长的。 未初始化的 map 的值是 nil。 key 可以是任意可以用 == 或者 != 操作符比较的类型，比如 string、int、float。所以数组、切片和结构体不能作为 key (译者注：含有数组切片的结构体不能作为 key，只包含内建类型的 struct 是可以作为 key 的），但是指针和接口类型可以。如果要用结构体作为 key 可以提供 Key() 和 Hash() 方法，这样可以通过结构体的域计算出唯一的数字或者字符串的 key。 value 可以是任意类型的；通过使用空接口类型（详见第 11.9 节），我们可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言（详见第 11.3 节）。 map 传递给函数的代价很小：在 32 位机器上占 4 个字节，64 位机器上占 8 个字节，无论实际上存储了多少数据。通过 key 在 map 中寻找值是很快的，比线性查找快得多，但是仍然比从数组和切片的索引中直接读取要慢 100 倍；所以如果你很在乎性能的话还是建议用切片来解决问题。 map 也可以用函数作为自己的值，这样就可以用来做分支结构（详见第 5 章）：key 用来选择要执行的函数。 如果 key1 是 map1 的key，那么 map1[key1] 就是对应 key1 的值，就如同数组索引符号一样（数组可以视为一种简单形式的 map，key 是从 0 开始的整数）。 key1 对应的值可以通过赋值符号来设置为 val1：map1[key1] = val1。 令 v := map1[key1] 可以将 key1 对应的值赋值给 v；如果 map 中没有 key1 存在，那么 v 将被赋值为 map1 的值类型的空值。 常用的 len(map1) 方法可以获得 map 中的 pair 数目，这个数目是可以伸缩的，因为 map-pairs 在运行时可以动态添加和删除。 示例 8.1 make_maps.go 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; var mapLit map[string]int //var mapCreated map[string]float32 var mapAssigned map[string]int mapLit = map[string]int&#123;&quot;one&quot;: 1, &quot;two&quot;: 2&#125; mapCreated := make(map[string]float32) mapAssigned = mapLit mapCreated[&quot;key1&quot;] = 4.5 mapCreated[&quot;key2&quot;] = 3.14159 mapAssigned[&quot;two&quot;] = 3 fmt.Printf(&quot;Map literal at \\&quot;one\\&quot; is: %d\\n&quot;, mapLit[&quot;one&quot;]) fmt.Printf(&quot;Map created at \\&quot;key2\\&quot; is: %f\\n&quot;, mapCreated[&quot;key2&quot;]) fmt.Printf(&quot;Map assigned at \\&quot;two\\&quot; is: %d\\n&quot;, mapLit[&quot;two&quot;]) fmt.Printf(&quot;Map literal at \\&quot;ten\\&quot; is: %d\\n&quot;, mapLit[&quot;ten&quot;])&#125; 输出结果： 1234Map literal at &quot;one&quot; is: 1Map created at &quot;key2&quot; is: 3.141590Map assigned at &quot;two&quot; is: 3Mpa literal at &quot;ten&quot; is: 0 mapLit 说明了 map literals 的使用方法： map 可以用 &#123;key1: val1, key2: val2&#125; 的描述方法来初始化，就像数组和结构体一样。 map 是 引用类型 的： 内存用 make 方法来分配。 map 的初始化：var map1 = make(map[keytype]valuetype)。 或者简写为：map1 := make(map[keytype]valuetype)。 上面例子中的 mapCreated 就是用这种方式创建的：mapCreated := make(map[string]float32)。 相当于：mapCreated := map[string]float32&#123;&#125;。 mapAssigned 也是 mapList 的引用，对 mapAssigned 的修改也会影响到 mapLit 的值。 不要使用 new，永远用 make 来构造 map 注意 如果你错误的使用 new() 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址： 1mapCreated := new(map[string]float32) 接下来当我们调用：mapCreated[&quot;key1&quot;] = 4.5 的时候，编译器会报错： 1invalid operation: mapCreated[&quot;key1&quot;] (index of type *map[string]float32). 为了说明值可以是任意类型的，这里给出了一个使用 func() int 作为值的 map： 1234567891011package mainimport &quot;fmt&quot;func main() &#123; mf := map[int]func() int&#123; 1: func() int &#123; return 10 &#125;, 2: func() int &#123; return 20 &#125;, 5: func() int &#123; return 50 &#125;, &#125; fmt.Println(mf)&#125; 输出结果为：map[1:0x10903be0 5:0x10903ba0 2:0x10903bc0]: 整形都被映射到函数地址。 map 容量 和数组不同，map 可以根据新增的 key-value 对动态的伸缩，因此它不存在固定长度或者最大限制。但是你也可以选择标明 map 的初始容量 capacity，就像这样：make(map[keytype]valuetype, cap)。例如： 1map2 := make(map[string]float32, 100) 当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。 这里有一个 map 的具体例子，即将音阶和对应的音频映射起来： 123noteFrequency := map[string]float32 &#123; &quot;C0&quot;: 16.35, &quot;D0&quot;: 18.35, &quot;E0&quot;: 20.60, &quot;F0&quot;: 21.83, &quot;G0&quot;: 24.50, &quot;A0&quot;: 27.50, &quot;B0&quot;: 30.87, &quot;A4&quot;: 440&#125; 用切片作为 map 的值 既然一个 key 只能对应一个 value，而 value 又是一个原始类型，那么如果一个 key 要对应多个值怎么办？例如，当我们要处理unix机器上的所有进程，以父进程（pid 为整形）作为 key，所有的子进程（以所有子进程的 pid 组成的切片）作为 value。通过将 value 定义为 []int 类型或者其他类型的切片，就可以优雅的解决这个问题。 这里有一些定义这种 map 的例子： 12mp1 := make(map[int][]int)mp2 := make(map[int]*[]int) 切片 7.2.1 概念 切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。 切片是可索引的，并且可以由 len() 函数获取长度。 给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个 长度可变的数组。 切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少：它等于切片的长度 + 数组除切片之外的长度。如果 s 是一个切片，cap(s) 就是从 s[0] 到数组末尾的数组长度。切片的长度永远不会超过它的容量，所以对于 切片 s 来说该不等式永远成立：0 &lt;= len(s) &lt;= cap(s)。 多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。 优点 因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用。 声明切片的格式是： var identifier []type（不需要说明长度）。 一个切片在未初始化之前默认为 nil，长度为 0。 切片的初始化格式是：var slice1 []type = arr1[start:end]。 这表示 slice1 是由数组 arr1 从 start 索引到 end-1 索引之间的元素构成的子集（切分数组，start:end 被称为 slice 表达式）。所以 slice1[0] 就等于 arr1[start]。这可以在 arr1 被填充前就定义好。 如果某个人写：var slice1 []type = arr1[:] 那么 slice1 就等于完整的 arr1 数组（所以这种表示方式是 arr1[0:len(arr1)] 的一种缩写）。另外一种表述方式是：slice1 = &amp;arr1。 arr1[2:] 和 arr1[2:len(arr1)] 相同，都包含了数组从第三个到最后的所有元素。 arr1[:3] 和 arr1[0:3] 相同，包含了从第一个到第三个元素（不包括第四个）。 如果你想去掉 slice1 的最后一个元素，只要 slice1 = slice1[:len(slice1)-1]。 一个由数字 1、2、3 组成的切片可以这么生成：s := [3]int&#123;1,2,3&#125;[:](注: 应先用s := [3]int&#123;1, 2, 3&#125;生成数组, 再使用s[:]转成切片) 甚至更简单的 s := []int&#123;1,2,3&#125;。 s2 := s[:] 是用切片组成的切片，拥有相同的元素，但是仍然指向相同的相关数组。 一个切片 s 可以这样扩展到它的大小上限：s = s[:cap(s)]，如果再扩大的话就会导致运行时错误（参见第 7.7 节）。 对于每一个切片（包括 string），以下状态总是成立的： 12s == s[:i] + s[i:] // i是一个整数且: 0 &lt;= i &lt;= len(s)len(s) &lt;= cap(s) 切片也可以用类似数组的方式初始化：var x = []int&#123;2, 3, 5, 7, 11&#125;。这样就创建了一个长度为 5 的数组并且创建了一个相关切片。 切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片长度以及切片容量。下图给出了一个长度为 2，容量为 4 的切片y。 y[0] = 3 且 y[1] = 5。 切片 y[0:4] 由 元素 3，5，7 和 11 组成。 示例 7.7 array_slices.go 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() &#123; var arr1 [6]int var slice1 []int = arr1[2:5] // item at index 5 not included! // load the array with integers: 0,1,2,3,4,5 for i := 0; i &lt; len(arr1); i++ &#123; arr1[i] = i &#125; // print the slice for i := 0; i &lt; len(slice1); i++ &#123; fmt.Printf(&quot;Slice at %d is %d\\n&quot;, i, slice1[i]) &#125; fmt.Printf(&quot;The length of arr1 is %d\\n&quot;, len(arr1)) fmt.Printf(&quot;The length of slice1 is %d\\n&quot;, len(slice1)) fmt.Printf(&quot;The capacity of slice1 is %d\\n&quot;, cap(slice1)) // grow the slice slice1 = slice1[0:4] for i := 0; i &lt; len(slice1); i++ &#123; fmt.Printf(&quot;Slice at %d is %d\\n&quot;, i, slice1[i]) &#125; fmt.Printf(&quot;The length of slice1 is %d\\n&quot;, len(slice1)) fmt.Printf(&quot;The capacity of slice1 is %d\\n&quot;, cap(slice1)) // grow the slice beyond capacity //slice1 = slice1[0:7 ] // panic: runtime error: slice bound out of range&#125; 输出： 123456789101112Slice at 0 is 2 Slice at 1 is 3 Slice at 2 is 4 The length of arr1 is 6 The length of slice1 is 3 The capacity of slice1 is 4 Slice at 0 is 2 Slice at 1 is 3 Slice at 2 is 4 Slice at 3 is 5 The length of slice1 is 4 The capacity of slice1 is 4 如果 s2 是一个 slice，你可以将 s2 向后移动一位 s2 = s2[1:]，但是末尾没有移动。切片只能向后移动，s2 = s2[-1:] 会导致编译错误。切片不能被重新分片以获取数组的前一个元素。 注意 绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针!! 问题 7.2： 给定切片 b:= []byte&#123;'g', 'o', 'l', 'a', 'n', 'g'&#125;，那么 b[1:4]、b[:2]、b[2:] 和 b[:] 分别是什么？ 7.2.2 将切片传递给函数 如果你有一个函数需要对数组做操作，你可能总是需要把参数声明为切片。当你调用该函数时，把数组分片，创建为一个 切片引用并传递给该函数。这里有一个计算数组元素和的方法: 123456789101112func sum(a []int) int &#123; s := 0 for i := 0; i &lt; len(a); i++ &#123; s += a[i] &#125; return s&#125;func main() &#123; var arr = [5]int&#123;0, 1, 2, 3, 4&#125; sum(arr[:])&#125; 7.2.3 用 make() 创建一个切片 当相关数组还没有定义时，我们可以使用 make() 函数来创建一个切片 同时创建好相关数组：var slice1 []type = make([]type, len)。 也可以简写为 slice1 := make([]type, len)，这里 len 是数组的长度并且也是 slice 的初始长度。 所以定义 s2 := make([]int, 10)，那么 cap(s2) == len(s2) == 10。 make 接受 2 个参数：元素的类型以及切片的元素个数。 如果你想创建一个 slice1，它不占用整个数组，而只是占用以 len 为个数个项，那么只要：slice1 := make([]type, len, cap)。 make 的使用方式是：func make([]T, len, cap)，其中 cap 是可选参数。 所以下面两种方法可以生成相同的切片: 12make([]int, 50, 100)new([100]int)[0:50] 下图描述了使用 make 方法生成的切片的内存结构：[ 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; var slice1 []int = make([]int, 10) // load the array/slice: for i := 0; i &lt; len(slice1); i++ &#123; slice1[i] = 5 * i &#125; // print the slice: for i := 0; i &lt; len(slice1); i++ &#123; fmt.Printf(&quot;Slice at %d is %d\\n&quot;, i, slice1[i]) &#125; fmt.Printf(&quot;\\nThe length of slice1 is %d\\n&quot;, len(slice1)) fmt.Printf(&quot;The capacity of slice1 is %d\\n&quot;, cap(slice1))&#125; 输出： 12345678910111213Slice at 0 is 0 Slice at 1 is 5 Slice at 2 is 10 Slice at 3 is 15 Slice at 4 is 20 Slice at 5 is 25 Slice at 6 is 30 Slice at 7 is 35 Slice at 8 is 40 Slice at 9 is 45 The length of slice1 is 10 The capacity of slice1 is 10 因为字符串是纯粹不可变的字节数组，它们也可以被切分成 切片。 练习 7.4： fobinacci_funcarray.go: 为练习 7.3 写一个新的版本，主函数调用一个使用序列个数作为参数的函数，该函数返回一个大小为序列个数的 Fibonacci 切片。 7.2.4 new() 和 make() 的区别 看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。 new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体（参见第 10 章）；它相当于 &amp;T&#123;&#125;。 make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：切片、map 和 channel（参见第 8 章，第 13 章）。 换言之，new 函数分配内存，make 函数初始化；下图给出了区别： 在图 7.3 的第一幅图中： 12var p *[]int = new([]int) // *p == nil; with len and cap 0p := new([]int) 在第二幅图中， p := make([]int, 0) ，切片 已经被初始化，但是指向一个空的数组。 以上两种方式实用性都不高。下面的方法： 1var v []int = make([]int, 10, 50) 或者 1v := make([]int, 10, 50) 这样分配一个有 50 个 int 值的数组，并且创建了一个长度为 10，容量为 50 的 切片 v，该 切片 指向数组的前 10 个元素。 问题 7.3 给定 s := make([]byte, 5)，len(s) 和 cap(s) 分别是多少？s = s[2:4]，len(s) 和 cap(s) 又分别是多少？ 问题 7.4 假设 s1 := []byte&#123;'p', 'o', 'e', 'm'&#125; 且 s2 := s1[2:]，s2 的值是多少？如果我们执行 s2[1] = 't'，s1 和 s2 现在的值又分别是多少？ 译者注：如何理解new、make、slice、map、channel的关系 1.slice、map以及channel都是golang内建的一种引用类型，三者在内存中存在多个组成部分， 需要对内存组成部分初始化后才能使用，而make就是对三者进行初始化的一种操作方式 2. new 获取的是存储指定变量内存地址的一个变量，对于变量内部结构并不会执行相应的初始化操作， 所以slice、map、channel需要make进行初始化并获取对应的内存地址，而非new简单的获取内存地址 7.2.5 多维 切片 和数组一样，切片通常也是一维的，但是也可以由一维组合成高维。通过分片的分片（或者切片的数组），长度可以任意动态变化，所以 Go 语言的多维切片可以任意切分。而且，内层的切片必须单独分配（通过 make 函数）。 7.2.6 bytes 包 类型 []byte 的切片十分常见，Go 语言有一个 bytes 包专门用来解决这种类型的操作方法。 bytes 包和字符串包十分类似（参见第 4.7 节）。而且它还包含一个十分有用的类型 Buffer: 12345import &quot;bytes&quot;type Buffer struct &#123; ...&#125; 这是一个长度可变的 bytes 的 buffer，提供 Read 和 Write 方法，因为读写长度未知的 bytes 最好使用 buffer。 Buffer 可以这样定义：var buffer bytes.Buffer。 或者使用 new 获得一个指针：var r *bytes.Buffer = new(bytes.Buffer)。 或者通过函数：func NewBuffer(buf []byte) *Buffer，创建一个 Buffer 对象并且用 buf 初始化好；NewBuffer 最好用在从 buf 读取的时候使用。 通过 buffer 串联字符串 类似于 Java 的 StringBuilder 类。 在下面的代码段中，我们创建一个 buffer，通过 buffer.WriteString(s) 方法将字符串 s 追加到后面，最后再通过 buffer.String() 方法转换为 string： 123456789var buffer bytes.Bufferfor &#123; if s, ok := getNextString(); ok &#123; //method getNextString() not shown here buffer.WriteString(s) &#125; else &#123; break &#125;&#125;fmt.Print(buffer.String(), &quot;\\n&quot;) 这种实现方式比使用 += 要更节省内存和 CPU，尤其是要串联的字符串数目特别多的时候。 修改字符串中的某个字符 Go 语言中的字符串是不可变的，也就是说 str[index] 这样的表达式是不可以被放在等号左侧的。如果尝试运行 str[i] = 'D' 会得到错误：cannot assign to str[i]。 因此，您必须先将字符串转换成字节数组，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式。 例如，将字符串 “hello” 转换为 “cello”： 1234s := &quot;hello&quot;c := []byte(s)c[0] = &#x27;c&#x27;s2 := string(c) // s2 == &quot;cello&quot; 所以，您可以通过操作切片来完成对字符串的操作。 7.6.5 字节数组对比函数 下面的 Compare 函数会返回两个字节数组字典顺序的整数对比结果，即 0 if a == b, -1 if a &lt; b, 1 if a &gt; b。 123456789101112131415161718func Compare(a, b[]byte) int &#123; for i:=0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ &#123; switch &#123; case a[i] &gt; b[i]: return 1 case a[i] &lt; b[i]: return -1 &#125; &#125; // 数组的长度可能不同 switch &#123; case len(a) &lt; len(b): return -1 case len(a) &gt; len(b): return 1 &#125; return 0 // 数组相等&#125; 搜索及排序切片和数组 标准库提供了 sort 包来实现常见的搜索和排序操作。您可以使用 sort 包中的函数 func Ints(a []int) 来实现对 int 类型的切片排序。例如 sort.Ints(arri)，其中变量 arri 就是需要被升序排序的数组或切片。为了检查某个数组是否已经被排序，可以通过函数 IntsAreSorted(a []int) bool 来检查，如果返回 true 则表示已经被排序。 类似的，可以使用函数 func Float64s(a []float64) 来排序 float64 的元素，或使用函数 func Strings(a []string) 排序字符串元素。 想要在数组或切片中搜索一个元素，该数组或切片必须先被排序（因为标准库的搜索算法使用的是二分法）。然后，您就可以使用函数 func SearchInts(a []int, n int) int 进行搜索，并返回对应结果的索引值。 当然，还可以搜索 float64 和字符串： 12func SearchFloat64s(a []float64, x float64) intfunc SearchStrings(a []string, x string) int 您可以通过查看 官方文档 来获取更详细的信息。 这就是如何使用 sort 包的方法，我们会在第 11.6 节对它的细节进行深入，并实现一个属于我们自己的版本。 append 函数常见操作 我们在第 7.5 节提到的 append 非常有用，它能够用于各种方面的操作： 将切片 b 的元素追加到切片 a 之后：a = append(a, b...) 复制切片 a 的元素到新的切片 b 上： 12b = make([]T, len(a))copy(b, a) 删除位于索引 i 的元素：a = append(a[:i], a[i+1:]...) 切除切片 a 中从索引 i 至 j 位置的元素：a = append(a[:i], a[j:]...) 为切片 a 扩展 j 个元素长度：a = append(a, make([]T, j)...) 在索引 i 的位置插入元素 x：a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...) 在索引 i 的位置插入长度为 j 的新切片：a = append(a[:i], append(make([]T, j), a[i:]...)...) 在索引 i 的位置插入切片 b 的所有元素：a = append(a[:i], append(b, a[i:]...)...) 取出位于切片 a 最末尾的元素 x：x, a = a[len(a)-1], a[:len(a)-1] 将元素 x 追加到切片 a：a = append(a, x) 因此，您可以使用切片和 append 操作来表示任意可变长度的序列。 从数学的角度来看，切片相当于向量，如果需要的话可以定义一个向量作为切片的别名来进行操作。","categories":[{"name":"print*,\"hello world!!!\"","slug":"print-hello-world","permalink":"https://blog.youmingsama.cn/categories/print-hello-world/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://blog.youmingsama.cn/tags/golang/"}]},{"title":"从零开始的go语言生活","slug":"hello world/golang基础知识梳理","date":"2020-04-29T00:00:00.000Z","updated":"2020-05-04T00:00:00.000Z","comments":true,"path":"posts/ce3ef34b/","link":"","permalink":"https://blog.youmingsama.cn/posts/ce3ef34b/","excerpt":"","text":"变量的初始化 变量声明可以包含初始值，每个变量对应一个。 如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。 1234567891011package mainimport &quot;fmt&quot;var i, j = 1, 2func main() &#123; var c, python, java = true, false, &quot;no!&quot; fmt.Println(i, j, c, python, java)&#125; 短变量声明 在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。 函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。 123456789101112package mainimport &quot;fmt&quot;func main() &#123; var i, j int = 1, 2 k := 3 c, python, java := true, false, &quot;no!&quot; fmt.Println(i, j, k, c, python, java)&#125; 基本类型 Go 的基本类型有 123456789101112131415boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名 // 表示一个 Unicode 码点float32 float64complex64 complex128 本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。 int, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;math/cmplx&quot;)var ( ToBe bool = false MaxInt uint64 = 1&lt;&lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i))func main() &#123; fmt.Printf(&quot;Type: %T Value: %v\\n&quot;, ToBe, ToBe) fmt.Printf(&quot;Type: %T Value: %v\\n&quot;, MaxInt, MaxInt) fmt.Printf(&quot;Type: %T Value: %v\\n&quot;, z, z)&#125; 类型转换 表达式 T(v) 将值 v 转换为类型 T。 一些关于数值的转换： 123var i int = 42var f float64 = float64(i)var u uint = uint(f) 或者，更加简单的形式： 123i := 42f := float64(i)u := uint(f) 与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。移除下面源代码中 float64 或 uint 就将报错 1234567891011121314package mainimport ( &quot;fmt&quot; &quot;math&quot;)func main() &#123; var x, y int = 3, 4 var f float64 = math.Sqrt(float64(x*x + y*y)) var z uint = uint(f) fmt.Println(x, y, z)&#125; defer defer 语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。 12345678910package mainimport &quot;fmt&quot;func main() &#123; defer fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;)&#125; defer 栈 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。 更多关于 defer 语句的信息，请阅读此博文。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;counting&quot;) for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println(&quot;done&quot;)&#125; 指针 Go 拥有指针。指针保存了值的内存地址。 类型 *T 是指向 T 类型值的指针。其零值为 nil。 1var p *int &amp; 操作符会生成一个指向其操作数的指针。 12i := 42p = &amp;i * 操作符表示指针指向的底层值。 12fmt.Println(*p) // 通过指针 p 读取 i*p = 21 // 通过指针 p 设置 i 这也就是通常所说的“间接引用”或“重定向”。 与 C 不同，Go 没有指针运算。 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; i, j := 42, 2701 p := &amp;i // 指向 i fmt.Println(*p) // 通过指针读取 i 的值 *p = 21 // 通过指针设置 i 的值 fmt.Println(i) // 查看 i 的值 p = &amp;j // 指向 j *p = *p / 37 // 通过指针对 j 进行除法运算 fmt.Println(j) // 查看 j 的值&#125; 结构体指针 结构体字段可以通过结构体指针来访问。 如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。 12345678910111213141516package mainimport &quot;fmt&quot;type Vertex struct &#123; X int Y int&#125;func main() &#123; v := Vertex&#123;1, 2&#125; p := &amp;v p.X = 1e9 fmt.Println(v.X)&#125; 结构体文法 结构体文法通过直接列出字段的值来新分配一个结构体。 使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。） 特殊的前缀 &amp; 返回一个指向结构体的指针。 12345678910111213141516171819package mainimport &quot;fmt&quot;type Vertex struct &#123; X, Y int&#125;var ( v1 = Vertex&#123;1, 2&#125; // 创建一个 Vertex 类型的结构体 v2 = Vertex&#123;X: 1&#125; // Y:0 被隐式地赋予 v3 = Vertex&#123;&#125; // X:0 Y:0 p = &amp;Vertex&#123;1, 2&#125; // 创建一个 *Vertex 类型的结构体（指针）)func main() &#123; fmt.Println(v1, p, v2, v3)&#125; 结果 1&#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125; 数组 类型 [n]T 表示拥有 n 个 T 类型的值的数组。 表达式 1var a [10]int 会将变量 a 声明为拥有 10 个整数的数组。 数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; var a [2]string a[0] = &quot;Hello&quot; a[1] = &quot;World&quot; fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; fmt.Println(primes)&#125; 结果 123Hello World[Hello World][2 3 5 7 11 13] 切片 每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。 类型 []T 表示一个元素类型为 T 的切片。 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔： 1a[low : high] 它会选择一个半开区间，包括第一个元素，但排除最后一个元素。 以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素： 1a[1:4] 1234567891011package mainimport &quot;fmt&quot;func main() &#123; primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; var s []int = primes[1:4] fmt.Println(s)&#125; 切片就像数组的引用 切片并不存储任何数据，它只是描述了底层数组中的一段。 更改切片的元素会修改其底层数组中对应的元素。 与它共享底层数组的切片都会观测到这些修改。 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; names := [4]string&#123; &quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &#125; fmt.Println(names) a := names[0:2] b := names[1:3] fmt.Println(a, b) b[0] = &quot;XXX&quot; fmt.Println(a, b) fmt.Println(names)&#125; 结果 1234[John Paul George Ringo][John Paul] [Paul George][John XXX] [XXX George][John XXX George Ringo] 切片的默认行为 在进行切片时，你可以利用它的默认行为来忽略上下界。 切片下界的默认值为 0，上界则是该切片的长度。 对于数组 1var a [10]int 来说，以下切片是等价的： 1234a[0:10]a[:10]a[0:]a[:] 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; s := []int&#123;2, 3, 5, 7, 11, 13&#125; s = s[1:4] fmt.Println(s) s = s[:2] fmt.Println(s) s = s[1:] fmt.Println(s)&#125; 结果 123[3 5 7][3 5][5] 切片的长度与容量 切片拥有 长度 和 容量。 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。 你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &#123; s := []int&#123;2, 3, 5, 7, 11, 13&#125; printSlice(s) // 截取切片使其长度为 0 s = s[:0] printSlice(s) // 拓展其长度 s = s[:4] printSlice(s) // 舍弃前两个值 s = s[2:] printSlice(s)&#125;func printSlice(s []int) &#123; fmt.Printf(&quot;len=%d cap=%d %v\\n&quot;, len(s), cap(s), s)&#125; 1234len=6 cap=6 [2 3 5 7 11 13]len=0 cap=6 []len=4 cap=6 [2 3 5 7]len=2 cap=4 [5 7] nil 切片 切片的零值是 nil。 nil 切片的长度和容量为 0 且没 123456789101112package mainimport &quot;fmt&quot;func main() &#123; var s []int fmt.Println(s, len(s), cap(s)) if s == nil &#123; fmt.Println(&quot;nil!&quot;) &#125;&#125; 12[] 0 0nil! 用 make 创建切片 切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。 make 函数会分配一个元素为零值的数组并返回一个引用了它的切片： 1a := make([]int, 5) // len(a)=5 要指定它的容量，需向 make 传入第三个参数： 1234b := make([]int, 0, 5) // len(b)=0, cap(b)=5b = b[:cap(b)] // len(b)=5, cap(b)=5b = b[1:] // len(b)=4, cap(b)= 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; a := make([]int, 5) printSlice(&quot;a&quot;, a) b := make([]int, 0, 5) printSlice(&quot;b&quot;, b) c := b[:2] printSlice(&quot;c&quot;, c) d := c[2:5] printSlice(&quot;d&quot;, d)&#125;func printSlice(s string, x []int) &#123; fmt.Printf(&quot;%s len=%d cap=%d %v\\n&quot;, s, len(x), cap(x), x)&#125; 1234a len=5 cap=5 [0 0 0 0 0]b len=0 cap=5 []c len=2 cap=5 [0 0]d len=3 cap=3 [ 向切片追加元素 为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。内建函数的文档对此函数有详细的介绍。 1func append(s []T, vs ...T) []T append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。 append 的结果是一个包含原切片所有元素加上新添加元素的切片。 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &#123; var s []int printSlice(s) // 添加一个空切片 s = append(s, 0) printSlice(s) // 这个切片会按需增长 s = append(s, 1) printSlice(s) // 可以一次性添加多个元素 s = append(s, 2, 3, 4) printSlice(s)&#125;func printSlice(s []int) &#123; fmt.Printf(&quot;len=%d cap=%d %v\\n&quot;, len(s), cap(s), s)&#125; 1234len=0 cap=0 []len=1 cap=1 [0]len=2 cap=2 [0 1]len=5 cap=6 [0 1 2 3 4] Range for 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。 123456789101112package mainimport &quot;fmt&quot;var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;func main() &#123; for i, v := range pow &#123; fmt.Printf(&quot;2**%d = %d\\n&quot;, i, v) &#125;&#125; 1234567892**0 = 12**1 = 22**2 = 42**3 = 82**4 = 162**5 = 322**6 = 642**7 = 128 映射 映射将键映射到值。 映射的零值为 nil 。nil 映射既没有键，也不能添加键。 make 函数会返回给定类型的映射，并将其初始化备用。 123456789101112131415161718package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m map[string]Vertexfunc main() &#123; m = make(map[string]Vertex) m[&quot;Bell Labs&quot;] = Vertex&#123; 40.68433, -74.39967, &#125; fmt.Println(m[&quot;Bell Labs&quot;])&#125; 1&#123;40.68433 -74.39967&#125; 映射的文法 映射的文法与结构体相似，不过必须有键名。 1234567891011121314151617181920package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123; &quot;Bell Labs&quot;: Vertex&#123; 40.68433, -74.39967, &#125;, &quot;Google&quot;: Vertex&#123; 37.42202, -122.08408, &#125;,&#125;func main() &#123; fmt.Println(m)&#125; 1map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;] 映射的文法（续） 若顶级类型只是一个类型名，你可以在文法的元素中省略它。 1234567891011121314151617package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123; &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;, &quot;Google&quot;: &#123;37.42202, -122.08408&#125;,&#125;func main() &#123; fmt.Println(m)&#125; 修改映射 在映射 m 中插入或修改元素： 1m[key] = elem 获取元素： 1elem = m[key] 删除元素： 1delete(m, key) 通过双赋值检测某个键是否存在： 1elem, ok = m[key] 若 key 在 m 中，ok 为 true ；否则，ok 为 false。 123456789101112131415161718import &quot;fmt&quot;func main() &#123; m := make(map[string]int) m[&quot;Answer&quot;] = 42 fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) m[&quot;Answer&quot;] = 48 fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) delete(m, &quot;Answer&quot;) fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) v, ok := m[&quot;Answer&quot;] fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)&#125; 1234The value: 42The value: 48The value: 0The value: 0 Present? false 函数值 函数也是值。它们可以像其它值一样传递。 函数值可以用作函数的参数或返回值。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math&quot;)func compute(fn func(float64, float64) float64) float64 &#123; return fn(3, 4)&#125;func main() &#123; hypot := func(x, y float64) float64 &#123; return math.Sqrt(x*x + y*y) &#125; fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow))&#125; 12313581 函数的闭包 Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。 例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125; 123456789100 01 -23 -66 -1210 -2015 -3021 -4228 -5636 -7245 -90 方法 Go 没有类。不过你可以为结构体类型定义方法。 方法就是一类带特殊的 接收者 参数的函数。 方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。 在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者。 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (b Vertex) Abs() float64 &#123; return math.Sqrt(b.X*b.X + b.Y*b.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs())&#125; 15 方法即函数 记住：方法只是个带接收者参数的函数。 现在这个 Abs 的写法就是个正常的函数，功能并没有什么变化。 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func Abs(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(Abs(v))&#125; 15 方法（续） 你也可以为非结构体类型声明方法。 在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat。 你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。 （译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;math&quot;)type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;func main() &#123; f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs())&#125; 11.4142135623730951 指针接收者 你可以为指针接收者声明方法。 这意味着对于某类型 T，接收者的类型可以用 *T 的文法。（此外，T 不能是像 *int 这样的指针。） 例如，这里为 *Vertex 定义了 Scale 方法。 指针接收者的方法可以修改接收者指向的值（就像 Scale 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。 试着移除第 16 行 Scale 函数声明中的 *，观察此程序的行为如何变化。 若使用值接收者，那么 Scale 方法会对原始 Vertex 值的副本进行操作。（对于函数的其它参数也是如此。）``Scale方法必须用指针接受者来更改main函数中声明的Vertex` 的值。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(10) fmt.Println(v.Abs())&#125; 150 指针与函数 现在我们要把 Abs 和 Scale 方法重写为函数。 同样，我们先试着移除掉第 16 的 *。你能看出为什么程序的行为改变了吗？要怎样做才能让该示例顺利通过编译？ （若你不确定，继续往下看。） 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func Abs(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func Scale(v *Vertex, f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; Scale(&amp;v, 10) fmt.Println(Abs(v))&#125; 方法与指针重定向 比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针： 123var v VertexScaleFunc(v, 5) // 编译错误！ScaleFunc(&amp;v, 5) // OK 而以指针为接收者的方法被调用时，接收者既能为值又能为指针： 1234var v Vertexv.Scale(5) // OKp := &amp;vp.Scale(10) // OK 对于语句 v.Scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)。 123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func ScaleFunc(v *Vertex, f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(2) ScaleFunc(&amp;v, 10) p := &amp;Vertex&#123;4, 3&#125; p.Scale(3) ScaleFunc(p, 8) fmt.Println(v, p)&#125; 1&#123;60 80&#125; &amp;&#123;96 72&#125; 方法与指针重定向（续） 同样的事情也发生在相反的方向。 接受一个值作为参数的函数必须接受一个指定类型的值： 123var v Vertexfmt.Println(AbsFunc(v)) // OKfmt.Println(AbsFunc(&amp;v)) // 编译错误！ 而以值为接收者的方法被调用时，接收者既能为值又能为指针： 1234var v Vertexfmt.Println(v.Abs()) // OKp := &amp;vfmt.Println(p.Abs()) // OK 这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()。 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func AbsFunc(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs()) fmt.Println(AbsFunc(v)) p := &amp;Vertex&#123;4, 3&#125; fmt.Println(p.Abs()) fmt.Println(AbsFunc(*p))&#125; 123455555 选择值或指针作为接收者 使用指针接收者的原因有二： 首先，方法能够修改其接收者指向的值。 其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。 在本例中，Scale 和 Abs 接收者的类型为 *Vertex，即便 Abs 并不需要修改其接收者。 通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。（我们会在接下来几页中明白为什么。） 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := &amp;Vertex&#123;3, 4&#125; fmt.Printf(&quot;Before scaling: %+v, Abs: %v\\n&quot;, v, v.Abs()) v.Scale(5) fmt.Printf(&quot;After scaling: %+v, Abs: %v\\n&quot;, v, v.Abs())&#125; 12Before scaling: &amp;&#123;X:3 Y:4&#125;, Abs: 5After scaling: &amp;&#123;X:15 Y:20&#125;, Abs: 25 接口 接口类型 是由一组方法签名定义的集合。 接口类型的变量可以保存任何实现了这些方法的值。 注意: 示例代码的 22 行存在一个错误。由于 Abs 方法只为 *Vertex （指针类型）定义，因此 Vertex（值类型）并未实现 Abser。 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Abser interface &#123; Abs() float64&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat 实现了 Abser a = &amp;v // a *Vertex 实现了 Abser // 下面一行，v 是一个 Vertex（而不是 *Vertex） // 所以没有实现 Abser。 a = v fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; 接口与隐式实现 类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。 隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。 因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。 12345678910111213141516171819202122package mainimport &quot;fmt&quot;type I interface &#123; M()&#125;type T struct &#123; S string&#125;// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。func (t T) M() &#123; fmt.Println(t.S)&#125;func main() &#123; var i I = T&#123;&quot;hello&quot;&#125; i.M()&#125; 接口值 接口也是值。它们可以像其它值一样传递。 接口值可以用作函数的参数或返回值。 在内部，接口值可以看做包含值和具体类型的元组： 1(value, type) 接口值保存了一个具体底层类型的具体值。 接口值调用方法时会执行其底层类型的同名方法。 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;math&quot;)type I interface &#123; M()&#125;type T struct &#123; S string&#125;func (t *T) M() &#123; fmt.Println(t.S)&#125;type F float64func (f F) M() &#123; fmt.Println(f)&#125;func main() &#123; var i I i = &amp;T&#123;&quot;Hello&quot;&#125; describe(i) i.M() i = F(math.Pi) describe(i) i.M()&#125;func describe(i I) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i)&#125; 12345(&amp;&#123;Hello&#125;, *main.T)Hello(3.141592653589793, main.F)3.141592653589793 底层值为 nil 的接口值 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。 在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 M 方法）。 注意: 保存了 nil 具体值的接口其自身并不为 nil。 12345678910111213141516171819202122232425262728293031323334353637package mainimport &quot;fmt&quot;type I interface &#123; M()&#125;type T struct &#123; S string&#125;func (t *T) M() &#123; if t == nil &#123; fmt.Println(&quot;&lt;nil&gt;&quot;) return &#125; fmt.Println(t.S)&#125;func main() &#123; var i I var t *T i = t describe(i) i.M() i = &amp;T&#123;&quot;hello&quot;&#125; describe(i) i.M()&#125;func describe(i I) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i)&#125; 12345(&lt;nil&gt;, *main.T)&lt;nil&gt;(&amp;&#123;hello&#125;, *main.T)hello nil 接口值 nil 接口值既不保存值也不保存具体类型。 为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。 123456789101112131415161718package mainimport &quot;fmt&quot;type I interface &#123; M()&#125;func main() &#123; var i I describe(i) i.M()&#125;func describe(i I) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i)&#125; 12345678(&lt;nil&gt;, &lt;nil&gt;)panic: runtime error: invalid memory address or nil pointer dereference[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x492e3f]goroutine 1 [running]:main.main() /tmp/sandbox891365133/prog.go:12 +0x8f 空接口 指定了零个方法的接口值被称为 空接口： 1interface&#123;&#125; 空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。） 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface&#123;&#125; 的任意数量的参数。 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; var i interface&#123;&#125; describe(i) i = 42 describe(i) i = &quot;hello&quot; describe(i)&#125;func describe(i interface&#123;&#125;) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i)&#125; 123(&lt;nil&gt;, &lt;nil&gt;)(42, int)(hello, string) 类型断言 类型断言 提供了访问接口值底层具体值的方式。 1t := i.(T) 该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。 若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。 为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。 1t, ok := i.(T) 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。 否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。 请注意这种语法和读取一个映射时的相同之处。 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; var i interface&#123;&#125; = &quot;hello&quot; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // 报错(panic) fmt.Println(f)&#125; 1234hellohello true0 falsepanic: interface conversion: interface &#123;&#125; is string, not float64 类型选择 类型选择 是一种按顺序从几个类型断言中选择分支的结构。 类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。 12345678switch v := i.(type) &#123;case T: // v 的类型为 Tcase S: // v 的类型为 Sdefault: // 没有匹配，v 与 i 的类型相同&#125; 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。 此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S 的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。 123456789101112131415161718192021package mainimport &quot;fmt&quot;func do(i interface&#123;&#125;) &#123; switch v := i.(type) &#123; case int: fmt.Printf(&quot;Twice %v is %v\\n&quot;, v, v*2) case string: fmt.Printf(&quot;%q is %v bytes long\\n&quot;, v, len(v)) default: fmt.Printf(&quot;I don&#x27;t know about type %T!\\n&quot;, v) &#125;&#125;func main() &#123; do(21) do(&quot;hello&quot;) do(true)&#125; 123Twice 21 is 42&quot;hello&quot; is 5 bytes longI don&#x27;t know about type bool! Stringer fmt 包中定义的 Stringer 是最普遍的接口之一。 123type Stringer interface &#123; String() string&#125; Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。 123456789101112131415161718package mainimport &quot;fmt&quot;type Person struct &#123; Name string Age int&#125;func (p Person) String() string &#123; return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)&#125;func main() &#123; a := Person&#123;&quot;Arthur Dent&quot;, 42&#125; z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125; fmt.Println(a, z)&#125; 1Arthur Dent (42 years) Zaphod Beeblebrox (9001 years) 错误 Go 程序使用 error 值来表示错误状态。 与 fmt.Stringer 类似，error 类型是一个内建接口： 123type error interface &#123; Error() string&#125; （与 fmt.Stringer 类似，fmt 包在打印值时也会满足 error。） 通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil 来进行错误处理。 123456i, err := strconv.Atoi(&quot;42&quot;)if err != nil &#123; fmt.Printf(&quot;couldn&#x27;t convert number: %v\\n&quot;, err) return&#125;fmt.Println(&quot;Converted integer:&quot;, i) error 为 nil 时表示成功；非 nil 的 error 表示失败。 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot; &quot;time&quot;)type MyError struct &#123; When time.Time What string&#125;func (e *MyError) Error() string &#123; return fmt.Sprintf(&quot;at %v, %s&quot;, e.When, e.What)&#125;func run() error &#123; return &amp;MyError&#123; time.Now(), &quot;it didn&#x27;t work&quot;, &#125;&#125;func main() &#123; if err := run(); err != nil &#123; fmt.Println(err) &#125;&#125; Reader io 包指定了 io.Reader 接口，它表示从数据流的末尾进行读取。 Go 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。 io.Reader 接口有一个 Read 方法： 1func (T) Read(b []byte) (n int, err error) Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。 示例代码创建了一个 strings.Reader 并以每次 8 字节的速度读取它的输出。 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;strings&quot;)func main() &#123; r := strings.NewReader(&quot;Hello, Reader!&quot;) b := make([]byte, 8) for &#123; n, err := r.Read(b) fmt.Printf(&quot;n = %v err = %v b = %v\\n&quot;, n, err, b) fmt.Printf(&quot;b[:n] = %q\\n&quot;, b[:n]) if err == io.EOF &#123; break &#125; &#125;&#125; 1234567n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]b[:n] = &quot;Hello, R&quot;n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]b[:n] = &quot;eader!&quot;n = 0 err = EOF b = [101 97 100 101 114 33 32 82]b[:n] = &quot;&quot;","categories":[{"name":"print*,\"hello world!!!\"","slug":"print-hello-world","permalink":"https://blog.youmingsama.cn/categories/print-hello-world/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://blog.youmingsama.cn/tags/golang/"}]},{"title":"超基础链表超完整代码实例大概","slug":"bug的炼金工坊/超基础链表超完整代码实例大概","date":"2020-04-19T00:00:00.000Z","updated":"2020-04-19T00:00:00.000Z","comments":true,"path":"posts/c5f13f7/","link":"","permalink":"https://blog.youmingsama.cn/posts/c5f13f7/","excerpt":"","text":"为了快速记忆，以及遗忘速查，也为了减少碎片化记忆（这是什么鬼？。该板块的代码样例为完整版，本着复制就能运行的态度，大概会持续更新吧 创建链表 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct node *listnode;struct node&#123; int data; listnode next;&#125;;listnode create(int a[])&#123; listnode p,pre,head; head=new node; head-&gt;next=nullptr; pre=head; for(int i=0;i&lt;5;i++)&#123; p=new node; p-&gt;data=a[i]; p-&gt;next=nullptr; pre-&gt;next=p; pre=p; &#125; return head;&#125;int main()&#123; int a[]=&#123;3,2,5,8,7&#125;; listnode k=create(a); k=k-&gt;next; while(k!=nullptr)&#123; cout&lt;&lt;k-&gt;data; k=k-&gt;next; &#125; system(&quot;pause&quot;); return 0;&#125; 查找元素 1234567891011int search(listnode head,int x)&#123; int count=0;//计数器 listnode p=head-&gt;next; while(p!=nullptr)&#123; if(p-&gt;data==x)&#123; count++; &#125; p=p-&gt;next; &#125; return count;&#125; 插入元素 1234567891011void insert(listnode head, int pos, int x)&#123; listnode p=head; for(int i=0;i&lt;pos-1;i++)&#123; p=p-&gt;next; &#125; //c插入到位置的前一个节点，就是pos-1哒 listnode q=new node; q-&gt;data=x; q-&gt;next=p-&gt;next; p-&gt;next=q;&#125; 删除元素 1234567891011121314void del(listnode head,int x)&#123; listnode p=head-&gt;next;//p从第一个节点开始枚举 listnode pre=head;//pre始终保存前驱节点的指针 while(p!=nullptr)&#123; if(p-&gt;data==x)&#123; pre-&gt;next=p-&gt;next; delete(p); p=pre-&gt;next; &#125;else&#123;//如果不是x；吧pre和p都后移一位 pre=p; p=p-&gt;next; &#125; &#125;&#125;","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"code","slug":"code","permalink":"https://blog.youmingsama.cn/tags/code/"}]},{"title":"排序","slug":"hello world/排序","date":"2020-04-07T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/a444b428/","link":"","permalink":"https://blog.youmingsama.cn/posts/a444b428/","excerpt":"","text":"排序嘛之前也不是没写过，就在刚刚水了1000字的时候，我一个ctrl+z按过火了导致不小心没有保存的源文件付诸东流，太草率了，现在说起来心情就有点低落，罢了罢了，我的心情真的平复下来了。话说之前也草草的整理过两篇排序的文章，不过现在在看向曾经整理的东西，啊太幼稚了 性能对比 类别排序方法时间复杂度空间复杂度稳定性 最好情况最坏情况平均情况辅助储存 插入排序直接插入排序O(n)O(n^2)O(n^2)O(1)不稳定 希尔排序O(n)O(n^2)~O(n^1.3)O(1)不稳定 交换排序冒泡排序O(n)O(n^2)O(n^2)O(1)不稳定 快速排序O(nlogn)O(n^2)O(nlogn)O(nlogn)不稳定 选择排序直接选择排序O(n^2)O(n^2)O(n^2)O(1)不稳定 堆排序O(nlogn)O(nlogn)O(nlogn)O(n^2)不稳定 归并排序O(nlogn)O(nlogn)O(nlogn)O(n)不稳定 基数排序K:代排元素的维数，m为基数个数O(m+n)O(k*(n+m))O(k*(n+m))O(m+n)稳定 pssss：makedown语法并没有合并单元格的功能，利用支持html语法的特性纯手撸，嗯看起来果然有点丑 排序有以下几类 种类 方式1 方式2 按储存介质分 内部排序 外部排序 按比较器个个数分 串行排序：单处理器 并行排序：多处理器 按主要操作分 比较排序 基数排序 按辅助空间分 原理排序 非原地排序 按稳定性分 稳定排序：eg插入排序 非稳定排序：eg选择排序 按自然性分 自然排序 非自然排序 插入排序 直接插入排序 插入排序是应该是最简单的排序算法之一了，不过排序算法也没几个。插入排序又N-1趟排序组成，对于P=1到P=N-1趟，插入排序利用了这样的事实；其实从0到位置P上的元素为以排序状态。插入排序利用了这样的事实。0到P-1的元素是已经排过序的。大致过程入下 不难知道，插入排序是将待插入元素一个个的插入到已有序的过程中，插入位置遵循了使用插入仍然保持有序的原则，具体做法是从后往前枚举已有的部分来确定插入位置。具体实现代码如下 12345678910111213141516171819202122#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;void insertsort(int a[],int n)&#123; for(int i=1;i&lt;n;i++)&#123; int temp=a[i];int j=i; while (j&gt;0&amp;&amp;temp&lt;a[j-1]) &#123; a[j]=a[j-1]; j--; &#125; a[j]=temp; &#125;&#125;int main()&#123;int a[]=&#123;9,8,5,2,3,1,4,7,6&#125;;insertsort(a,9);for(int i=0;i&lt;9;i++)&#123; cout &lt;&lt; a[i];&#125; system(&quot;pause&quot;); return 0;&#125; 选择排序 直接选择排序 选择排序也算是最简单的排序算法之一了。没错又是之一（滑稽。甚至我用的这本教程已经自动省略了这个排序算法。这样大概就可以冠以最简单的排序算法之名了吧（雾。简单选择排序是指对于一个序列A[1]~A[n],令i从1到n枚举，进行n糖操作，每趟从待排序[i,n]中选择最小元素。令其与待排序部分的第一个元素A[i]进行交换，这样子的话元素A[i]就会与当前的有序区间[1,i-1]，形成新的有序区间[1,i]，于是在进行n趟排序后，元素就会是有序的。 实现代码如下 1234567891011121314151617181920212223#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;void selectsort(int a[], int n)&#123; for(int i=0;i&lt;n-1;i++)&#123; int k=i; for(int j=i;j&lt;n;j++)&#123; if(a[k]&gt;a[j]) k=j; &#125; swap(a[i],a[k]); &#125;&#125;int main()&#123; int a[]=&#123;1,2,3,5,4,7,8,9,6&#125;; selectsort(a,9); for(int i=0;i&lt;9;i++)&#123; cout &lt;&lt; a[i]; &#125; system(&quot;pause&quot;); return 0;&#125; 选择排序虽然很简单不错啦，但是由于时间复杂度为O(n2)的原因其实大部分情况都不能处理，大概只能处理105这个范围只能的数据。所以在使用的时候要记住上限条件。 kaguyasama哇哇哇哇哇哇哇！！！！！！！ 我已经鸽了好久了！！jojo！！！我不写博客啦！！ 堆排序 大概简介上只有那么短短三句话， 对所有记录建 堆 。 依次取出堆顶元素，就可以得到排好序的序列。 时间复杂度为O(nlogn) 。 堆即是一个可以看作为完全二叉树的数组。《算法导论》第三版这样定义： *The(binary) heap data structure is an array object that we can view as a nearly completely binary tree. 只要一个序列可以看作为一个完全二叉树，它又满足堆的性质，那么它就可以称 之为一个堆。——一个数组可以这样看成一个完全二叉树，将第一个数看作根结点， 第二和第三个数看作第一个数的左孩子和右孩子，…，将第2n和第2n+1数看作 是第n个数的两个孩子。 堆可以分为大堆和小堆，所谓堆属性是指结点应总是大于它的孩子，此为大堆属性。 对于小堆来讲则反之。也就是说堆的根结点总是存储着最大或最小的数，当一个完 全二叉树中所有的结点都满足堆属性时此完全二叉树就可以看作为一个堆。 总的来讲，堆排序的要诀在于堆的一个特性——堆的根结点总是存储着最大或最小的 数。假使我们能将一组数建堆，那么只需要不断的在取出根结点和维持堆属性这两 步中不断循环就可以完成排序了 以下是c++实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std; void HeapAdjust(vector&lt;int&gt; &amp;list, int parent, int length)&#123; int temp = list[parent]; // temp保存当前父节点 int child = 2 * parent + 1; // 先获得左孩子 while (child &lt; length)&#123; // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点 if (child + 1 &lt; length &amp;&amp; list[child] &lt; list[child + 1])&#123; child++; &#125; // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点 if (temp &gt;= list[child])&#123; break; &#125; // 把孩子结点的值赋给父结点 list[parent] = list[child]; // 选取孩子结点的左孩子结点,继续向下筛选 parent = child; child = 2 * parent + 1; &#125; list[parent] = temp;&#125; vector&lt;int&gt; HeadSort(vector&lt;int&gt; list)&#123; int length = list.size(); // 循环建立初始堆 for (int i = length / 2 - 1; i &gt;= 0; i--)&#123; HeapAdjust(list, i, length); &#125; // 进行n-1次循环，完成排序 for (int i = length - 1; i &gt; 0; i--)&#123; // 最后一个元素和第一元素进行交换 int temp = list[i]; list[i] = list[0]; list[0] = temp; // 筛选 R[0] 结点，得到i-1个结点的堆 HeapAdjust(list, 0, i); cout &lt;&lt; &quot;第&quot; &lt;&lt; length - i &lt;&lt; &quot;趟排序:&quot;; for (int i = 0; i &lt; list.size(); i++)&#123; cout &lt;&lt; list[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return list;&#125; int main()&#123; int arr[] = &#123; 5, 4, 6, 7, 2, 3, 1 &#125;; vector&lt;int&gt; test(arr, arr + sizeof(arr) / sizeof(arr[0])); cout &lt;&lt; &quot;排序前:&quot;; for (int i = 0; i &lt; test.size(); i++)&#123; cout &lt;&lt; test[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt; result; result = HeadSort(test); cout &lt;&lt; &quot;排序后:&quot;; for (int i = 0; i &lt; result.size(); i++)&#123; cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 交换排序 冒泡排序 冒泡排序原理实现很简单，要想轻松简单的理解的理解冒泡排序，可以吧数组理解成一个垂直猪蹄，其中最小的元素在顶部，最大的元素在底部。数组从底部往上扫描。就像水的冒泡原理一样，气泡是从底部一点点的往上冒的。如果相邻的两个元素逆序。则交换两者的位置， 首先 比较data[n-1]和data[n-2]之间的大小，如果逆序则互换，接着比较data[n-2]和data[n-3]。有需要时就改变他们的顺序，就这样一直一直的比较到data[1]到data[0]；就这样最小的元素就移动到了顶部。 然而，这只是完成了第一步。我们需要再次对数组进行扫描，比较剩下来的数据项。当有需要的时候需要交换位置。然后就这样哈一直一直的比下去，最后一项比较的是data[1]和data[0];由于data[0]在第一次一定完成后已经是最小的了。也就是位置0，然而第二次冒泡最小的元素会放在第二个位置上也就是1！！！！！然后第三次第四次依次按照同样的方法就行了。到最后一步只需要比较**data[n-1]和data[n-2]**之间的大小就好了。 下面写上伪代码 1234bubblesort(data[],n) for i到n-2 for j=n-1到i+1 如果两者逆序，交换j和j-1位置的元素 具体实现 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;void bubblesort(int data[], int n)//代码就不解释啦八&#123; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = n - 1; j &gt; i; --j) &#123; if (data[j] &lt; data[j - 1]) &#123; swap(data[j], data[j - 1]); &#125; &#125; &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; int a[n]; for (size_t i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; bubblesort(a, n); for (size_t i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i]&lt;&lt;&quot; &quot;; &#125; system(&quot;pause&quot;); return 0;&#125; 快速排序 快速排序(quicksort)是在实践中中目前最快的已知算法，平均运行为O(nlogn)，该算法超级快，主要是由于非常精炼和高度优化的内部循环，虽然他最坏的情况能达到O(n^2)，但只要稍加努力就能避免这种情况。 其核心思想是分治：选择数组中某个数作为基数，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数都比基数小，另外一部分的所有数都都比基数大，然后再按此方法对这两部分数据分别进行快速排序，循环递归，最终使整个数组变成有序。 大概可以总结为一下三个过程 将数列划分为两部分（不是直接分，要求保证相对大小关系） 递归到两个子序列中分别进行快速排序 不用合并，因为此时数列已经完全有序 和归并排序不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。第三步中的序列已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。怎么操作呢？ 为了保证平均时间复杂度，一般是随机选择一个数 m 来当做两个子数列的分界。之后，维护一前一后两个指针 p 和 q，依次考虑当前的数是否放在了应该放的位置（前还是后），当前位置放对了之后，再移动指针继续处理，直到两个指针相遇。如果当前的数没放对呢？比如说如果后面的指针 q 遇到了一个比 m 小的数，那么可以交换 p 和 q 位置上的数，再把 p 向后移一位。其实，快速排序没有指定应如何具体实现第一步，不论是选择 m 的过程还是划分的过程，都不是只有一种实现方法。 一般我们说的快速排序的时间复杂度是平均为 O(nlogn)，最坏是 O(n^2)，实践中几乎不可能达到最坏情况。且因为快速排序的内存访问遵循局部性原理，多数情况下快速排序的表现大幅优于堆排序等其他复杂度为O(nlogn) 的排序算法。 其实，在选择 m 的过程中使用 Median of Medians 算法，就可以保证最坏时间复杂度为 O(nlogn)，但是由于其过于复杂，实践中一般不使用。 具体实现 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int partition(int a[],int left,int right)&#123; int temp=a[left]; while (left&lt;right) &#123; while(left&lt;right&amp;&amp;a[right]&gt;temp)right--; a[left]=a[right]; while(left&lt;right&amp;&amp;a[left]&lt;temp)left++; a[right]=a[left];&#125;a[left]=temp;return left;&#125;void quicksort(int a[],int left,int right)&#123; if(left&lt;right)&#123; int post=partition(a,left,right); quicksort(a,left,post-1); quicksort(a,post+1,right);&#125;&#125;int main()&#123;int a[]=&#123;7,5,6,3,2,4,1,8,9&#125;;quicksort(a,0,8);for(int i=0;i&lt;9;i++)cout &lt;&lt; a[i]; system(&quot;pause&quot;); return 0;&#125; 希尔排序 选择排序也是一种插入排序 说起希尔排序当然是和他的发明者希尔有关系啦（雾，该算法算是最早的一批冲破二次屏障的算法的前辈了。过了若干年后才证明了他的亚二次界，原理是通过比较相距一定间隔的元素来工作；各趟比较所用的距离随着算法的进行而减小，直到比较相邻元素的最后一趟排序为止，所以希尔排序有时也被叫做缩小增量排序(diminishing increment sort) 大概实现图解 重点来啦！！！ Shell 排序是以它的发明者命名的（废话，也称为缩小增量排序法。Shell 排序对不相邻的记录进行比较和移动： 将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同） 对这些子序列进行插入排序 减小每个子序列中元素之间的间距，重复上述过程直至间距减少为 1 Shell 排序的复杂度和间距序列的选取（就是间距如何减小到 1）有关，比如“间距每次除以 3”的 Shell 排序的复杂度是 O(n^2/3)。 具体实现 123456789101112131415161718192021222324#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;void shellsort(int a[],int n)&#123; int i,j,Increment; int temp; for(Increment=n/2;Increment&gt;0;Increment/=2)&#123; for(i=Increment;i&lt;n;i++)&#123; temp=a[i]; for(j=i;j&gt;=Increment;j-=Increment) if(temp&lt;a[j-Increment]) a[j]=a[j-Increment]; else break; a[j]=temp; &#125; &#125;&#125;int main()&#123; int a[]=&#123;4,3,2,7,1,6,8,2,9,5&#125;; shellsort(a,10); for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; system(&quot;pause&quot;); return 0;&#125; 归并排序 归并排序是一种采用了 分治 思想的排序算法。 归并排序分为三个过程： 将数列划分为两部分（在均匀划分时时间复杂度为 O（nlogn）； 递归地分别对两个子序列进行归并排序； 合并两个子序列。 不难发现，归并排序的核心是如何合并两个子序列，前两步都很好实现。直接撂代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100;void merge(int A[], int L1, int R1, int L2, int R2)&#123; int i = L1, j = L2; int temp[maxn], index = 0;//temp临时储存变量 while (i &lt;= R1 &amp;&amp; j &lt;= R2) &#123; if (A[i] &lt;= A[j]) &#123; temp[index++] = A[i++];//如果满足条件将A[i]加入temp &#125; else &#123; temp[index++] = A[j++];//否则加入A[j] &#125; &#125; while (i &lt;= R1) temp[index++] = A[i++];//加入剩余元素 while (j &lt;= R2) temp[index++] = A[j++]; for (i = 0; i &lt; index; i++) &#123; A[L1 + i] = temp[i];//合并或的序列赋值回数组A &#125;&#125;void mergeSort(int A[], int left, int right)&#123; if (left &lt; right) &#123; int mid = (left + right) / 2; mergeSort(A, left, mid); mergeSort(A, mid + 1, right); merge(A,left,mid,mid+1,right); &#125;&#125;int main()&#123; int A[] = &#123;1, 5, 4, 7, 3, 6, 8, 2, 9&#125;; mergeSort(A, 0, 8); for (int i = 0; i &lt; 9; i++) &#123; cout &lt;&lt; A[i]; &#125; system(&quot;pause&quot;); return 0;&#125; 啊，对了加上非递归实现 12345678910111213void mergeSort(int A[])&#123; for (int step = 2; step / 2 &lt; n; step *= 2) &#123; for (int i = 1; i &lt;= n; i += step) &#123; int mid = i + step / 2 - 1; if (mid + 1 &lt;= n) merge(A, i, mid, mid + 1, min(i + step - 1, n)); &#125; &#125;&#125; 如果想观察每一次排序后的结果 12345678910111213void merge(int a[])&#123; for (int step = 2; step / 2 &lt; 9; step *= 2) &#123; for (int i = 0; i &lt; 9; i += step) &#123; sort(a + i, a + min(i + step, 10)); &#125; for (int i = 0; i &lt; 9; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125; 基数排序 首先，我们要有十个桶，和一个大桶（桶里的数根据先到先出的顺序，是一个队列，下文不作说明了） 第一步，把数组里的数依次放到桶里； 第二步，把倒数第i位（i从1开始）为k的数放到第k个桶里； 第三步，从第一个桶开始，把所有数放到大桶里； 第四步，重复第二、三步，直到所有数中的最大数倒数第i位是0； 排序完成 例如对&#123;41, 467, 334, 500, 169, 724, 478, 358, 962, 464&#125;进行基数排序。 1、–&gt; &#123;500&#125;, &#123;41&#125;, &#123;962&#125;, &#123;334, 464&#125;, &#123;467&#125;, &#123;478, 358&#125;, &#123;169&#125; 2、–&gt; &#123;500, 41, 962, 334, 464, 467, 478, 358, 169&#125; 3、–&gt; &#123;500&#125;, &#123;724&#125;, &#123;334&#125;, &#123;41&#125;, &#123;358&#125;, &#123;962, 467, 169&#125;, &#123;478&#125; 4、–&gt; &#123;500, 724, 334, 41, 358, 962, 467, 169, 478&#125; 5、–&gt; &#123;041&#125;, &#123;169&#125;, &#123;334, 358&#125;, &#123;464, 467, 478&#125;, &#123;500&#125;, &#123;724&#125;, &#123;962&#125; 6、–&gt; &#123;041, 169, 334, 358, 464, 467, 478, 500, 724, 962&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;// 求出数组中最大数的位数的函数int MaxBit(vector&lt;int&gt; input)&#123; // 数组最大值 int max_data = input[0]; for (int i = 1; i &lt; input.size(); i++) &#123; if (input[i] &gt; max_data) &#123; max_data = input[i]; &#125; &#125; // 数组最大值的位数 int bits_num = 0; while (max_data) &#123; bits_num++; max_data /= 10; &#125; return bits_num;&#125;// 取数xxx上的第d位数字int digit(int num, int d)&#123; int pow = 1; while (--d &gt; 0) &#123; pow *= 10; &#125; return num / pow % 10;&#125;// 基数排序vector&lt;int&gt; RadixSort(vector&lt;int&gt; input, int n)&#123; // 临时数组，用来存放排序过程中的数据 vector&lt;int&gt; bucket(n); // 位记数器，从第0个元素到第9个元素依次用来记录当前比较位是0的有多少个...是9的有多少个数 vector&lt;int&gt; count(10); // 从低位往高位循环 for (int d = 1; d &lt;= MaxBit(input); d++) &#123; // 计数器清0 for (int i = 0; i &lt; 10; i++) &#123; count[i] = 0; &#125; // 统计各个桶中的个数 for (int i = 0; i &lt; n; i++) &#123; count[digit(input[i], d)]++; &#125; /* * 比如某次经过上面统计后结果为：[0, 2, 3, 3, 0, 0, 0, 0, 0, 0]则经过下面计算后 结果为： [0, 2, * 5, 8, 8, 8, 8, 8, 8, 8]但实质上只有如下[0, 2, 5, 8, 0, 0, 0, 0, 0, 0]中 * 非零数才用到，因为其他位不存在，它们分别表示如下：2表示比较位为1的元素可以存放在索引为1、0的 * 位置，5表示比较位为2的元素可以存放在4、3、2三个(5-2=3)位置，8表示比较位为3的元素可以存放在 * 7、6、5三个(8-5=3)位置 */ for (int i = 1; i &lt; 10; i++) &#123; count[i] += count[i - 1]; &#125; /* * 注，这里只能从数组后往前循环，因为排序时还需保持以前的已排序好的顺序，不应该打 * 乱原来已排好的序，如果从前往后处理，则会把原来在前面会摆到后面去，因为在处理某个 * 元素的位置时，位记数器是从大到到小（count[digit(arr[i], d)]--）的方式来处 * 理的，即先存放索引大的元素，再存放索引小的元素，所以需从最后一个元素开始处理。 * 如有这样的一个序列[212,213,312]，如果按照从第一个元素开始循环的话，经过第一轮 * 后（个位）排序后，得到这样一个序列[312,212,213]，第一次好像没什么问题，但问题会 * 从第二轮开始出现，第二轮排序后，会得到[213,212,312]，这样个位为3的元素本应该 * 放在最后，但经过第二轮后却排在了前面了，所以出现了问题 */ for (int i = n - 1; i &gt;= 0; i--) &#123; int k = digit(input[i], d); bucket[count[k] - 1] = input[i]; count[k]--; &#125; // 临时数组复制到 input 中 for (int i = 0; i &lt; n; i++) &#123; input[i] = bucket[i]; &#125; &#125; return input;&#125;int main()&#123; int arr[] = &#123;50, 123, 543, 187, 49, 30, 0, 2, 11, 100&#125;; vector&lt;int&gt; test(arr, arr + sizeof(arr) / sizeof(arr[0])); cout &lt;&lt; &quot;排序前:&quot;; for (int i = 0; i &lt; test.size(); i++) &#123; cout &lt;&lt; test[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt; result = test; result = RadixSort(result, result.size()); cout &lt;&lt; &quot;排序后:&quot;; for (int i = 0; i &lt; result.size(); i++) &#123; cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 传统艺能 最后给你们整个绝活，咕咕咕咕咕咕，这篇排序前前后后鸽了快一个月才写完，也参考了几篇文章。之所以为什么要鸽一个月嘛…因为当鸽子是真的爽。","categories":[{"name":"print*,\"hello world!!!\"","slug":"print-hello-world","permalink":"https://blog.youmingsama.cn/categories/print-hello-world/"}],"tags":[{"name":"算法啦","slug":"算法啦","permalink":"https://blog.youmingsama.cn/tags/%E7%AE%97%E6%B3%95%E5%95%A6/"}]},{"title":"关于#include与html的奇怪冲突","slug":"bug的炼金工坊/关于include与html的奇怪冲突","date":"2020-04-02T00:00:00.000Z","updated":"2020-04-02T00:00:00.000Z","comments":true,"path":"posts/3c41776c/","link":"","permalink":"https://blog.youmingsama.cn/posts/3c41776c/","excerpt":"","text":"我遇到了一个棘手的问题，在线等，很急！！！当今天也是慢慢悠悠的打开博客那一瞬间突然发现头文件#include后面的东西全都不见了？？？比如说懒人专用头文件#include&lt; bit/stdc++.h&gt;莫名的变成了#include，本来以为我只是粗心忘记打了。不对，我怎么会犯那么愚蠢的错误，打开源文件一看，发现完整版头文件好好的躺在那？？？？然后查看我之前的源代码发现也都是出现了同样的问题？？？？？ 一番操作猛如虎之后【雾】，得知这个#include&lt;&gt;与html的’&gt;‘和’&lt;'冲突所致但是由于提交blog的时候会对&lt;和&gt;进行转义，有时候修改了几次就转不成了(blog引擎的bug)，结果就被当作了一个不可识别的标签。 解决方法 在#include&lt;后面加上空格 但是这样显示出来时也会带上空格，强迫症表示有失美学，而且直接复制下来运行时还需要将原有多余的空格去掉，为什么？？？因为会编译报错啊笨蛋！！！作为一名懒人主义至上的完美人士我绝对采用第二种方法。 使用字符实体&quot;&amp; lt&quot;和“&amp; gt&quot; 这样就没问题了，就是需要费力的换成&amp;lt和&amp;gt了。很好符合完全懒人精神【×】","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"buggggg","slug":"buggggg","permalink":"https://blog.youmingsama.cn/tags/buggggg/"}]},{"title":"Hash表","slug":"bug的炼金工坊/Hash表","date":"2020-03-31T00:00:00.000Z","updated":"2020-04-02T00:00:00.000Z","comments":true,"path":"posts/a1205a06/","link":"","permalink":"https://blog.youmingsama.cn/posts/a1205a06/","excerpt":"","text":"散列表（也叫 Hash 表）是一种应用较为广泛的数据结构，几乎所有的高级编程语言都内置了散列表这种数据结构。在现代的编程语言中，几乎都会有散列表的身影，故而难以忽视它为程序员所带来的种种便利性。散列跟数组是很相似的，较大的区别在于，数组直接通过特定的索引来访问特定位置的数据，而散列表则是先通过散列函数来获取对应的索引，然后再定位到对应的存储位置。这是比较底层的知识了，一般的散列表，在底层都是通过数组来进行存储，利用数组作为底层存储的数据结构最大的好处在于它的随机访问特性，不管数组有多长，访问该数组的时间复杂度都是O(1)。当然这是针对某些情况，在实际应用中它的时间复杂度不一定的O（1）；显而易见这是一种空间换时间的做法、 散列表有多简单呢 散列表在结构上真的是不能再简单了，它是一个包含关键字的具有固定数组的大小。每个关键字被映射到0~TableSize-1这个范围中的某个数，并且被放到适当的单元中，这个映射就叫做散列函数，当然映射的方式就是根据散列函数来制定的。最常见的就是这个关键字(Key)是几就映射到第几个单元，不过这样子的话空间利用率显然不让人感到满意。 当然要设计一个能用的散列表，在底层仅仅用普通的数组是不够的，毕竟我们需要存储的不仅仅是数值类型，还可能会存储字符串为键，字符串为值，或者以字符串为键，某个函数的指针为值 的键值对。在这类情况中，我们需要对底层的结点进行精心设计，才能够让散列表存储更多元化的数据。 无论以何种数据类型为键，我们始终都需要有把键转换成底层数组任意位置索引的能力，通过散列函数可以做到这一点。散列函数是个很考究的东西，设计得不好可能会导致频繁出现多个不同的键映射到同一个索引值的现象，这种现象称之为冲突。除此之外，每次为散列表所分配的空间是有限的，随着元素的插入，散列表会越来越满，这时，冲突的几率就越高。故而，我们需要定期对散列表进行扩张，并把已有的键值对重新映射到新的空间中去，让散列表中的键值对更加分散，降低冲突的几率。这个过程被称为 Resize。这个过程能够在一定程度上降低散列表的冲突几率，提高查找效率。 为什么不用链表来储存键值 对于链表虽然不会有所谓的冲突产生，但是对于链表来说不管是插入，查找还是删除都需要遍历整个链表，假设稍稍运气不好点最坏情况下时间复杂度可能都是O(n)，假设我们储存少量的键值。看起来是没什么问题，但是如果储存大量的键值所花费的时间成本可能真的是令人难以接受。然而对于散列来说只要保证没有冲突发生，它的时间时间复杂度都为O（1），当然这是非常理想的情况，在实际应用中复杂度往往是大于O(1)的。但是我们可以通过设计让它尽量接近O（1）或者达到O(1); 那么如何提高Hash表的查找效率呢 使用平均查找长度ASL来衡量查找效率，ASL取决于 散列函数 处理冲突的方法 散列表的装填因子 a=表中填入的记录数/哈希表长度 接下来是一个超级简单的散列函数 1234Index Hash(ElementType Key, int TableSize)&#123; return Key % TableSize;&#125; 这个就是前面提到的Key是几就映射到第几个位置，这个是最直观最简单的方法了，虽然是空间利用效率不怎么样，但“不也挺好的吗”。虽然空间利用率有些低，但同时也尽可能的避免了不同的键映射到相同的索引值。我觉得是利大于弊的。相比于冲突太多会降低影响效率这点来看，显然除留余数法做散列函数优于其他类型的散列函数。当然往往都是去TableSize的最大质数来避免冲突 如何避免冲突 前面所设计的散列函数真的超级十分简单，然而所分配的空间却最多只能够存储 TableSize 个键值对，这种情况下很快就会产生冲突。所谓冲突就是不同的键，经过散列函数处理之后得到相同的散列值。也就是说这个时候，它们都指向了数组的同一个位置。我们需要寻求一些手段来处理这种冲突，常见的有开放地址法以及链地址法 开放地址法 是当冲突产生的时候通过某种探测手段来在原有的数组上寻找下一个存放键值对位置。如果下个位置也存有东西了则再用相同的探测算法去寻找下下个位置，直到能够找到合适的存储位置为止。常用的大概有下面这三种。 线性探测法 平方探测法 伪随机探测法 线性探测法 线性探测法其实就像线性函数一样，一个自变量对应一个因变量。这样就避免了冲突的产生。，计算公式为hashNext = (hash(key) + i) mod size。举个直观点的例子，目前散列表中索引为 5 的位置已经有数据了。当下一个键值对也想在这个位置存放数据的时候，冲突产生了。我们可以通过线性探测算法来计算下一个存储的位置，也就是(5 + 1) % 7 = 6。如果这个地方也已经有数据了，则再次运用公式(5 + 2) % 7 = 0，如果还有冲突，则继续(5 + 3) % 7 = 1以此类推，直到找到对应的存储位置为止。很明显的一个问题就是当数组越满的时候，冲突的几率越高，越难找到合适的位置。这里本人比较倾向平法探测法，所以这里具体的实现代码使用平法探测法。啊还有一点就是虽然平方探测法可以有效减少聚集，但是他也是避免不了聚集的，只是比线性探测法稍微好那么一点罢了。同样也会产生二次聚集问题。 Give me your code！！！ 123456-------fatal.h-------#include &lt; stdio.h&gt;#include &lt; stdlib.h &gt;#define Error( Str ) FatalError( Str )#define FatalError( Str ) fprintf( stderr, &quot;%s\\n&quot;, Str ), exit( 1 ) 这里和下面链地址法是同一个fatal.h。专业强迫症人士表示必须要加上。 12345678910111213141516171819202122232425---------hashquad.h---------/* Interface for quadratic probing hash table */typedef int ElementType;/* START: fig5_14.txt */ #ifndef _HashQuad_H #define _HashQuad_H typedef unsigned int Index; typedef Index Position; struct HashTbl; typedef struct HashTbl *HashTable; HashTable InitializeTable( int TableSize ); void DestroyTable( HashTable H ); Position Find( ElementType Key, HashTable H ); void Insert( ElementType Key, HashTable H ); ElementType Retrieve( Position P, HashTable H ); HashTable Rehash( HashTable H ); /* Routines such as Delete are MakeEmpty are omitted */ #endif /* _HashQuad_H */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174-------HashEntry----------#include &quot;fatal.h&quot;#include &quot;hashquad.h&quot;#include &amp;lt;stdlib.h&amp;gt;#include &lt; bits/stdc++.h &gt;#define NumItems 400#define MinTableSize (10)using namespace std;enum KindOfEntry&#123; Legitimate, Empty, Deleted&#125;;struct HashEntry&#123; ElementType Element; enum KindOfEntry Info;&#125;;typedef struct HashEntry Cell;/* Cell *TheCells will be an array of *//* HashEntry cells, allocated later */struct HashTbl&#123; int TableSize; Cell *TheCells;&#125;;/* Return next prime; assume N &gt;= 10 */static intNextPrime(int N)&#123; int i; if (N % 2 == 0) N++; for (;; N += 2) &#123; for (i = 3; i * i &lt;= N; i += 2) if (N % i == 0) goto ContOuter; /* Sorry about this! */ return N; ContOuter:; &#125;&#125;/* Hash function for ints */Index Hash(ElementType Key, int TableSize)&#123; return Key % TableSize;&#125;HashTableInitializeTable(int TableSize)&#123; HashTable H; int i; if (TableSize &lt; MinTableSize) &#123; Error(&quot;Table size too small&quot;); return NULL; &#125; /* Allocate table */ H = new HashTbl; if (H == NULL) FatalError(&quot;Out of space!!!&quot;); H-&gt;TableSize = NextPrime(TableSize); H-&gt;TheCells = (Cell *)malloc(sizeof(Cell) * H-&gt;TableSize); if (H-&gt;TheCells == NULL) FatalError(&quot;Out of space!!!&quot;); for (i = 0; i &lt; H-&gt;TableSize; i++) H-&gt;TheCells[i].Info = Empty; //初始化为1 return H;&#125;PositionFind(ElementType Key, HashTable H)&#123; Position CurrentPos; int CollisionNum; CollisionNum = 0; CurrentPos = Hash(Key, H-&gt;TableSize); cout&lt;&lt;H-&gt;TableSize&lt;&lt;&quot; &quot;; while (H-&gt;TheCells[CurrentPos].Info != Empty &amp;&amp; H-&gt;TheCells[CurrentPos].Element != Key) /* Probably need strcmp!! */ &#123; CurrentPos += 2 * ++CollisionNum - 1; if (CurrentPos &gt;= H-&gt;TableSize) CurrentPos -= H-&gt;TableSize; &#125; return CurrentPos;&#125;void Insert(ElementType Key, HashTable H)&#123; Position Pos; Pos = Find(Key, H); if (H-&gt;TheCells[Pos].Info != Legitimate) &#123; /* OK to insert here */ H-&gt;TheCells[Pos].Info = Legitimate; H-&gt;TheCells[Pos].Element = Key; /* Probably need strcpy! */ &#125;&#125;HashTableRehash(HashTable H)&#123; int i, OldSize; Cell *OldCells; OldCells = H-&gt;TheCells; OldSize = H-&gt;TableSize; /* Get a new, empty table */ H = InitializeTable(2 * OldSize); /* Scan through old table, reinserting into new */ for (i = 0; i &lt; OldSize; i++) if (OldCells[i].Info == Legitimate) Insert(OldCells[i].Element, H); free(OldCells); return H;&#125;ElementTypeRetrieve(Position P, HashTable H)&#123; return H-&gt;TheCells[P].Element;&#125;void DestroyTable(HashTable H)&#123; free(H-&gt;TheCells); free(H);&#125;int main(void)&#123; HashTable H; Position P; int i, j = 0; int CurrentSize; H = InitializeTable(CurrentSize = 17); Insert(9, H); Insert(13, H); Insert(6, H); Insert(2, H); int m=14; P=Find(m,H); cout&lt;&lt;P; if(Retrieve(P,H)==m) cout&lt;&lt;&quot;Find！&quot;; else cout&lt;&lt;&quot;Not Find!&quot;; H=Rehash(H); system(&quot;pause&quot;); return 0;&#125; 这里加上的测试代码。同时兼顾了平方探测法的特点，加上了Resize函数，具体实现为Rehash函数。 链地址法 链地址法跟开放地址法的线性探测十分相似，最大的不同在于线性探测法中的下一个节点是在当前的数组上去寻找，而链地址法则是通过链表的方式去追加结点。实际上所分配数组的每一个位置都可以称之为桶，总的来说，开放地址法产生冲突的时候，会去寻找一个新的桶来存放键值对，而链地址法则是依然使用当前的桶，但是会追加新结点增加桶的深度。 Give me your code！！！ 123456----------fatal.h------------#include &lt; stdio.h &gt;#include &lt; stdlib.h &gt;#define Error( Str ) FatalError( Str )#define FatalError( Str ) fprintf( stderr, &quot;%s\\n&quot;, Str ), exit( 1 ) 123456789101112131415161718192021-------hashsep.h---------typedef int ElementType;typedef unsigned int Index;#ifndef _HashSep_H#define _HashSep_Hstruct ListNode;typedef struct ListNode *Position;struct HashTbl;typedef struct HashTbl *HashTable;HashTable InitializeTable(int TableSize);void DestroyTable(HashTable H);Position Find(ElementType Key, HashTable H);void Insert(ElementType Key, HashTable H);ElementType Retrieve(Position P);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &quot;fatal.h&quot;#include &quot;hashsep.h&quot;#include &lt; stdlib.h &gt;#define NumItems 5#define MinTableSize (10)struct ListNode&#123; ElementType Element; Position Next;&#125;;typedef Position List;/* List *TheList will be an array of lists, allocated later *//* The lists use headers (for simplicity), *//* though this wastes space */struct HashTbl&#123; int TableSize; List *TheLists;&#125;;/* Return next prime; assume N &gt;= 10 */static intNextPrime(int N)&#123; int i; if (N % 2 == 0) N++; for (;; N += 2) &#123; for (i = 3; i * i &lt;= N; i += 2) if (N % i == 0) goto ContOuter; /* Sorry about this! */ return N; ContOuter:; &#125;&#125;Index Hash(ElementType Key, int TableSize)&#123; return Key % TableSize;&#125;HashTableInitializeTable(int TableSize)&#123; HashTable H; int i; if (TableSize &lt; MinTableSize) &#123; Error(&quot;Table size too small&quot;); return NULL; &#125; /* Allocate table */ H=new HashTbl; if (H == NULL) FatalError(&quot;Out of space!!!&quot;); H-&gt;TableSize = NextPrime(TableSize); /* Allocate array of lists */ H-&gt;TheLists = (List*)malloc(sizeof(List) * H-&gt;TableSize); if (H-&gt;TheLists == NULL) FatalError(&quot;Out of space!!!&quot;); /* Allocate list headers *//*实现表头*/ for (i = 0; i &lt; H-&gt;TableSize; i++) &#123; H-&gt;TheLists[i] = new ListNode; if (H-&gt;TheLists[i] == NULL) FatalError(&quot;Out of space!!!&quot;); else H-&gt;TheLists[i]-&gt;Next = NULL; &#125; return H;&#125;PositionFind(ElementType Key, HashTable H)&#123; Position P; List L; L = H-&gt;TheLists[Hash(Key, H-&gt;TableSize)]; P = L-&gt;Next; while (P != NULL &amp;&amp; P-&gt;Element != Key) /* Probably need strcmp!! */ P = P-&gt;Next; return P;&#125;void Insert(ElementType Key, HashTable H)&#123; Position Pos, NewCell; List L; Pos = Find(Key, H); if (Pos == NULL) /* Key is not found */ &#123; NewCell = new ListNode; if (NewCell == NULL) FatalError(&quot;Out of space!!!&quot;); else &#123; L = H-&gt;TheLists[Hash(Key, H-&gt;TableSize)]; NewCell-&gt;Next = L-&gt;Next; NewCell-&gt;Element = Key; /* Probably need strcpy! */ L-&gt;Next = NewCell;S &#125; &#125;&#125;ElementTypeRetrieve(Position P)&#123; return P-&gt;Element;&#125;void DestroyTable(HashTable H)&#123; int i; for (i = 0; i &lt; H-&gt;TableSize; i++) &#123; Position P = H-&gt;TheLists[i]; Position Tmp; while (P != NULL) &#123; Tmp = P-&gt;Next; free(P); P = Tmp; &#125; &#125; free(H-&gt;TheLists); free(H);&#125; int main(void)&#123; HashTable H; Position P; int i, j = 0; int k; int CurrentSize; H = InitializeTable(CurrentSize = 13); for(i = 0; i &lt; NumItems-3; i++, j += 71) Insert(j, H); for(i = 0, j = 0; i &lt; NumItems; i++, j += 71)&#123; if( ( P = Find( j, H ) ) == NULL || Retrieve( P ) != j ) printf(&quot;Error at %d\\n&quot;, j); &#125; DestroyTable(H); printf(&quot;End of program.\\n&quot;); system(&quot;Pause&quot;); return 0; &#125; 代码经测试没有问题 除了原来的数据字段之外，还需要维护一个指向下一个冲突结点的指针，实际上就是的链表的方式。这种处理方式有个好处就是，产生冲突的时候，不再需要为了寻找合适的位置而进行大量的探测，只要通过散列函数找到对应桶的位置，然后遍历桶中的链表即可。此外，利用这种方式删除节点也是比较容易的。即便是采用了链地址法，到了一定时候还是要对散列表进行 Resize 的，不然等桶太深的时候，依旧不利于查找。 总体而言，采用开放地址法所需要的内存空间比较少，实现起来也相对简单一些，当冲突产生的时候它是通过探测函数来查找下一个存放的位置。但是删除结点的时候需要另外维护一个状态，才不至于查找链的中断。链地址法则是通过链表来存储冲突数据，这为数据操作带来不少便利性。然而，无论采用哪种方式，都需要在恰当的时候进行 Resize，才能够让时间复杂度保持在O(1)左右。 至于伪随机探测法 经过多方参考大概是这个样子【雾】 上面两个算法最大的特点在于，对于相同的地址输入，总会按照一个固定的路线去寻找合适的位置，这样以后要再从散列表中查找对应的键值对就有迹可循了。其实伪随机数也有这种特性，只要随机的种子数据是相同的，那么每次得到的随机序列都是一定的。可以利用下面的程序观察伪随机数的行为 123456789101112131415#include &lt; stdio.h &gt;#include &lt; stdlib.h &gt;int main()&#123; int seed = 100; srand(seed); int value = 0; int i=0; for (i=0; i&lt; 5; i++) &#123; value =rand(); printf(&quot;value is %d\\n&quot;, value); &#125;&#125; 伪随机种子是seed = 100，这个程序无论运行多少次打印的结果总是一致的，在我的计算机上会打印以下数值 12345value is 365value is 1216value is 5415value is 16704value is 24504 利用这个特性，我们就能够以伪随机的机制来实现伪随机探测函数randomProbing 1234567int randomProbing(Hash *hash, int address, int size) &#123; srand(address); while (!hash[address].isNull) &#123; address = rand() % size; &#125; return address;&#125; 无论采用哪种方式，只要有相同的 address 输入，都会得到相同的查找路线。总体而言，用开放地址法来解决地址冲突问题，在不考虑哈希表 Resize 的情况下，实现起来还是比较简单的。不过不难想到，它较大问题在于当散列表满到一定程度的时候，冲突的几率会比较大，这种情况下为了找到合适的位置必须要进行多次计算。另外还有个问题，就是删除键值对的时候，我们不能把键值对的数据简单地 “删除” 掉，并把当前位置设置成空。因为如果直接删除并设置为空的话会出现查找链中断的情况，任何依赖于当前位置所做的搜索都会作废，可以考虑另外维护一个状态来标识当前位置是 “空闲” 的，表明它曾经有过数据，现在也接受新数据的插入。 PSSSSS: 在这个例子中，我们可以只利用isNull字段来标识不同状态。用数值 0 来标识当前结点已经有数据了，用 1 来标识当前结点是空的，采用 2 来标识当前结点曾经有过数据，目前处于空闲状态，并且接受新数据的插入。这样就不会出现查找链中断的情况了。不过需要对上面的探测函数稍微做一些调整，这里不展开说 插入 通过散列函数计算出键所对应的散列值。 根据散列值从数组中找到相对应的索引位置。 如果这个位置是 “空闲” 的，则插入数据。如果该键值对已经存在了，则替换掉原来的数据。4 如果这个位置已经有别的数据了，表明冲突已经产生。 通过特定的探测法，计算下一个可以存放的位置。 返回第三步。 查找 通过散列函数计算出键所对应的散列值。 根据散列值从数组中找到相对应的索引位置。 如果这个位置为空的话则直接返回说找不到数据。 如果这个位置能够匹配当前查找的键，则返回需要查找的数据。 如果这个位置已经有别的数据，或者状态显示曾经有过别的数据，表明有冲突产生。 通过特定的探测法，计算下一个位置。 返回第三步。 链地址法其实也类似的，可以看上面的具体实现代码。区别在于插入键值对的时候如果识别到冲突，链地址法并不会通过一定的探测法来查找下一个存放数据的位置，而是顺着链表往下搜索，增添新的结点，或者更新已有的结点。查找的时候则是沿着链表往下查找，找到目标数据则直接把结果返回。假设穷尽链表都无法找到对应的数据，表明数据不存在。 双散列 为了避免聚集，在探测时选择跳跃式的探测，即再使用一个散列函数，用来计算探测的位置。假设前面的散列函数为hash1(X)，用于探测的散列函数为hash2(X)，那么一种流行的选择是F(i) = i * hash2(X)，即第一次冲突时探测hash1(X)+hash2(X)的位置，第二次探测hash1(X)+2hash2(X)的位置。模拟表明，双散列的探测几乎和随机冲突解决方法情景相同，这使得双散列在理论上很有吸引力。不过对于平方探测就没有必要使用第二个散列函数了。这个就不在具体说了。 再散列 这个具体的实现方法在前面的开放定址法就已经实现过了，对于平法探测法，如果表的元素填的太满，实际操作估计也就比50%多一点吧。不仅运行时间较长，效率也会变慢。Insert操作也可能失败，所以一种方法是建立另一个大约两倍大的表，扫描整个原始散列表，计算每个未删除的新散列值并将其插入到新表中。具体实现可参考前面实现的源代码。 可扩散列 如果数据量太大而无法装进内存，就需要考虑检索数据所需的磁盘存取次数。前面的两种散列法在发生冲突时可能引起多个区块的读取。 可扩散列允许用两次磁盘访问执行一次查找，插入操作也只需很少的磁盘访问。它可以看作由B-树变化而来，增加 M ，使B-树的深度为1。根保存在内存中，用 D 代表根使用的位数， D 也称为目录，则目录中的项数为 2D 。树叶的元素个数最多为 M ， d**L 为树叶 L 所有元素共有的最高位的位数， d**L≤D 。下图是可扩散列的一个例子。 插入100 插入000000 可扩散列插入时，如果树叶已经满了，则增加目录大小，分裂树叶，未分裂的树叶由相邻的目录项共同指向。可以看到尽管目录被重写，但其他树叶未被访问。需要注意的是，有可能一个树叶的元素有多于 D+1 个前导位相同时需要多次目录分裂，如上图 D=2 时，插入 111010 、 111011 后再插入 111100 ；另一个问题是如果允许重复关键字，若存在超过 M 个重复关键字，则算法无效。 可扩散列提供了对大型数据库插入和查找操作的快速存取。 总结 散列表可以以常数时间实现Insert和Find操作，使用散列表是，注意加装填因这样的细节子也是非常重要的，否则时间界不在有效，当关键字不是短串或者整数时，需要仔细选择散列函数也是非常重要的。 对于链地址法，装填因子不是很大时性能并不会明显降低，但装填因子黑兽应该接近于1，对于开放定址算法，除非玩去哪不可以避免，否则装填因子不应该超过0.5，如果使用线性探测，那么性能会随着接近于1急速下降。可以通过在散列的扩充来实现。保持合理的装填因子，对于空间紧缺并且不可能声明巨大散列表的情况是很重要的。 二叉树也可以用来实现Insert和Find运算，虽然平均时间界为O（log N)。但是显然二叉查找树更强大，散列不可能找出最小元素。除非准确的知道一个字符串。否则对于散列表来说是不可能有效的找到它的，二叉查找树可以在一定范围内迅速查找，而且单单从时间界来看O（log N)也不必O（1）大多少，这是因为使查找树不需要多余的乘法和除法。 散列表的应用非常广泛，编译器使用散列表跟踪源代码中的声明变量，这种数据结构叫做符号表。还有用是在为游戏编制的程序中，当程序搜索游戏的不同行时，它要跟踪通过计算基于位置的散列函数而看到的一些位置，如果同样的位置在出现时通常经过简单的移动变换来避免昂贵的重复计算，游戏程序的这种特点一般叫做交换表。 至于可扩散列的具体实现 写是不可能写的,只能偶尔划划水这样子,才能勉强维持的了水博客这样子。","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"}]},{"title":"github被攻击之小蒟蒻瑟瑟发抖","slug":"bug的炼金工坊/github被攻击之小蒟蒻瑟瑟发抖","date":"2020-03-30T00:00:00.000Z","updated":"2020-03-30T00:00:00.000Z","comments":true,"path":"posts/fd7e80ac/","link":"","permalink":"https://blog.youmingsama.cn/posts/fd7e80ac/","excerpt":"","text":"事情发生在3月26日，我一边在修改博客的css样式，一边在不停的提交查看效果，然而前一秒还能安然这刷新的博客，当我下一秒在此刷新是，谷歌竟然发出了证书无效的警告！！！！？ 在这万分危急的时刻，我第一反应是网络劫持【雾】，转念一想加一寻思不对啊，静态网站也有人攻击？？？于是这个想法在不到0.1秒的时间内被我丢弃，然后开始怀疑我github证书是不是过签了，按说提前一个月就应该自动续签的？？？一番操作猛如虎。确定了没问题之后，我开始怀疑是ip解析出了问题，然后我ping了一下现有ip。也ping的通啊。我现有中国地区解析ip是185.199.111.153.我把官方提供的110，109，108，试了个遍。在搜索引擎内内输入ip地址仍然不能打开，仍然是谷歌的证书无效的警告。怎么肥事???我慌了，小蒟蒻感觉很慌。我觉的现在非常有可能是github pages受到了攻击，当然github还能打开。当然作为一个小蒟蒻这个时候就应该去求助大佬了。 啥？？？ 打不开？？？？ 你确定？？？ 大佬疑问三连，纳尼！！还真打不开，一顿操作猛如虎。我们发现了网站证书变为一张通过私人QQ邮箱自签名的证书。生成时间为2019年9月26。我本来以为这是攻击者为了生成CA证书，随便填的邮箱…然后看网上的消息这个QQ号好像就是攻击者本人？？？？不是吧，真的留了QQ号？？？emmmmmm牛啊！！！！！嘛，事到如今也只能等平台恢复了。在攻击事件过了几十个小时后github和github pages恢复了正常的访问。其实这已经不是github在国内遭受的第一次中间人攻击了。2013年也曾发生过过。 中间人攻击 中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。 一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。 简单点来说，所谓的中间人攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而通信的双方却毫不知情。所以说建立安全的HTTPS通信非常重要！!！！【溜】 参考资料 “Man-in-the-MiddleAttack”百度百科","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://blog.youmingsama.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"是B树不是B-树","slug":"hello world/是B树不是B-树","date":"2020-03-26T00:00:00.000Z","updated":"2020-03-27T00:00:00.000Z","comments":true,"path":"posts/c7537434/","link":"","permalink":"https://blog.youmingsama.cn/posts/c7537434/","excerpt":"","text":"是B树不是B-树 学之前找了一下网上的资料。B树，B-树是两种树？？？然后才发现B-树就是B树，因为B-tree然后国内大多数直译为B-tree，不得不说这真是一种非常糟糕的翻译。然后就是我这本国外教材上的B树内容真的是非常的枯燥。然后之前在网上看到了一篇非常有意思的介绍B树的漫画然后我就将他转载来了。不得不说这又是一次成功的剽窃。 以下文章来源于转载**转载链接** 本文提到的「B-树」，就是「B树」，都是 B-tree 的翻译，里面不是减号-，是连接符-。因为有人把 B-tree 翻成 「B-树」，让人以为「B树」和「B-树」是两种树，实际上两者就是同一种树。 ———————————— ———————————— 二叉查找树的结构： 第1次磁盘IO： 第2次磁盘IO： 第3次磁盘IO： 第4次磁盘IO： 下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征： 1.根结点至少有两个子女。 2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 4.所有的叶子结点都位于同一层。 5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 第1次磁盘IO： 在内存中定位（和9比较）： 第2次磁盘IO： 在内存中定位（和2，6比较）： 第3次磁盘IO： 在内存中定位（和3，5比较）： 自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。 节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。 自顶向下查找元素11的节点位置。 删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋） 就这样小灰再也没有收到那个面试官的电话【雾】","categories":[{"name":"print*,\"hello world!!!\"","slug":"print-hello-world","permalink":"https://blog.youmingsama.cn/categories/print-hello-world/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"}]},{"title":"树的遍历","slug":"bug的炼金工坊/树的遍历","date":"2020-03-25T00:00:00.000Z","updated":"2020-04-21T00:00:00.000Z","comments":true,"path":"posts/332b8f17/","link":"","permalink":"https://blog.youmingsama.cn/posts/332b8f17/","excerpt":"","text":"树的遍历 这是一篇水文【理直气壮】 废话不多说先上代码 先序遍历 12345678910void PreorderTravel(AVLTree T)&#123; if (T != NULL) &#123; printf(&quot;%d\\n&quot;, T-&gt;Element); PreorderTravel(T-&gt;Left); PreorderTravel(T-&gt;Right); &#125;&#125; 节点在其儿子的节点前进行处理，这种遍历可以用来利用节点深度来标记每一个节点 中序遍历 123456789void InorderTravel(AVLTree T)&#123; if (T != NULL) &#123; InorderTravel(T-&gt;Left); printf(&quot;%d\\n&quot;, T-&gt;Element); InorderTravel(T-&gt;Right); &#125;&#125; 中序遍历的一般策略是首先遍历左子树，然后是当前节点，最后遍历右子树，这个算法有趣的部分除他简单的特性外，还在于总运行时间为O（N）。这是因为在树的每一个节点除进行的工作都是常数时间的，每一个节点访问一次，而在每一个节点进行的工作是检测是否为NULL，建立两个过程调用并执行输出函数，由于每个节点的工作发费时间以及总共有N个节点，因此运行时间为O（N）； 后序遍历 123456789void PostorderTravel(AVLTree T)&#123; if (T != NULL) &#123; PostorderTravel(T-&gt;Left); PostorderTravel(T-&gt;Right); printf(&quot;%d\\n&quot;, T-&gt;Element); &#125;&#125; 当有时我们需要处理两个子树然后才能处理当前节点。例如，为了计算一个节点的高度，我们需要知道他两棵子树的高度，由于检查一些特殊情况总是有益的，特别是啊在我们使用递归的情况下。因此我们需要注意这个声明中的树叶的高度，运行时间和上面同出一辙也是O（N）； 新的更新加上了层序遍历 层序遍历和bfs很像，从上到下一层一层的进行遍历 根节点root加入队列 取出队首节点访问它 如果该节点有左孩子，将左孩子入队 如果该节点有右孩子，将右孩子入队 返回第二步，直到队列为空。 12345678910111213void LayerOrder(T root)&#123; queue&lt;T&gt;q; q.push(root); while(!q.empty())&#123; T now=q.front(); q.pop(); cout&lt;&lt;now-&gt;data; if(now-&gt;Left!=nullptr) q.push(now-&gt;Left); if(now-&gt;Right!=nullptr) q.push(now-&gt;Right); &#125;&#125; 今天的我果然也没有鸽呢","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"}]},{"title":"AVL树","slug":"bug的炼金工坊/AVL树","date":"2020-03-23T00:00:00.000Z","updated":"2020-03-23T00:00:00.000Z","comments":true,"path":"posts/973716ad/","link":"","permalink":"https://blog.youmingsama.cn/posts/973716ad/","excerpt":"","text":"AVL树 我就鸽了一天哦！！！【雾】 AVL树，是一种平衡(balanced)的二叉搜索树(binary search tree, 简称为BST)；AVL树是带有平衡条件的二叉查找树。由于各种算法教材上对 AVL 的介绍十分冗长，造成了很多人对 AVL 树复杂、不实用的印象。但实际上，AVL 树的原理简单，实现也并不复杂。好像的确是这样啊【雾】…相对来说这个平衡条件必须要容易保持，而且他须保证书的深度是O（log N)最简单的想法是要求左右树相同的高度。它有以下两个性质： 任意一个结点的key，比它的左孩子key大，比它的右孩子key小； 任意结点的孩子结点之间高度差距最大为1； 空二叉树是一个 AVL 树 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树。 树高为 O（log N）； 空树的高度定为-1 平衡因子：右子树高度 - 左子树高度 另一种平衡条件是要求每个节点都必须要有相同的左子树和右子树。如果空子树的高度定义为-1，那么只有具有2^K-1个节点的理想平衡树满足这个条件，因此虽然这个平衡树保证了树的深度小，但是它太严格了，难以使用。前面我们说了要想满足AVL树的条件，左子树和右子树的高度必须&lt;=1 一棵树最少节点数满足斐波那契数列，且S(h)=S(h-1)+S(h-2)+1,对于h=0;S(1)=1;h1=1,S(h)=2;h代表AVL树中的高。 这部分的验证代码 123456789101112131415#include&lt; bits/stdc++.h&gt;using namespace std;int f(int n)&#123; if(n==0) return 1; else if(n==1) return 2; else return f(n-1)+f(n-2)+1;&#125;int main()&#123;int n;cin&gt;&gt;n;cout&lt;&lt;f(n-1)+f(n-2)+1&lt;&lt;endl;system(&quot;pause&quot;);&#125; 当进行插入操作时 我们需要更新通向根节点路径那些节点的所有平衡信息，而进行插入操作时，我们需要更新通向根节点路径上的那些节点的所有平衡信息，而插入操作可能存在的困难在于，插入一个根节点可能破坏AVL树的特性，如果发生了这种情况，那么要把性质恢复以后才认为这一步插入完成，事实上，这总可以通过对树的简单修正来做到，当然了这个我们称作旋转。 当然了在插入以后，只有那些从插入点到根节点的路径上的节点间的平衡可能被改变，因为只有这些节点的子树可能发生变化，当我们沿着这条路径更新平衡信息时，我们可以找到一个节点，他的新平衡破坏了AVL的平衡条件，所以我们需要找出这样一个节点并重新平衡这棵树，并证明，这一平衡保证满足AVL特性。 如果把必须重新平衡的节点叫做a好了由于任意节点最多有两个孩子，因此当高度不平衡时，a点的两棵子树高度差为2.很容易看出不平衡可能存在以下几种情况 对a的左儿子的左子树进行一次插入 失衡结点&quot; 的左子树比右子树高 2，左孩子（即 x）下的左子树比右子树高 1。我们只需对 “以 y 为根的子树” 进行 “左左旋转 (ll_rotate)” 即可。一次旋转后，恢复平衡。 对a的左儿子的右子树进行一次插入 所谓的左右，即 “失衡结点” 的左子树比右子树高 2，左孩子（即 x）下的右子树比左子树高 1。观察发现，若先对 “以 x 为根的子树” 进行 “右右旋转 (rr_rotate)”，此时 “以 y 为根的子树” 恰好符合 “左左失衡”，所以再进行一次 “左左旋转 (ll_rotate)”。两次旋转后，恢复平衡。 对a的右儿子的左子树进行一次插入 所谓的右左，即 “失衡结点” 的右子树比左子树高 2，右孩子（即 x）下的左子树比右子树高 1。观察发现，若先对 “以 x 为根的子树” 进行 “左左旋转 (ll_rotate)”，此时 “以 y 为根的子树” 恰好符合 “右右失衡”，所以再进行一次 “右右旋转 (rr_rotate)”。两次旋转后，恢复平衡。 对a的右儿子的右子树进行一次插入 所谓的右右，即 “失衡结点” 的右子树比左子树高 2，右孩子（即 x）下的右子树比左子树高 1。我们只需对 “以 y 为根的子树” 进行 “右右旋转 (rr_rotate)” 即可。一次旋转后，恢复平衡。 单旋转 单旋转顾名思义就是通过一次旋转来达到AVL树平衡的目的，前面的左左平衡和右右平衡是但旋转，刚好是镜像对称 双旋转 顾名思义通过两次旋转来达到平衡的目的左右和右左平衡是双旋转，也刚好是镜面对称。但深度依旧没办法降低，一次旋转无法降低它的深度就需要双旋转了。 多说无益！！！那就直接扔代码了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt; bits/stdc++.h&gt;using namespace std;typedef struct AVLnode *Position;typedef struct AVLnode *AVLTree;typedef int ElementType;struct AVLnode&#123; ElementType Element; AVLTree Left; AVLTree Right; int Height;&#125;;static int Height(Position P)&#123; if (P == nullptr) return -1; else return P-&gt;Height;&#125;static Position singleRotateWithRight(Position k2)&#123; Position k1; k1 = k2-&gt;Right; k2-&gt;Right = k1-&gt;Left; k1-&gt;Left = k2; k2-&gt;Height = max(Height(k2-&gt;Left), Height(k2-&gt;Right)) + 1; k1-&gt;Height = max(Height(k1-&gt;Right), Height(k2-&gt;Left)) + 1; return k1; //返回新的根节点，后面也是一样哒&#125;static Position singleRotateWithLeft(Position k2)&#123; Position k1; k1 = k2-&gt;Left; k2-&gt;Left = k1-&gt;Right; k1-&gt;Right = k2; k2-&gt;Height = max(Height(k2-&gt;Left), Height(k2-&gt;Right)) + 1; k1-&gt;Height = max(Height(k1-&gt;Left), Height(k2-&gt;Right)) + 1; return k1;&#125;static Position DoubleRotateWithRight(Position k3)&#123; k3-&gt;Right = singleRotateWithLeft(k3-&gt;Right); return singleRotateWithRight(k3);&#125;static Position DoubleRotateWithLeft(Position k3)&#123; k3-&gt;Left = singleRotateWithRight(k3-&gt;Left); return singleRotateWithLeft(k3);&#125;AVLTree Insert(ElementType X, AVLTree T)&#123; if (T == nullptr) &#123; T = new AVLnode; if (T == nullptr) cout &lt;&lt; &quot;error&quot;; else &#123; T-&gt;Element = X; T-&gt;Height = 0; T-&gt;Left = T-&gt;Right = nullptr; &#125; &#125; else if (X &lt; T-&gt;Element) &#123; T-&gt;Left = Insert(X, T-&gt;Left); if (Height(T-&gt;Left) - Height(T-&gt;Right) == 2) if (X &lt; T-&gt;Left-&gt;Element) T = singleRotateWithLeft(T); else T = DoubleRotateWithLeft(T); &#125; else if (X &gt; T-&gt;Element) &#123; T-&gt;Right = Insert(X, T-&gt;Right); if (Height(T-&gt;Right) - Height(T-&gt;Left) == 2) if (X &gt; T-&gt;Right-&gt;Element) T = singleRotateWithRight(T); else T = DoubleRotateWithRight(T); &#125; T-&gt;Height = max(Height(T-&gt;Left), Height(T-&gt;Right)) + 1; return T;&#125;int main()&#123; AVLTree T; T = nullptr; T = Insert(1, T); T = Insert(15, T); T = Insert(3, T); printf(&quot;Root: %d\\n&quot;, T-&gt;Element); system(&quot;pause&quot;); return 0;&#125; 反正大概我知道的就那么多了【逃】","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"}]},{"title":"树同学是个好同志","slug":"bug的炼金工坊/树同学是个好同志","date":"2020-03-14T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/fd6da870/","link":"","permalink":"https://blog.youmingsama.cn/posts/fd6da870/","excerpt":"","text":"树同学她是个好同志 思前想后我决定递归先鸽了，相比于我们的递归同学。我觉得树同学才是我的真爱！！！当然我只是选择先爱我们的树同学，递归同学您就往后稍稍得嘞。 树 对于少量的数据我们可以用链表快速高效的访问，但对于大量的输入数据，链表就显得完全力不从心了，因为链表的线性访问，实在是太慢了。虽然链表可以提供比数组更大的灵活性，但很难使用他们对组织分层表示。栈和队列虽然也反映了某些层次，但他们是一维的。基于总总，终于万众期待的转学生树…于是我们创建了一个新的数据类型，称为树。 定义树的一种自然的方法是递归，一棵树是一些节点的集合 这个集合可以是空集 若非空，则一棵树有称作根(root)的节点r以及0个或者多个非空的子树T1，T2，T3…组成 这些子树中每一课都被来自根r的一条有向的边（eage）所连接 每一棵子树的根叫做根r的儿子(child)，而r是每一棵子树的父亲(parent) }树大部分操作的运行时间都在O(log N) 树的种类 我们可能已经听过很多树的名词，例如，红黑树，霍夫曼树，B树，B+树，平衡二叉树等等，而本文将要介绍二叉查找树，很多其他树都是它的变种，不像链表的线性访问，二叉查找树的大部分操作时间复杂度都为O(logN)。 关于父亲儿子外祖父兄弟孙子之类的 我觉得这就没有必要讲的吧，各位不懂的…代入啊代入 树的实现 实现树的一种最常见的方法就是在每一个节点除数据外还需要一些指针，使得该节点每一个son都有一个指针指向它。树并没有规定子节点数量，所以子节点数可以变化很大而且事先不知道。因此没办法建立到各个子节点之间的链接，因为这样太浪费空间了。但是其实解法也很简单：`我们可以将每个节点的所有儿子都放在树节点的链表中。 我们简单声明一个树的节点 1234567typedef int ElementType;typedef struct TreeNode *PtrToNode;struct TreeNode&#123; ElementType Element; PtrToNode firstchild;//第一个儿子 PtrToNode nextSibling;//下一个兄弟&#125;; emmmmmm看起来很简单对吧 树的遍历及应用 树有很多应用，比如Unix，dos在内的许多操作系统中的目录结构大多数反映分层结构的都是使用树来完成的。树的遍历有这难以比拟的优势。对于一个链表来说如果我们要查找他的一个元素，最坏的情况要从第一个遍历到最后一个，假如说有10000个元素我们就需要遍历到9999个元素才能找到。那么假如是我们是定义在树中即使要定义到最远的那个位置，测试次数也会大大减少。不同节点的树可能也有不同的算法。事实上，人们也已经开发出了这种算法。这里我们重点讨论二叉树。 二叉树 ~~二叉树顾名思义就是很二。~~一个节点要分为左节点和右节点。 节点层次:就是从根到该节点所有的弧加一,所以根节点的层次是0,非空节点最低就是2了 以此类推 第一层有1=2^0【由于mathjax的奇怪报错，我放弃使用渲染了，凑合看吧】 第二层有2=2^1 第三层有4=2^2 第四层… 第五层… 第六层… 咦？你们铐我干什么？？什么！！！我没有水博客啊你们相信我啊！！！！ 满足该条件被称为完全二叉树 不难看出所有的非终端节点都有两个节点，所有叶节点都在同一节点上，第i+1层有2^i个节点。 对于非空二叉树来说，若其所有的非终端节点都有两个子节点，则叶节点的数目m大于非终端节点数目k，且m=k+1 对于一般二叉树来说她的深度要比n小得多，这个平均深度为O（ N ）【这里出现的是根号n，这里用的是mathml，如果出现其他奇怪的符号那就没办法了，火狐上测试是可以正常显示的】对于二叉查找树也被称为有序二叉树 其平均深度是O(log N)，但是呢我们有可能会遇到最糟糕的情况，没错就是完完全全笔笔直直一条直线这种情况深度就大到了N-1； 二叉树的实现 不出意外的来说一个二叉树最多有两个儿子【废话】，我们可以用指针直接指向他们，树节点在声明上和双链表很像。 在声明中，一个节点就是由key加上两个指向其他节点的指针（Left and Right)组成的结构。链表上的很多东西放在树上也同样适用，当进行一次插入操作时调用malloc创建节点【俺一般都用new，毕竟懒】节点调用后可以调用free删除后被释放。树一般华城圆圈并用一些直线连接起来。二叉树本身就是图。当然涉及到树时我们也没有必要画出Null指针，因为N个节点的一颗二叉树就需要N+1NULL指针； 12345678typedef int ElementType;typedef struct PtrToNode Tree;typedef struct TreeNode *PtrToNode;struct TreeNode&#123; ElementType Element; PtrToNode Left; PtrToNode Right;&#125;; 表达式树 声明一点表达式树的树叶就是操作数。比如是常数或者变量，而其他的节点为操作符，由于这里的所有操作都是二元的，因此棵特定的树为二叉树。 大致过程为 如果符号是操作数，那么我们就建立一个单节点树并将一个指向它的指针推入栈中 如果符号是操作数，则从栈中弹出两棵树T1和T2（先弹出T1），并形成一颗以操作符为根的树，其中T1为右儿子，T2为左儿子； 然后将新的树压入栈中，继续上述过程。 来看一个栗子吧假如说输入为a b + c d e + * * （1）依次读入操作数a 和 b，并压入栈中 （2）紧接着“+”被读入，因此指向这两科树的指针被弹出，一颗新的树形成了，而指向该树的指针被压入栈中 （3）然后c，d，e被读入，在每个单节点被创建后，指向对应的树的指针被压入到栈中。 接下来读入“+”号，因此两棵树合并。 再次读入“+”号，因此，我们弹出两个树指针并形成一个新的树，“ * ”是它的根。 读入最后一个符号，两棵树合并，而指向最后的树的指针留在栈中。 查找树ADT-------二叉查找树 二叉树一个非常非常非常重要的应用应该就是查找了吧！！！如果要使一个二叉树变成二叉查找树的性质是，对于每个节点X，他的左子树的所有关键字值小于X的关键字值，而他的右子树中的所有关键字值大于X关键字值。这意味着该树所有的元素都可以使用某一种统一的方式排序,这点非常重要。 初始化MakeEmpty 这个操作主要用于初始化 12345678SearchTree makeEmpty(SearchTree Tree)&#123; if(Tree==nullptr)&#123; makeEmpty(Tree-&gt;Left); makeEmpty(Tree-&gt;Right); free(Tree); &#125; return nullptr;&#125; 一般的写法是初始化为单节点树，比如TreeNode *tree = nullptr;但是这里用了树的递归定义建立了一棵空树。 Find 这个操作一般需要返回指向树T中具有关键字X节点的指针，如果这种节点不存在就返回NULL；如果T是NULL我们就返回NULL，如果存储在T中的关键字是X，我们就可以返回T；然后还需要注意测试顺序： 判断是否为空树，否则就要一直在NULL兜圈子了 最不可能的情况应该放在最后进行 尾递归尽量用赋值+goto解决，否则可能导致栈空间被用尽，但这里使用时合理的，因为栈空间的量不过才O（log N)而已 1234567891011Posttion Find(ElementType X, SearchTree Tree)&#123; if (Tree == nullptr) return nullptr; if (X &lt; Tree-&gt;Element) return Find(X, Tree-&gt;Left); else if (X &gt; Tree-&gt;Element) return Find(X, Tree-&gt;Right); else return Tree;&#125; 嘛。这里吧goto代替尾递归的也给加上吧 123456789101112131415Posttion Find(ElementType X, SearchTree Tree)&#123;next: if (Tree == nullptr) return nullptr; if (X &lt; Tree-&gt;Element) Tree = Tree-&gt;Left; else if (X &gt; Tree-&gt;Element) &#123; Tree = Tree-&gt;Right; goto next; &#125; else return Tree;&#125; FindMin和FindMax 返回树中的最大元和最小元的位置 对于FindMin从根开始只要有左儿子就向左进行，终止点是最小元素。 至于FindMax当然是反过来啊！！ 递归是如此的简单以至于很多程序猿都不厌其烦的使用它。这里我偏不。 FindMIn的递归实现 1234567Posttion FindMin(SearchTree Tree)&#123; if(Tree==nullptr) return nullptr; else if(Tree-&gt;Left==nullptr) return Tree; else return FindMin(Tree-&gt;Left);&#125; FindMax的非递归实现 123456Posttion FindMax(SearchTree Tree)&#123; if(Tree!=nullptr) while(Tree-&gt;Right!=nullptr) Tree=Tree-&gt;Right; return Tree;&#125; 要小心处理空树这种情况，小心原地兜圈圈 Insert 插入的操作是相对简单的啊！将X插入到树T中这件事，可以用Find那样沿着树来查找。如果找到X可以做一些更新啊，否则将X插入到遍历路径的最后一点上。必如说我们要入5，先找到关键字4的节点出，我们需要向右行进，但是右边不存在子树，所以5不在这棵树上。因此我们需要插入5。 12345678910111213141516171819SearchTree insert(ElementType X, SearchTree Tree)&#123; if (Tree == nullptr) &#123; Tree = new TreeNode; if (Tree == nullptr) cout &lt;&lt; &quot;error&quot;; else &#123; Tree-&gt;Element = X; Tree-&gt;Left = Tree-&gt;Right = nullptr; &#125; &#125; else if (X &lt; Tree-&gt;Element) Tree-&gt;Left = insert(X, Tree-&gt;Left); else if (X &gt; Tree-&gt;Element) Tree-&gt;Right = insert(X, Tree-&gt;Right); return Tree;&#125; 初始的T指向该树的根，根在插入时变化，因此Insert被写成一个指向新树根的指针，所以的两次递归把X插到适当的子树中 Delete 删除算是比较难的操作了，一旦发现要删除的节点我们需要考虑以下几种情况 节点只有一片树叶，可以立刻被删除 如果节点有一个儿子，那该节点可以在其父节点调整指针绕过该节点后被删除 比较复杂的情况 相对来说比较复杂的情况是处理具有两个儿子的节点，比较常用的策略是用其右子树的最小数据代替该节点的数据并递归删除那个节点（现在它是空的），因为右子树的最小节点不可能有左儿子，所以第二次删除相对容易。 抱歉啊一不留神做完图发现2没换？？？第二个图的2应该换成3 12345678910111213141516171819202122232425262728SearchTree Delete(ElementType X, SearchTree Tree)&#123; Posttion TemCell; if (Tree == nullptr) cout &lt;&lt; &quot;Element not found&quot; &lt;&lt; &quot;\\n&quot;; else if (X &lt; Tree-&gt;Element) Tree-&gt;Left = Delete(X, Tree-&gt;Left); else if (X &gt; Tree-&gt;Element) Tree-&gt;Right = Delete(X, Tree-&gt;Right); else if (Tree-&gt;Left &amp;&amp; Tree-&gt;Right) &#123; TemCell = FindMin(Tree-&gt;Right); Tree-&gt;Element = TemCell-&gt;Element; Tree-&gt;Right = Delete(Tree-&gt;Element, Tree-&gt;Right); &#125; else &#123; TemCell = Tree; if (Tree-&gt;Left == nullptr) Tree = Tree-&gt;Right; else if (Tree-&gt;Right = nullptr) Tree=Tree-&gt;Left; free(TemCell); &#125; return Tree;&#125; 这个程序的效率并不高，因为它沿该树进行两趟搜索一查找和删除右子树中最小的节点。 平均情况 在之前，出了MakeEmpty之外我们所有的操作都花费了O（log N）因为我们用常数时间在树中降低了一层，这样对树的操作大概降低了一半左右。出了前面提到的MakeEmpty其他都是O（d），其中d表示所访问的关键字深度。 一棵树所有的节点深度的和被称为内部路径长,如果我们现在要计算二叉查找树的平均内部路径长，其中的平均是对向二叉查找树中所有的可能的插入序列进行的。 D（N）是N个节点的内部路径长 D(1) 0 具有i节点的左子树 D(i) 右子树 D(N-i-1) D(N) D(i)+D(n-i-1)+N-1 D(N)=2/N{(j=0-&gt;N-1)D(j)}+N-1 D(N)=O(N log N) 在原树中所有节点要加深1度 这个看起来让人感觉非常愉悦，但是仅凭这个我们是无法保证这个O（log N）是完全正确的，原因在于去删除操作，我们并不清楚是否所有二叉查找树都是等可能出现的，在删除的时候我们选择该元素的最小右子树代替，这种算法有利于左子树比右子树深，当我们进行大量的删除之后高达几十万次就可以明显的看待两边显著的差别。左子树明显会比右子树要深。为了保证所有的节点不得过深所以就搞来了所谓的AVL树。这是一种超老的平衡查找树。 溜了溜了【猝不及防】","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"}]},{"title":"再探队列","slug":"bug的炼金工坊/再探队列","date":"2020-03-10T14:58:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/ffe3b3b2/","link":"","permalink":"https://blog.youmingsama.cn/posts/ffe3b3b2/","excerpt":"","text":"再探队列 我为什么要说再？？？？？打算明天在总结的想想不能再鸽了啊。因为菜鸡越鸽越菜！为了防止我成为弱弱弱弱的菜鸡所以很有必要好好好好学习。 什么是队列 队列是一个简单的等待数列。尾部加入元素，头部删除元素，和栈不同的是它是可以两端都是用的一种结构：一端用来加入元素，一端用来删除元素。因此最后一个元素只能等排在他之前的元素全部删除之后才可以操作。操作和栈都差不多 clean()----清空队列 isEmpty()----判断队列是否为空 enqueue(a)-----在尾部加入元素a dequeue()------取出队列的第一个元素 FristEI()-------返回队列第一个元素但不删除 那么接下来就先写一个超级简单模板库队列【毕竟我是辣鸡嘛】 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;queue&lt;int&gt; q1;queue&lt;int,list&lt;int&gt;&gt;q2;q1.push(1);q1.push(2);q1.push(3);q1.push(4);q2.push(5);q2.push(6);q2.push(7);q2.push(8);q1.push(q2.back());while(!q1.empty())&#123; cout&lt;&lt;q1.front()&lt;&lt;&quot; &quot;; q1.pop();&#125;while (!q2.empty())&#123; cout&lt;&lt;q2.front()&lt;&lt;&quot; &quot;; q2.pop();&#125;system(&quot;pause&quot;); return 0;&#125; 这是标准模板库中的队列，自己写模板什么的…毕竟我是辣鸡嘛 顺序队列 不理想的设计【雾】： 1 . 若使用顺序表的尾端插入实现enqueue操作，根据队列性质，出队操作应该在表的首端进行。为了维护顺序表的完整性（表元素在表前端连续存放），出队操作取出当时的首元素后，就需要把表中其余元素全部前移，这样就会是一个 O(n) 时间的操作。 2 . 反过来：从尾端出队是 O(1) 操作，但从首端入队就是 O(n) 时间操作，这种设计也不理想。 3 . 另一种是在队首元素出队后表中的元素不前移，但记住新队头位置。如果队列中没有空闲了，只需要在入队时，再集中触发一次数据的搬移操作。 顺序队列也被称为队列的数组是实现，我写的我感觉完全看不出来错误，但是编译器他就是一直报错，啊，我是辣鸡！！！说以为了保证严谨性就完完全全拿了网上一片大大的文章 源代码地址 请摁我！ 一：队列的数组实现【来了来了模板他来了】 我们用 first 和 last 存储队列首元素和尾元素的下标。 *当队列为空时，习惯上设置 first 和 last 的值为-1。当数据入队时, 必须先++相应的下标，然后再存入数据。 *判断队列是否为空：这时只需要看 first 就可以，如果 first == -1 ， 队列即为空。 *判断队列是否已满：队列满队，有两种情况： 1.当队列首次按顺序存满数据时，它的 first 等于0，指向storge数组第一个元素位置storge[0]，而它的last 等于size-1，指向storge数组最后一个元素storge[size-1]，此时队列已满。 2.另外一种情况就是，但我们首次队列满时，将一些元素出队，由于队列是FIFO结构，从头部开始出队，这样在队列元素未全部出队的情况下，first 指向后移。当我们再次将一些数据入队时，last 从storge[size-1] 再次回到 storge[0]，然后按照队列顺序入队，当last = first -1 时，队列再次满队。 *入队操作： 1.首先入队操作首先判断队列是否已满，队列已满则不入队。 2.其次，我们要注意到特殊情况，当队列由空队开始存入第一个数据时，以及last 等于 size-1 时，我们下一个数据入队会被存储在storge[0]的位置，此时需要令 last = 0，不要忘了如果 first 等于-1，同时要令 first = 0; 3.其他情况++last，然后入队即可。 *出队操作： 1.首先判断队列是否空，若为空，则不能出队。 2.重点：当 first等于last 时，说明队列中只有一个元素，此时出队后队列为空，切记将 first ，last值 赋为-1，表示队列空。 3.特殊情况：当 first 等于size-1 时，它处于storge数组尾部，事实上由于它是队列此状态下的首元素，队列的第二个元素是storge数组storge[0]，所以此时进行出队操作后，须将 first 的值设置为0。 4.其他情况 直接出队，++first即可。 队列数组实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#ifndef _ARRAY_QUEUE_H#define _ARRAY_QUEUE_H#include &lt;iostream&gt;using namespace std;template&lt;typename T, int size = 0&gt;class Queue&#123;public: Queue(); bool is_empty()const; bool is_full()const; void enqueue(const T&amp;); T dequeue(); void traverse()const;private: T storge[size]; int first; int last;&#125;;template&lt;typename T, int size&gt;Queue&lt;T, size&gt;::Queue()&#123; first = last = -1;&#125;template&lt;typename T, int size&gt;bool Queue&lt;T, size&gt;::is_empty()const&#123; return first == -1;&#125;template&lt;typename T, int size&gt;bool Queue&lt;T, size&gt;::is_full()const&#123; return first == 0 &amp;&amp; last == size - 1 || last == first - 1;&#125;template&lt;typename T, int size&gt;void Queue&lt;T, size&gt;::enqueue(const T&amp; elem)&#123; if(!is_full())&#123; if(last == -1 || last == size -1)&#123; storge[0] = elem; last = 0; if(first == -1) first = 0; &#125; else storge[++last] = elem; &#125; else&#123; cout &lt;&lt; &quot;Queue full.&quot; &lt;&lt; endl; exit(EXIT_FAILURE); &#125;&#125;template&lt;typename T, int size&gt;T Queue&lt;T, size&gt;::dequeue()&#123; if(is_empty())&#123; cout &lt;&lt; &quot;Queue empty.&quot; &lt;&lt; endl; exit(EXIT_FAILURE); &#125; T tmp; tmp = storge[first]; if(first == last) last = first = -1; else if(first == size - 1) first = 0; else ++first; return tmp;&#125;template&lt;typename T, int size&gt;void Queue&lt;T, size&gt;::traverse()const&#123; for(auto i=first; i&lt;=last; ++i) cout &lt;&lt; storge[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;#endif 下面是测试程序实测完全OK 123456789101112131415161718192021#include &quot;array_queue.h&quot; int main()&#123; Queue&lt;int, 3&gt; queue; queue.enqueue(10); queue.enqueue(10);+/- queue.enqueue(10); cout &lt;&lt; queue.is_full() &lt;&lt;endl; queue.traverse(); queue.dequeue(); queue.dequeue(); queue.dequeue(); queue.is_empty(); queue.traverse();&#125; 而c版的实现是这样的哒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define OK 1#define ERROR 0#define OVERFLOW -2using namespace std;typedef int Status;//===============循环队列=====================#define MAXQSIZE 6 //最大队列长度typedef int QElemType;typedef struct &#123; QElemType *base; //初始化的动态分配存储分配空间 int front; //头指针，若队列不空，指向队头元素 int rear; //尾指针，若队列不空，指向队尾元素的下一个位置&#125;SqQueue;//================队列初始化==========Status InitQueue(SqQueue *Q) &#123; //构造一个空队列Q Q-&gt;base = new QElemType[MAXQSIZE]; if (!Q-&gt;base) exit(OVERFLOW);//存储分配失败 Q-&gt;front = Q-&gt;rear = 0; return OK;&#125;//================入队================================Status EnQueue(SqQueue *Q,QElemType e) &#123; //插入元素e为Q的新的队尾元素 if ((Q-&gt;rear + 1) % MAXQSIZE == Q-&gt;front)return ERROR;//队列满 Q-&gt;base[Q-&gt;rear] = e; Q-&gt;rear = (Q-&gt;rear + 1) % MAXQSIZE;//重新设置队尾指针 return OK;&#125;//===============出队=================================Status DeQueue(SqQueue *Q, QElemType *e) &#123; //若队列不空，则删除Q的对头元素，用e返回其值 if (Q-&gt;front == Q-&gt;rear)return ERROR;//队空 *e = Q-&gt;base[Q-&gt;front]; Q-&gt;front = (Q-&gt;front + 1) % MAXQSIZE; return OK;&#125;int main() &#123; SqQueue Q; QElemType e; int i = 5, j = 5; InitQueue(&amp;Q); for (i; i &gt; 0; i--) &#123; EnQueue(&amp;Q, i); printf(&quot;入队元素为%d\\n&quot;, i); &#125; for (j; j &gt; 0; j--) &#123; DeQueue(&amp;Q, &amp;e); printf(&quot;出队元素为%d\\n&quot;, e); &#125; system(&quot;pause&quot;); return 0;&#125; 链式队列 最简单的单链表只支持首端 O(1) 的操作，在另一端操作需要 O(n) 时间。不适合作为队列的实现基础。 考虑带表尾指针的单链表，它支持 O(1) 时间的尾端插入操作；再加上表首端的高效访问和删除，基于单链表实现队列就很容易。 辣鸡本鸡 依然是大大的 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#ifndef _LIST_QUEUE_H#define _LIST_QUEUE_H #include &lt;list&gt;#include &lt;iostream&gt;using namespace::std; template&lt;class T&gt;class Queue&#123;public: Queue() = default; bool is_empty()const; T&amp; front(); T dequeue(); void enqueue(const T&amp;); size_t size()const; void clear();private: list&lt;T&gt; lst;&#125;; template&lt;class T&gt;bool Queue&lt;T&gt;::is_empty()const&#123; return lst.is_empty();&#125; template&lt;typename T&gt;T&amp; Queue&lt;T&gt;::front()&#123; return lst.front();&#125; template&lt;typename T&gt;T Queue&lt;T&gt;::dequeue()&#123; if(!lst.size())&#123; cout &lt;&lt; &quot;Queue empty.&quot; &lt;&lt; endl; exit(EXIT_FAILURE); &#125; T tmp = lst.front(); lst.pop_front(); return tmp;&#125; template&lt;typename T&gt;void Queue&lt;T&gt;::enqueue(const T&amp; elem)&#123; lst.push_back(elem);&#125; template&lt;typename T&gt;void Queue&lt;T&gt;::clear()&#123; lst.clear();&#125; template&lt;typename T&gt;size_t Queue&lt;T&gt;::size()const&#123; return lst.size();&#125; #endif 这里说明一下。链表的实现采用了标准模板库中的list 那再来说两种队列吧 阻塞队列 阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。 注：可以用阻塞队列实现一个“生产者-消费者模型”。基于阻塞队列，可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。 并发队列 在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题。 要实现一个线程安全的队列就需要并发队列。 最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。 优先队列 啥玩意是优先队列 啊，小朋友，你是否有很多问题，在很多情况下，简单的队列结构是远远不够的，我们需要更复杂的方法来应付这些复杂的场景。加入是一个残疾人去银行排队，职员应该首先给他服务而不是排在他前面的那些人。公路收费亭也应该优先于警车和消防车优先通过。说以休闲队列的关键在于，如何更加快速高效的进行出队列和如对列的操作。元素会随机到达队列，说以并不能保证排在前面的元素先出列排在后面的元素后出列。在不同的引用场景下我们可以采用不同的优先规则。这里主要说明标准模板库中的优先对列。 priority_queue容器默认vector容器x实现 deque容器也是可以的 list是不行哒 STL优先队列的使用 定义 1priority_queue&lt;Type,Container=vector&lt;Type&gt;,cmp=greater&lt;Type&gt;&gt;que; 其中，第一个参数为数据类型，第二个参数为容器（默认为vector），第三个参数为比较函数（默认大值优先）。 比较函数的写法 使用C++自带的库函数 自定义优先级1 自定义优先级2 自定义优先级3 方法一：使用C++自带的库函数 首先在头文件中引用include库函数 1#include functional 中提供了如下的基于模板的比较函数对象。 equal_to: 等于 not_equal_to: 不等于 greater: 大于 greater_equal: 大于等于 less: 小于 less_equal: 小于等于 创建方法：priority_queue,less&gt;que; 方法二：自定义优先级1，队列元素为数值型 12345678910struct cmp1&#123; bool operator()(int &amp;a,int &amp;b)&#123; return a&lt;b;//最大值优先 &#125;&#125;;struct cmp&#123; bool operator()(int &amp;a,int &amp;b)&#123; return a&gt;b;//最小值优先 &#125;&#125;; 创建方法：priority_queue,cmp1&gt;que; 方法三：自定义优先级2，队列元素为结构体 123456789101112struct node1&#123; int x,y; bool operator &lt; (const node1 &amp;a) const &#123;//只能重载&lt; retrun x&lt;a.x;//最大值优先 &#125;&#125;;struct node2&#123; int x,y; bool operator &lt; (const node2 &amp;a) const &#123; retrun x&gt;a.x;//最小值优先 &#125;&#125;; 创建方法：priority_queueque; 方法四：自定义优先级3，队列元素为结构体 123456789struct node&#123; int x,y;&#125;；bool operator &lt; (const node &amp;a,const node &amp;b)&#123; return a.x&lt;b.x;按成员x最大值优先&#125;/*bool operator &lt; (const node &amp;a,const node &amp;b)&#123;//由于都是重载&lt;,所以两种比较形式只能同时存在一种 return a.y&gt;b.y;按成员y最小值优先&#125;*/ 创建方法：priority_queueque; 当然实际中俺就使过第一种嘻嘻嘻 那那那这里就来具体实现一下标准模板库中的优先对列 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;int main()&#123; priority_queue&lt;int&gt;q1; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q2; q1.push(1);q1.push(2);q1.push(3); q2.push(3);q2.push(2);q2.push(1); int a[]=&#123;1,2,6,4,7,8,9,3,5&#125;; priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;q3(a,a+9); while (!q1.empty()) &#123; cout&lt;&lt;q1.top()&lt;&lt;&quot; &quot;; q1.pop(); &#125; while (!q2.empty()) &#123; cout&lt;&lt;q2.top()&lt;&lt;&quot; &quot;; q2.pop(); &#125; while (!q3.empty()) &#123; cout&lt;&lt;q3.top(); q3.pop(); &#125; system(&quot;pause&quot;); return 0;&#125; 你以为完了吗还有呐 双端队列 先说方法STL提供的方法贼多 构造： deque c 创建一个空的deque deque c1(c2) 复制一个deque。 deque c(n) 创建一个deque，含有n个数据，数据均已缺省构造产生。 deque c(n, elem) 创建一个含有n个elem拷贝的deque deque c(beg,end) 创建一个以[beg;end)区间的deque c.~deque() 销毁所有数据，释放内存 方法： c.assign(beg,end) 将[beg; end)区间中的数据赋值给c。 c.assign(n,elem) 将n个elem的拷贝赋值给c。 c. at(idx) 传回索引idx所指的数据，如果idx越界，抛出out_of_range。 c.back() 传回最后一个数据，不检查这个数据是否存在。 c.begin() 传回迭代器中的第一个数据。 c.clear() 移除容器中所有数据。 c.empty() 判断容器是否为空。 c.end() 指向迭代器中的最后一个数据地址。 c.erase(pos) 删除pos位置的数据，传回下一个数据的位置。 c.erase(beg,end) 删除[beg,end)区间的数据，传回下一个数据的位置。 c.front() 传回第一个数据。 get_allocator 使用构造函数返回一个拷贝。 c.insert(pos,elem) 在pos位置插入一个elem拷贝，传回新数据位置 c.insert(pos,n,elem) 在pos位置插入&gt;n个elem数据。无返回值 c.insert(pos,beg,end) 在pos位置插入在[beg,end)区间的数据。无返回值 c.max_size() 返回容器中最大数据的数量。 c.pop_back() 删除最后一个数据。 c.pop_front() 删除头部数据。 c.push_back(elem) 在尾部加入一个数据。 c.push_front(elem) 在头部插入一个数据。 c.rbegin() 传回一个逆向队列的第一个数据。 c.rend() 传回一个逆向队列的最后一个数据的下一个位置。 c.resize(num) 重新指定队列的长度。 c.size() 返回容器中实际数据的个数。 我决对不是在水博客你们相信我啊！！！！！！ 标准模板库中的双端队列[double-ended queue]是允许在两端访问的线性表，因此双端队列可以用双向链表实现。在STL中的容器list已经添加了双向链表，在STL在双端队列中添加了很多额外的功能，可以随机访问双端队列的``任意位置`。如同 数组一样。不说了直接开始水一段代码！【雾】胜利的法则已经确定！！ 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;deque&gt;using namespace std;int main()&#123; deque&lt;int&gt;q1; q1.push_front(1); q1.push_front(2); q1.push_back(3); q1.push_back(4);//现在序列应该是2134; deque&lt;int&gt;q2(q1.begin()+1,q1.begin()-1);//13 q1[1]=5;//现在是2534,我说过了完全可以当数组使 q1.erase(q1.begin());//534 q1.insert(q1.end()-1,2,6);//53664 sort(q1.begin(),q1.end());//34566 deque&lt;int&gt;q3; q3.resize(q1.size()+q2.size());//q3=&#123;0,0,0,0,0,0,0&#125; merge(q1.begin(),q1.end(),q2.begin(),q2.end(),q3.begin());//1334566 system(&quot;pause&quot;); return 0;&#125; 虽然有点突然但大概就那么多吧 。好了大概就那么多吧，emmmmm我想想还有什么要说的吗emmmmmm估计没了，在写下去水博客就实锤了！！！！还有我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客我没有水博客 你们相信我啊！！！！","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"},{"name":"算法","slug":"算法","permalink":"https://blog.youmingsama.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"碎碎念1","slug":"碎碎念/碎碎念one","date":"2020-03-08T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/c19d3793/","link":"","permalink":"https://blog.youmingsama.cn/posts/c19d3793/","excerpt":"","text":"碎碎念1 ​ 有时候我的个人 情绪算是蛮难控制的，但是我却隐藏的很好。我明白有些事情只是徒增烦恼，但是人就是奇怪的生物，总是喜欢在一些毫无意义的事情上做无谓的挣扎结果也许必然也是毫无意义的吧。时常陷入奇怪的情绪，我不认为这些情绪是消极的，但显然也不积极。年纪大了【雾】人是思想就像芦苇越长越深。有的时候因为无所谓的琐事陷入烦恼，有的时候也因为一些小事而眉飞色舞。有的时候为了掩饰自己的迷茫，必须坚持下去。嗯！！！我已经长大了，我这样说着这样坚持着，殊不知在很多时候我依旧想当个孩子。可是我也明白我早就不是那个无忧无虑的孩子了。在没有变化的日子里我开始烦恼，生气，不知所措。若什么都做不到，就伪装自己吧，假装没事一样，可当我再次回头，已经没有一丝痕迹留下，已经找不到来时的路。只能摸索着继续向前。这是我所期望的吗，恐怕连我都不清楚。但是除此之外已经没有其他选择了。当逐渐长大并且成熟 我唯一能做的就是告诉自己：保持自我，别逃避。【以上纯属胡说八道！！！！！！！】","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://blog.youmingsama.cn/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://blog.youmingsama.cn/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"不知道在讲啥","slug":"不知道在讲啥","permalink":"https://blog.youmingsama.cn/tags/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%9C%A8%E8%AE%B2%E5%95%A5/"}]},{"title":"碎碎念2","slug":"碎碎念/碎碎念two","date":"2020-03-08T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/58946629/","link":"","permalink":"https://blog.youmingsama.cn/posts/58946629/","excerpt":"","text":"碎碎念2 现在的时间是22：12了，现在的时间是22点多了 每到这个点都感觉有点疲惫 虽然有些累 但是却完完全全没有获得应有的满足感 反而有些焦躁的情绪 很多时候努力很回报完完全全是不对的等的 回报这种东西甚至很多时候都显得那么不真实 到头来赤裸裸的现实大概可能会狠狠嘲笑这种家伙 看清楚了吗，这种极度扭曲不平衡的东西就是你唯一的选择 是的 人一旦饿了就会不停的抱怨这种毫无意义的狗屁废话 因为肚子将不满情绪传给大脑了 低效率的学习 和循环往复的不停踩坑真的有些累了 很多时候都在怀疑自己到底在什么，我也明白很多事情急不来但是我可能是真的饿了才会在这思考这种白痴问题吧【滑稽】","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://blog.youmingsama.cn/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://blog.youmingsama.cn/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"不知道在讲啥","slug":"不知道在讲啥","permalink":"https://blog.youmingsama.cn/tags/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%9C%A8%E8%AE%B2%E5%95%A5/"}]},{"title":"栈学不会咋办嘛","slug":"bug的炼金工坊/栈学不会咋办嘛","date":"2020-03-06T22:12:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/834bc38f/","link":"","permalink":"https://blog.youmingsama.cn/posts/834bc38f/","excerpt":"","text":"栈学不会咋办嘛 写篇博客之前我已经鸽了好久，因为只几天一直在折腾github和一些插件，正规的学习也鸽了好久，今天又温习了一下链表感觉也有好多坑要填，暂时就先不填了，感觉需要填好多，所以暂时就先鸽了吧。这次写博客我老老实实的加上了date标签，因为昨天晚上用github action自动部署的时候之前的更新记录全给我推平了，所以这篇博客以前的更新时间全是昨天晚上。还有想要吐槽的地方是用ssh验证的时候一直都部署失败，折腾了几个小时耐心到达极点的情况下果断选择了token。token大法好。还有之前为了破解腾讯的防盗链也花了不少时间。这真是一个非常折磨人的过程。腾讯抠到连蹭个外链都不行了吗。 什么是栈 栈是一种线性数据结构,存储以及查找数据时只能访问栈的一端。形象点来说栈类似于自助餐厅中的一叠盘子，新盘子呢在最上面，去的时候也是从上面取。最后放上去的盘子是最先被取走的盘子，因此栈被称为后进先出(LIFO,last in/first out)结构。栈必须有一个盘子的时候才能取出盘子，只有空间还够的时候（比如说盘子我还能加，不要停下来啊），才能加上一个盘子。因此`可以改变栈的状态和检测栈的状态来操作定义栈，这些操作包括： clean()-------清空栈 isEmpty()------判断栈是否为空 push(el)------将le元素放到栈的顶部 pop()-------弹出栈顶元素 topEI-------获取栈顶部元素，但不删除该元素 插入 删除 这些都是比较简单的实现，对于栈来说可操作的地方只有栈顶，当然栈的应用比较常见的一个就是程序中匹配分隔符，当然我们常用的浏览器的前进和后退也是用栈实现的。 关于括号匹配 很久之前写过一篇，容许我献上我拙劣的源代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt; bits/stdc++.h&gt;using namespace std;string str;int sum=0;int main(int argc, char const *argv[])&#123; cin&gt;&gt;str; int len=str.size(); stack &lt;char&gt; ss; char ch; for (int i = 0; i &lt;len ; ++i) &#123; ch=str[i]; if (ch==&#x27;(&#x27;) &#123; sum++; ss.push(ch); &#125;else&#123; if (ch==&#x27;)&#x27;) &#123; if (ss.empty()) &#123; cout&lt;&lt;&quot;NO&quot;; return 0; &#125; ss.pop(); &#125; &#125; &#125; if (ss.empty()&amp;&amp;sum!=0) &#123; cout&lt;&lt;&quot;YES&quot;; &#125;else cout&lt;&lt;&quot;NO&quot;; return 0;&#125; 总体来看实现还是非常简单的 那么现在我们来看看具体的实现是什么样子的 栈既可以用数组实现，也可以用链表来实现。用数组实现的栈，叫作顺序栈，用链表实现的栈，叫作链栈。这里我们用py实现一下，ps:py半吊子出家的某人 示例：顺序栈 123456789101112131415161718192021222324252627282930313233class Stack(): def __init__(self,size): &quot;&quot;&quot;初始化&quot;&quot;&quot; self.size = size self.num = 0 self.stack = [] def getSize(self): &quot;&quot;&quot;获取栈的长度&quot;&quot;&quot; return self.num def print_all(self): &quot;&quot;&quot;输出栈元素&quot;&quot;&quot; for s in self.stack: print s def append_stack(self,value): &quot;&quot;&quot;入栈&quot;&quot;&quot; if self.num &gt;= self.size: print(&quot;the stack is full&quot;) return else: self.stack.append(value) self.num += 1 def pop_stack(self): &quot;&quot;&quot; 出栈&quot;&quot;&quot; if self.num is None: print(&quot;the stack is empty&quot;) return else: self.stack.remove(self.stack[-1]) 复杂度分析 空间复杂度 无论是顺序栈还是链栈，存储数据只需要一个大小为n的数组。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度为O(1)。 注：存储数据需要一个大小为n的数组，并不是指空间复杂度就为O(n)。因为，这 n 个空间是必须的，无法省掉。 我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要的额外的存储空间。 时间复杂度 不管顺序栈还是链栈，入栈、出栈只涉及栈顶个别数据的操作，所以复杂度为O(1)。 支持动态扩容的顺序栈的入栈、出栈时间复杂度分析 对于出栈操作来说，不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。 也就是说，对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。而平均时间复杂度，由摊还分析法分析可知为 O(1)。 啊突然想起来栈还有一个应用 如果两个数非常非常大，甚至超过了long long，或者是超级超级大的数【雾】。我们可以用高精度算法或者你熟悉java的BigInteger。那么问题来了，高精度好难，java完全不熟悉咋办。没毛病老铁，高精度俺也不会写。不熟悉java？咱还有解！！！！如果说整型变量完全放不下。我们可以用栈来解决 把非常大的变量看成一串数字 分别放到两个栈中 然后重栈中弹出数，进行加法操作 解决 给出伪代码 12345678910addingLargeNumber（）读第一个数字，并将这个数对应的数存放到一个栈中读第二个数字，并将这个数对应的数存放到另一个栈中Carry=0;while(至少一个栈不为空) 从每个非空的栈中弹出一个数，并将这个数字与Carry相加 讲个位数的结果放入栈中; 将进位放进Carry中;如果进位不为0；将其放入结果栈中;从结果栈中弹出结果并显示; 私下画画流程图就很容易懂了 栈的内容大概就那摩一点点【雾】。具体代码实现就容许我先鸽了吧！！！嗯！就酱。","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"}]},{"title":"指针学不会咋办","slug":"bug的炼金工坊/指针","date":"2020-03-05T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/a23bcc6c/","link":"","permalink":"https://blog.youmingsama.cn/posts/a23bcc6c/","excerpt":"","text":"指针 今天想复习指针并不是突然的新鞋来潮，主要是TM的链表太难，完全一脸懵逼的状态，搞的我只能被迫偷偷学一下指针啊，我太难了，指针真的对我来说就是降智打击！！！！ 指针学不会还学啥玩意c语言and c++啊 - - -夹击妹抖 数据、指令和内存 在冯诺依曼体系中，程序的数据和指令，是存放在同一空间中的。在 Linux 中，它们存放在进程的虚拟内存空间中.因此，对于进程来说，数据和指令其实没有本质的差别；其区别仅在于如何理解和使用虚存空间中的内容——如果读取虚存空间某个位置的值来使用，这块内容就是数据，如果执行虚存空间某个位置的代码，这块内容就是指令。决定如何理解和使用虚存空间中的内容的因素，是类型。具体到 C 和 C++ 语言来说，对应数据的那部分内存，当中存储的自然就是数据；对应函数的那部分内存，当中存储的就是指令。 因此，对于虚存空间中的内容来说，有两个关键要素： 它在哪里（内存地址是多少）； 它具有哪些属性、能做哪些事情（它的类型是什么）。 所以这一点来说指针有两种属性内容和位置 指针是对内存区域的抽象 C 和 C++ 中的指针，是一种特殊的复合类型。指针变量中存放着目标对象的内存地址，而与指针相复合的类型，则说明了相应内存区域中的内容具有哪些属性，以及能做什么事情。也就是说，在内存空间某块区域中的内容，原本可以是不可解读的；但是，如果有一个描述这块内存区域的指针存在，我们就能找到它（地址的作用），并且合理地使用它（类型的作用）。因此，我们说：指针是对内存区域的抽象。这样解释我感觉应该不抽象了。 定义和使用指针 指针的定义 在 C 和 C++ 中定义指针变量是很简单的，和定义普通的变量基本是一样的。所有的区别，仅在于我们需要在变量名称前使用解引用符号 * 来标记这是一个指针。 12int *ip1, *ip2; // ip1 和 ip2 都是指向 int 类型变量的指针变量double d, *dp; // d 是 double 类型变量，dp 是指向 double 类型变量的指针变量 在上述定义中，我们看到，ip1, ip2, dp 是三个指针——因为在它们之前用 * 号标记处他们是指针；没错这样就变成了指针！！而 d 是一个普通的 double 类型变量。同时，我们注意到，ip1 和 ip2 在定义之时，就确定了他们是指向 int 类型的变量。这意味着，被 ip1 和 ip2 指向的内存，在使用 ip1 和 ip2 进行访问的时候，将被当做是 int 类型的对象来对待。同理，dp 指向的内存，在使用 dp 进行访问的时候，将被当做是 double 类型的对象来对待。 所以是确定是什么类型的指针非常重要[括弧] 回顾一下，我们在几十秒前说道到，内存空间中的内容有两个关键要素：地址和类型。在上述定义过程中，我们通过类型与解引用符号 * 相结合，已经确定了类型。如果要正确使用指针，我们还应该让指针记录一个地址。【再次括弧】 获取对象的地址 上面说到，我们应该在定义指针之后，记录一个地址。在 C 和 C++ 中，我们需要使用取地址符号 &amp; 来获取对象的地址。 1int val = 42;int *p = &amp;val; // &amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里 （绝大多数情况下，当然那剩下的绝小部分就是故意而为之了）指针的类型和对象的类型需要严格匹配。例如，你不能用一个指向 int 类型的指针变量，保存一个 double 类型的对象的地址。应该不会有人犯这样的错误吧 1234double dval = 0.0;double *pd1 = &amp;dval; // 正确：pd1 保存 double 类型变量 dval 的地址double *pd2 = pd1; // 正确：pd1 是 double 类型的指针，可以赋值初始化同样类型的 pd2int *pi1 = &amp;dval; // 错误：不能用指向 int 类型变量的指针保存 double 类型变量的地址int *pi2 = pd1; // 错误：pd1 是 double 类型的指针，不能将其赋值给 int 类型的指针 访问指针指向的对象 指针 p 记录了变量 val 的地址。因此，我们可以通过解引用指针 p 来访问变量 val。 123456int val = 42;int *p = &amp;val; // &amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里cout &lt;&lt; *p &lt;&lt; endl; // 通过指针 p 访问变量 val，输出 val 的值：42*p = 360; // 通过指针 p 改变变量 val 的值，out &lt;&lt; *p &lt;&lt; endl; // 通过指针 p 访问变量 val，输出 val 的值：360cout &lt;&lt; val &lt;&lt; endl; // 输出 val 的值：360 所以说指针烦就烦在太戏了，很容易把人绕进去，如果你忘了之前指针访问过val；那这里你就绝对要出错了耶！ 空指针和空类型的指针 空指针是不指向任何对象的指针，在实际编程中，通常使用空指针作为指针变量有效性的判断标准。 C 语言和老版本 C++ 的空指针字面值是 NULL，它定义在 stdlib 当中；新版本(也只是c11而已)的 C 使用 nullptr 作为空指针字面值。话说我还一直在使用NULL,是的信息落后不爱学习的老爷爷昨天晚上还在用。C++ 还支持用字面值常量 0 初始化指针变量，被这样初始化的指针变量会是一个空指针。（这个我几乎都不怎么用） 123int *p1 = NULL; // C 风格的空指针初始化int *p2 = nullptr; // C++ 风格的空指针初始化int *p3 = 0; // 使用字面值常量 0 初始化空指针 注意nullptr和NULL以及0在作为条件判断时值都为false，它们两两之间进行等于（==）判断时值为true。 空类型的指针，指的是形如 void *pv 的指针。这是一类特殊的指针；这里的空类型，不是说没有类型，而是说空类型的指针，可以用于存储任意类型对象的地址。 1234567double pi = 3.14;void *pv = &amp;pi; // 使用 void * 存放了一个 double 类型对象的地址double *pd = &amp;pi;pd = pv; // 错误：不能将空类型的指针赋值给其他类型的指针pv = pd; // 正确：空类型的指针可以接受任意类型的指针赋值pd = (double *)pv; // 正确：C 风格的强制类型转换pd = reinterpret_cast&lt;double *&gt;(pv); // 正确：C++ 风格的强制类型转换 让我们回顾一下指针的两个要素：地址和类型。：地址和类型。：地址和类型。：地址和类型。：**地址和类型。**重要的事情说三遍。由于空类型的指针可以接受任意类型对象的地址，所以，当编译器拿到一个空类型的指针的时候，它无法知道应该按照何种方式解释和使用指针中记录地址中的内容。因此，空类型指针能够做的事情非常有限：做指针之间的比较、作为函数的输入或输出、赋值给另外一个空类型指针。 理解指针的定义 再探探探变量声明 在 C 和 C++ 中，变量的声明包括一个基本数据类型（或者类类型），以及一组声明符。定义指针使用的解引用符号 * 是类型修饰符，它是声明符的一部分。因此，在下列语句中，int 是基本数据类型，*p 是声明符，* 是类型修饰符作为声明符的一部分存在。 1int *p; 在同一个变量定义语句中，基本数据类型只能有一个，但是可以有多个形式相同或不同的声明符。这也就是说，同一个语句可以定义出不同类型的变量。 12// pi 是指向 int 型变量的指针；val 是 int 型变量int *pi = nullptr, val = 1024; 就像这样 理解稍微复杂的指针定义 因为指针本身也是变量，所以它当然也是存储在虚存空间里的。因此，我们当然也可以定义一个指向这一指针的指针。比如： 123int val = 1024;int *p = &amp;val;int **pp = &amp;p; **pp这里是不是看不懂看不懂就对啦！！！！！ 我们需要仔细理解一下 pp 的定义。理解这类稍微复杂的定义语句，一个基本的办法就是：从最靠近变量名字的地方开始，一层一层剖析变量的类型。就酱 距离 pp 最近的是一个解引用符 *，这预示着 pp 是一个指针，它指向 int * 类型的变量； 再来看 int *，距离 *pp 最近的，依然是一个解引用符，这意味着 *pp 也是一个指针，它指向 int 类型的变量； 因此 pp 是一个指向指向 int 类型变量的指针的指针。 晕没晕！！！晕没晕！！！晕了就对啦！！你可以反复晕几遍 const 与指针 常量的值在生存期内不允许改变。这一特性经常是有用的：可以定义一个常量，然后在多个地方使用；当认为这个常量的值不合适的时候，修改它的定义，即可在所有使用到它的地方生效（而无需依次手工修改）；此外，还可以防止程序意外修改这个值。定义常量，只需要在基本类型前，加上 const 关键字即可；它是 constant 的缩写，意为常量。 1const double pi = 3.141592653580793; 当 const 与指针牵扯到一起，就有些难搞了。至少有以下几种情况： 1234567891011121314151617int val = 0; // int 型变量const int cnst = 1; // int 型常量int *pi = &amp;val; // pi 本身是变量，通过 pi 访问的也是变量 // 正确：将变量地址赋值给变量的指针 pi = &amp;cnst; // 错误：不允许将常量的地址赋值给变量的指针const int *pci = &amp;cnst; // pci 本身是变量，通过 pci 访问的是常量 (point to const) // 正确：将常量地址赋值给常量的指针pci = &amp;val; // 正确：允许将变量地址赋值给常量的指针int *const cpi = &amp;val; // cpi 本身是常量，通过 cpi 访问的是变量 // 正确：允许将变量地址赋值给变量的指针int fake = 2; // int 型变量cpi = &amp;fake; // 错误：cpi 本身是常量，不能在定义之外赋值const int *const cpci = &amp;val; // cpci 本身是常量，通过 cpci 访问的也是常量 // 正确：允许将变量地址赋值给常量的指针cpci = &amp;fake; // 错误：cpci 本身是常量，不能在定义之外赋值cpci = &amp;cnst; // 错误：cpci 本身是常量，不能在定义之外赋值，哪怕是常量的地址 因为变量可以是常量，而指针本身也可以是常量。因此在变量和指针两个维度，都可以选择是否为常量。这样一来，就像上面代码展示的那样，当 const 与指针牵扯在一起的时候，就有 4 中可能性。为了区分这两个维度，我们引入顶层 const 和底层 const 的概念（具体可参考C++primer）： 顶层 const：指针本身是常量。此时，指针在定义初始化之外，不能被赋值修改。称指针为指针常量。 底层 const：指针指向的变量是常量。此时，不能通过解引用指针的方式，修改变量的值。称指针为常量的指针。 喜闻乐见的指针与数组 数组的名字被当做指针使用 在 C 和 C++ 中，指针与数组有非常紧密的联系。实际上，使用数组的时候，编译器通常都是在操作指针。这里我们从两个角度说明数组名在很多时候被当做是一个指针。 1234567891011int nums[] = &#123;1, 2, 3&#125;;int *p = &amp;(nums[0]);if (p == nums) &#123; printf(&quot;true!\\n&quot;);&#125;size_t i = 0;for (i = 0; i != 3; ++i)&#123; printf(&quot;%d\\n&quot;, p[i]);&#125; 如果你执行这一小段代码，那么，不出意外的话，程序会在终端上打印 true!，以及 nums 中的三个数字。这预示着，指针变量 p 保存的内容（也就是 nums[0] 的地址）和 nums 保存的内容是完全一样哒；同时，编译器以相同的方式去解释 p 和 nums。显然 p 是一个指向 int 型变量的指针，那么 nums 也就是一个指针了。emmmm这样说我觉得很清晰了。对吧！！！ C++11 标准引入了 auto 关键字，它能够在定义变量时，探测初始值的类型，并为新定义的变量设置合适的类型。我们看看 auto 关键字作用于数组名字的时候，会发生什么。 1234int nums[] = &#123;1, 2, 3&#125;;auto what = nums;int val = 42;what = &amp;val; 这份代码在 C++11 标准中，可以顺利通过。这说明 what 的类型，经由 auto 检测，是 int *。 以上，足以说明：当数组名字被当做是一个值来使用的时候，它就相当于是一个指针。 但是！！但是！！也不是全部时候 当然，也不是全部时候，数组名字都被当做是简单的指针。比如，在数组名字被传入 sizeof() 运算符的时候，它会被当做是一个真实的数组来看待。 数组指针可以自增哒 数组的指针，可以像 C++ 中 std::vector 的迭代器那样进行自增操作。这句话不是太严谨，因为，实际上是先有数组的指针，再有 std::vector 的迭代器；迭代器实际上是仿造数组的指针设计的功能。 之前提到，数组的指针，实际上是一个指向数组元素类型的对象的指针。数组的指针进行自增、自减运算，实际是将指针所指的位置，沿着数组向后或者向前移动一个元素。 123456int nums[] = &#123;0,1,2,3,4,5&#125;;size_t len = sizeof(nums) / sizeof(nums[0]);int *iter;int *end = nums + len; // end 是尾后指针for (iter = nums; iter != end; ++iter) &#123; printf(&quot;%d\\n&quot;, *iter);&#125; 像这样的用法，就和 std::vector 的迭代器几乎没有差别了。 数组指针可以进行加减运算 数组的指针还可以进行加减运算。比如，在上述例子中 iter += 2，就是将 iter 指针沿着数组向后移动 2 个元素。这个我觉得大多数人都应该很清楚 两个指针如果指向同一个数组中的元素，那么它们可以做差。做差得到的结果是两个指针之间的距离，这个结果可以是负数（实际类型是 ptrdiff_t）。例如，在上述例子中在循环体末尾处，如果进行 end - iter 计算，则其结果表示当前尚未打印的元素的数量。学到了！！！ 数组下标与指针加减 上面提到，数组指针可以进行加减运算：数组指针与整数的加减，实际是将指针沿着数组进行移动，得到的结果还是一个指针。既然结果是指针，那么就可以解引用，访问数组中的元素。因此有 1234567891011int nums[] = &#123;0,1,2,3,4&#125;;size_t len = sizeof(nums) / sizeof(nums[0]);int *p = nums;size_t i = 0;for (i = 0; i != len; ++i)&#123; if (nums[i] == *(p + i))&#123; printf(&quot;true!\\n&quot;);&#125;&#125; 不出意外的话，估计也没有意外这一小段代码会连续打印五行 true!。这提供了另一种访问数组内元素的方法；而事实上，在使用下标访问数组元素的时候，编译器都会转换成类似 *(nums + i) 的形式。也就是说，通过指针运算和解引用来访问数组元素，其实是更加本质的方式。 函数与指针 函数与指针，基本上是指针相关的话题中，最复杂的一个了。那没办法呢！！！不会就是不会，完全没商量了【雾】？？那咋办啊，我好方啊谁来帮帮我啊！ 让函数返回一个数组的指针 我们知道，函数在返回的过程中，会对返回值进行拷贝。因此，一个无法拷贝的对象，是无法被函数返回的。数组是不能被拷贝的，所以函数无法直接返回数组。为了达到返回数组的目的，我们只能寄希望于让函数返回数组的指针（在 C++ 中还可以返回数组的引用）。 为此，我们需要了解，如何定义一个返回数组指针的函数。 首先，我们看一组数组的定义： 1234int arr[10]; // arr 是一个数组，长度是 10，元素类型是 int 型int *parr[10]; // parr 是一个数组，长度是 10，元素类型是 int *，也就是数组中存的是指针int (*p)[10] = &amp;arr; // p 是一个指针，它指向一个长度是 10 元素类型是 int 型的数组 okk这样一来，就不难构造返回数组的指针的函数定义了。 12345678int *(func(param_list))[10]; // 错误：func 是一个函数，param_list 是它的参数 // 它尝试返回一个长度为 10，元素类型为 int * 的数组 // 而数组是无法返回的int (*func(param_list))[10]; // 正确：func 是一个函数，param_list 是它的参数 // 它返回的是一个指针 // 这个指针指向了一个长度为 10 元素类型是 int 型的数组 于是，我们得到了此类函数定义的一般形式： 1element_type (*func(param_list))[dimension] 写到这迷迷糊糊的这里对于我来说比较吃力，至于我能不能懂这就是个概率事件了 函数的指针 终于水到这了 之前提到，无论是数据（变量）还是指令（函数），都是存放在虚存空间的。因此，既然有变量的指针，那么也一定会有函数的指针。这就是我们这一小节需要讨论的函数指针；这会逐渐引出本文最复杂的话题。【害怕.jpg】 一个函数的类型，取决于它的输入和输出。这也就是说，一个函数的类型，应当包含它的返回值类型和参数列表。比如下面定义的函数，用于比较两个 int 型数据是否相等（这是一个仅用于示例而没有实际用处的函数）： 1bool isEqual(int, int); 对于一个函数来说，如果你能拿到它的定义，就很容易能取得它的类型：只需要去掉函数名字就可以了。因此，定义一个指向该类型的函数指针，并不困难。 123bool isEqual(int, int);bool (*pfunc)(int, int) = &amp;isEqual; // 定义了一个函数指针，指向 isEqualbool (*pfunc)(int, int) = isEqual; // 一个等价定义 在这里，pfunc 就是一个函数指针，它指向一个 bool (int, int) 类型的函数。也就是说，这类函数接收两个 int 型的参数，并返回一个 bool 类型的值。 值得一提的是，当函数名字作为值使用时，它会自动地转换成指针（有点像数组名字，不是吗）。因此，在函数指针的初始化或者复制的过程中，取值运算符是可选的。于是，上述两个定义语句是等价的。另一方面，函数指针作为函数调用使用时，它会自动转换成函数名（有点像数组指针，不是吗）。因此，这种情况下，解引用运算符是可选的。 12345bool isEqual(int, int);bool (*pfunc)(int, int) = isEqual;bool res1 = isEqual(1, 2); // 通过原函数名调用bool res2 = (*pfunc)(1, 2); // 一个等价调用：通过函数指针，解引用调用bool res3 = pfunc(1, 2); // 另一个等价调用：函数指针自动转换成函数名 值得一提的是，不同类型的函数的指针之间，不存在任何的类型转换：你不能期待一个接受两个 int 型参数并返回 bool 值的函数的指针，经过类型转换，就能接受三个 int 型的参数。因此，对于重载的同名函数，他们的函数类型是不一样的，因此函数指针也不能是同一个。 将函数指针作为参数传入另一个函数 在传参的过程中（除了 C++ 的传引用），也是伴随着拷贝的过程。因此，一个对象如果不能拷贝，那么它就不能作为参数传入函数。无疑，函数是不能拷贝的，因此你无法将函数作为参数直接传给另一个函数。但是，指针是可以拷贝的，因此，你可以将函数指针作为参数，传给另一个函数。 12345void addIfEqual(int lhs, int rhs, bool pfunc(int, int)); // addIfEqual 的第三个参数是一个函数定义 // 它会自动地转换成一个函数指针的参数 void addIfEqual(int lhs, int rhs, bool (*pfunc)(int, int)); // 一个等价定义：显式地注明第三个参数是函数指针 于是，你可以这样使用这个函数： 1addIfEqual(1, 1, isEqual); 此时，函数名 isEqual 作为引数被传入，它起到的是「值」的作用。因此，isEqual 被自动地转换成指向该函数的指针。 让函数返回一个函数的指针 同样地，与数组类似，虽然我们无法返回一个函数，但是我们可以返回一个函数指针。我们回到 isEqual 的函数指针的定义上来： 1bool (*pfunc)(int, int) = isEqual; 在这里，pfunc 是一个指针，它指向了一个函数；该函数接收两个 int 型参数，并返回一个 bool 值。因此，仿造之前「返回数组指针的函数的定义形式」，我们不难得出： 1outer_return_type (*func(param_list))(outer_param_list) 这里，func(param_list) 是当前需要定义的函数；outer_return_type 和 outer_param_list 分别是当前定义的函数返回的函数指针对应函数的返回值类型和参数列表。 很难对吧，我也是这样感觉的 别急还没完 登峰造极的 (*(void(*)())0)(); 这恐怕是一个会令所有 C/C++ 程序员战栗不已的函数调用语句。因此，在解释这个语句之前，我愿意先给出它的含义，安抚各位战栗的心灵。它表示：访问内存地址 0，将它作为一个参数列表和返回类型均为空的函数，并执行函数调用。（这是一个特殊场景下的函数调用，不用纠结为什么会调用 0 位置上的函数） 类型定义与 C 风格的类型强制转换符 C 风格的类型强制转换符应该不是个稀罕玩意儿。比如 (double)a 就能将变量 a 强制转换为 double 类型。在这个简单的例子里，我们希望能够找到一些朴素的规律，破解这一登峰造极而又令人战栗的函数调用语句。 同样以 double 类型及相关指针类型为例，我们首先看下面的代码： 1234double a; // 定义了一个 double 型的变量double *b; // 定义了一个 double * 型的变量（double 型的指针）(double) c; // 将变量 c 强制转换为 double 类型(double *) d; // 将变量 d 强制转换为 double * 类型 我们不难发现，类型转换和对应类型的变量定义，有着千丝万缕的联系：首先去掉变量定义语句末尾的分号，然后去掉变量定义语句中的变量名，最后给剩余的部分加上括号——一个 C 风格的类型强制转换符，就得到了。 真相只有一个 我们知道 void(*pfunc)(); 定义了一个函数指针 pfunc，它指向的函数参数列表为空、返回值类型也为空。因此，(void(*)()) 就是一个 C 风格的类型转换符。 因此，(void(*)())0 会将 0 转换成一个函数指针，然后交给 * 解引用，最后传入参数（空的参数列表 ()），执行函数调用。 在 C++ 中，这个函数调用应该写作 1(*reinterpret_cast&lt;void(*)()&gt;(0))(); 听说这个写法，相较 C 风格的类型强制转换符，要清晰明朗得多。因此，请不要再吐槽 C++ 风格的强制转换是「语法盐」了。[明明是语法炸弹] 好难啊好难 虽然很难，但是没办法游戏难度是固定的，指针这块对于一些基础不到位的人士来说【比如我】是世纪性难题，就好比你刚刚熟悉基础操作，上来就直接勇闯魔王窟了。还是需要大量的练习和更加深刻的理解。 哎，还是应了著名人士xxx的那句话 speak is simple,give me your code. 所以说我家飞鸟她不香吗？？？？？？还写啥子代码哟 我好了！！！！","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"},{"name":"算法","slug":"算法","permalink":"https://blog.youmingsama.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法复杂度分析","slug":"bug的炼金工坊/算法复杂度分析","date":"2020-03-05T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/f3215fef/","link":"","permalink":"https://blog.youmingsama.cn/posts/f3215fef/","excerpt":"","text":"算法复杂度分析 之前写过一篇文章“不要陷入技术的魔咒”，然而最近又迷上了写拓展，我TM！！！管不住自己，之前我哥推荐了很好的git管理工具，很多东西都用那个托管了，真的很少在写博客了，直话直说我c++这还是学的非常差的，当然后面也没有好好学过，自从开始写一些脚本开始，我更加意识到了自己的软肋，虽然我浑身都是软肋，陈sir，每次气的每次都说我该回炉重造。的确我非常有必要回炉重造了，客观来看我底子的确是弱得很，以后尽量希望明确学习方向，不在对一些应用场景少、难以产生效益、无法应用到实际项目、瞎折腾的技术进行钻研。重最简单的开始学习吧，之前，这个博客是我建的第一个博客，之前也想换换托管方式，打算在阿里云上托管的，但转念一想。又觉得不是很有必要，之前也试过阿里云oss。不过我感觉git+github pages+hexo这个已经完全够用了。也懒得再折腾。 其次c++已经鸽了有大半年了，所以有必要重hello world，重新开始学的必要，我感觉， 算法复杂度以及渐进复杂度 一个问题往往可以以效率不同的算法来解决，当然在数据较少的时候，各种算法之间的差异也许微不足道，但当数据量成倍增加时，你就会发现不同算法之间的差异非常非常明显，如果你关注LeetCode你会发现不同的算法在占用和时间上会有非常明显的差别，比如一道题，你用双指针可能只需要4ms，其他的算法可能是他的一百多倍。为了比较算法的效率，两个名字很复杂的老外，引入了一种称为计算复杂度的标准来衡量算法。计算复杂度表示一种算法需要付出多大的成本和努力，当然成本在很多不同的地方有自己的衡量标准，我们常说的衡量效率就是时间和空间，当然远远不止这两种，其他，其他我也不知道啊！！！当然时间因数往往比空间因素重要的多，我们往往关注的是数据处理的时间，而不是空间，毕竟现在在技术层面，数据储存完全不是人们担心的地方，而时间和效率往往决定这一个程序的好坏。印度是全世界最大的代码输出国，微软ceo也是印度人，印度人写代码哪管那么多啊，所以是现在硬件的发展完全可以弥补算法层面的不住，当然这只是在某些领域，在一些非常需要算法效率的领域，你，如果，不会写算法还是删库趁早跑路吧，我觉得你进公司面试可能面试官就直接吧你pass了 评估算法效率 算法效率的评估并不能以时间来评估，而是采用某种逻辑关系，用文件和数组的尺度n同时间t之间的关系，我们该如何表示不同的t和n之间的关系呢， 假如t和n之间是线性关系 n2=5n1则必有t2=5t1n2=5n1 则必有t2=5t1 n2=5n1则必有t2=5t1 同样 t1=log2(n)，t2=log2(2n)则t1=t2+1 $$ {log2} 当然通常情况下。，这些n与t之间的关系复杂的多的多。当数据量非常巨大的时候，计算这些函数才变得比较重要，不会实质上改变函数数量级的应该从函数中剔除，emmmmm就相当于数学的极限思想。比如说f（n）=n+10000，在n足够大时我们就没有必要考虑常数项。 ## 大O表示法 这大概是最长用来表示渐进复杂度（评估函数的增长率）的表示方法了，是Paul Bachmann引入的 具体我就不说了详情请看百科 [请点我！！！！](https://baike.baidu.com/item/大O表示法/1851162?fr=aladdin) ## 常见的时间复杂度量级 我们先从常见的时间复杂度量级进行大O的理解： - 常数阶O(1) - 线性阶O(n) - 平方阶O(n²) - 对数阶O(logn) - 线性对数阶O(nlogn) ![](C:\\Users\\Administrator.USER-20181115IF\\Desktop\\b&amp;bo=bwNwAm8DcAIRCT4!&amp;rf=viewer_4) ### O(1) ![](http://m.qpic.cn/psc?/V13PUOHK44wDVX/4pNOqgOvBLvj4yTC9qc55aKetXJx4AS93ajzRKFTHJhI3psuRi3P2h0bUOiDmn2n*47302gYOXxReWb7HbXD0ZHP7hGQ2mWcuMH1UcSxSLw!/b&amp;bo=tgMTArYDEwICCS0!&amp;rf=viewer_4) [^]: 图片转载至掘金 无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1) 123456void swapTwoInts(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125; ### O(n) ![](http://m.qpic.cn/psc?/V13PUOHK44wDVX/4pNOqgOvBLvj4yTC9qc55cUDXjmkugsoYy7opoXUiCvLNRMvYGKmzn6CAQkKpXsRsHKsHMDKh9xhB.2TynbNmTOKZTW.FgHzh7gugVjXLh8!/b&amp;bo=tgMTArYDEwICCS0!&amp;rf=viewer_4) 在下面这段代码，for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此可以用O(n)来表示它的时间复杂度。 12345678int sum ( int n )&#123; int ret = 0; for ( int i = 0 ; i &lt;= n ; i ++)&#123; ret += i; &#125; return ret;&#125; 特别一提的是 c * O(n) 中的 c 可能小于 1 ，比如下面这段代码： 1234567void reverse ( string &amp;s ) &#123; int n = s.size(); for (int i = 0 ; i &lt; n/2 ; i++)&#123; swap ( s[i] , s[n-1-i]); &#125;&#125; ### O(n²) ![](https://user-gold-cdn.xitu.io/2018/12/13/167a509fc3d8fd52?imageslim) 当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。 1234567891011void selectionSort(int arr[],int n)&#123; for(int i = 0; i &lt; n ; i++)&#123; int minIndex = i; for (int j = i + 1; j &lt; n ; j++ ) if (arr[j] &lt; arr[minIndex]) minIndex = j; swap ( arr[i], arr[minIndex]); &#125;&#125; 这里简单的推导一下 - 当 i = 0 时，第二重循环需要运行 (n - 1) 次 - 当 i = 1 时，第二重循环需要运行 (n - 2) 次 - 。。。。。。 不难得到公式： 12345(n - 1) + (n - 2) + (n - 3) + ... + 0= (0 + n - 1) * n / 2= O (n ^2) 当然并不是所有的双重循环都是 O(n²)，比如下面这段输出 30n 次 `youmingsama：）`的代码。 123456void printInformation (int n )&#123; for (int i = 1 ; i &lt;= n ; i++) for (int j = 1 ; j &lt;= 30 ; j ++) cout&lt;&lt; &quot;youmingsama：）&quot;&lt;&lt; endl;&#125; ### O(logn) ![](http://m.qpic.cn/psc?/V13PUOHK44wDVX/4pNOqgOvBLvj4yTC9qc55SAtAYyoKoFH9LThDmv5KBqEilX7kZS5*YENt9eb53UUj1tsZjOiqyATMn2d7fz6GmBNZqXgsYxamz8WIaLU6og!/b&amp;bo=vQMcAr0DHAICGT0!&amp;rf=viewer_4) 1234567891011int binarySearch( int arr[], int n , int target)&#123; int l = 0, r = n - 1; while ( l &lt;= r) &#123; int mid = l + (r - l) / 2; if (arr[mid] == target) return mid; if (arr[mid] &gt; target ) r = mid - 1; else l = mid + 1; &#125; return -1;&#125; 在二分查找法的代码中，通过while循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。 同样的还有下面两段代码也是 O(logn) 级别的时间复杂度。 12345678910111213141516171819 // 整形转成字符串 string intToString ( int num )&#123; string s = &quot;&quot;; // n 经过几次“除以10”的操作后，等于0 while (num )&#123; s += &#x27;0&#x27; + num%10; num /= 10; &#125; reverse(s) return s; &#125;void hello (int n ) &#123; // n 除以几次 2 到 1 for ( int sz = 1; sz &lt; n ; sz += sz) for (int i = 1; i &lt; n; i++) cout&lt;&lt; &quot;youmingsama：）&quot;&lt;&lt; endl;&#125; ### O(nlogn) 将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。 12345678void hello ()&#123; for( m = 1 ; m &lt; n ; m++)&#123; i = 1; while( i &lt; n )&#123; i = i * 2; &#125; &#125;&#125; ## 最好，平均和最坏情况 ### 先举个栗子 分析以下这段代码的时间复杂度 123456789// n 表示数组 array 的长度int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123; if (array[i] == x) pos = i; &#125; return pos;&#125; #### 分析 - 功能：在一个无序数组array中，查找变量x出现的位置 - 时间复杂度：`O(n)`, n表示数组的长度 更为优化的方式 123456789101112// n 表示数组 array 的长度int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123; if (array[i] == x) &#123; pos = i; break; &#125; &#125; return pos;&#125; &gt; 时间复杂度： 不一定是O(n)了，不同情况下这段代码的时间复杂度是不同的。 ### 引入概念 - 最好情况时间复杂度：在最理想情况下，执行代码的时间复杂度 - 最坏情况时间复杂度：在最糟糕情况下，执行代码的时间复杂度 - 平均情况时间复杂度：最好情况和最坏情况都是属于极端情况，发生的概率并不大。需要表示平均情况下的复杂度 ### 如何分析平均情况时间复杂度 以上面的例子为例：查找x在数组中的位置，有`n+1`种情况，在数组`0~n-1`的位置上和不在数组中。 将每种情况下，查找需要遍历的元素个数相加，再除以n+1种情况，就可得到需要遍历的元素个数的平均值 `(1+2+3+...+n+n)/n+1 = n (n+3) /2(n+1)` 省略掉系数、低阶、常量后得到平均时间复杂度为`O(n)` #### 存在问题 在以上的n+1种情况中，未考虑x在每种情况下出现的概率。 现在假设，x在数组中与x不在数组中的概率各为`1/2`； 要查找的x出现在`0~n-1`这n个位置的可能性是相同的，即`1/n`； 那么，要查找的x出现在`0~n-1`中任意位置的概率为 `1/2*1/n = 1/(2n)` 将每种情况发生的概率考虑进去后，平均时间复杂度计算过程变成： 1(1+2+3+...+n+n)*(1/(2n)) 作期望值。因而平均时间复杂度的全称为**加权平均时间复杂度**或**期望时间复杂度**。 &gt; 注：很多时候，我们只使用一个复杂度就可以满足要求。只有同一块代码在不同情况下，时间复杂度有量级的差距，才会使用以上3种复杂度的表示法来区分。 ### 均摊时间复杂度、摊还分析（摊销分析） 举栗子说明： 12345678910111213141516// array 表示一个长度为 n 的数组// 代码中的 array.length 就等于 nint[] array = new int[n];int count = 0;void insert(int val) &#123; if (count == array.length) &#123; int sum = 0; for (int i = 0; i &lt; array.length; ++i) &#123; sum = sum + array[i]; &#125; array[0] = sum; count = 1; &#125; array[count] = val; ++count;&#125; #### 分析 - 功能：实现了往数组中插入数据的功能。 - 具体： 1 . 当数组满了`count == array.length`,就用for循环遍历求和，将求得的和放在数组的第一个位置，并清空数组其余元素；然后再插入新的元素。 2 . 当数组一开始就有空闲，则直接将数据插入数组。 - 复杂度分析： 1 . 最好情况：数组中有空闲，直接将数据插入到`count`的位置，为`O(1)` 2 . 最坏情况：数组没有空闲空间，需要先做一个遍历求和，再作插入。所以复杂度为`O(n)` 3 . 平均时间复杂度：`O(1)` ##### 平均时间复杂度如何得到 总共`n+1`种情况，前`n`中情况每种时间复杂度都为`O(1)`，后一种情况时间复杂度为`O(n)`；`n+1`种情况发生的概率一样，为`1/(n+1)`；根据加权平均计算方法： &gt; 11*1/(n+1) + 1*1/(n+1) + ... + n*1/(n+1) = O(1) #### 摊销时间复杂度（amortized time complexity） 分析发现: 1 . `insert()`函数在**大部分情况**下，时间复杂度都为`O(1)`；**极个别情况**下，复杂度才高，为`O(n)` 2 . `insert()`函数中，`O(1)`时间复杂度的插入和`O(n)`时间复杂度的插入，**出现频率很有规律**。存在前后时序关系，一般一个`O(n)`插入之后，紧跟着`n-1`个`O(1)`的插入操作，循环往复。 ##### 针对这种场景，引入均摊分析法 大致思路：每一次 `O(n)` 的插入操作，都会跟着 `n-1` 次 `O(1)` 的插入操作，所以把耗时多的那次操作均摊到接下来的 `n-1` 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 `O(1)`。 #### 总结 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。 而且，**在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度**。 &gt; 均摊时间复杂度就是一种特殊的平均时间复杂度，没必要花太多精力去区分它们。 ## NP完整性 决定性算法，，，，，，emmmmmmm这个好难，看不太懂，暂时就鸽了吧。就酱 ![](http://m.qpic.cn/psc?/V13PUOHK0NDZXM/4pNOqgOvBLvj4yTC9qc55fBIxyAZSXpIVMg.7WexfLdGNmW.mlaAcPX7syv*IA5cDPQiD.SX5XbpJ4wbz98KbX5FY5Kp7p0ZtX0VTT5LE1E!/b&amp;bo=LAHUACwB1AACCS0!&amp;rf=viewer_4)","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"},{"name":"算法","slug":"算法","permalink":"https://blog.youmingsama.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"链表","slug":"bug的炼金工坊/链表","date":"2020-03-05T00:00:00.000Z","updated":"2023-06-23T07:25:57.098Z","comments":true,"path":"posts/2362a8ea/","link":"","permalink":"https://blog.youmingsama.cn/posts/2362a8ea/","excerpt":"","text":"链表 今天开始学链表了，我觉得学链表前很有必要先看看数组 数组 不得不承认数组的确是日常使用中最常用的手段之一，但是啊，数组的使用是有局限的(1)在编译期就要做到大小，不然是不行哒。2数组中的数据在内存中是以相同的距离隔开的，这就意味着我们要想在数组中插入数据变的非常困难。如果我们偏要插入数据的话则需要去移动改数组的其他数据。这样感觉非常不妙而且让人感觉非常烦躁。 数组定义 一组线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 关键词解释 线性表：每个线性表上的数据最多只有前和后两个方向。 除了数组，链表、队列、栈都是线性表结构，然而线性表有分为顺序表和链表，顺序表可以简单的理解为数组这个概念。 联想到非线性表：数据之间并不是简单的前后关系。 如，二叉树、堆、图等 连续的内存空间和相同类型的数据 正因为有了这两个限制，才使得数组有了随机访问的特性； 也正是因为这两个限制，使得数组的删除、插入操作效率很低。 如何实现根据下标随机访问数组元素？ 计算机会给每个内存单元分配一个地址，再通过地址来访问内存中的数据。 而计算机通过寻址公式来计算元素存储的内存地址： 12//a[i]的地址就是从首地址偏移i*data_type_size的位置a[i] = base_address + i * data_type_size base_address: 内存块的首地址 data_type_size：数中每个元素的大小；根据存储的数据类型而定，如int型，该值为4 为什么数组要从0开始编号，而不是从1开始呢？ 若数组从1开始计数，那么上面的公式就变成 1a[i] = base_address + (i-1) * data_type_size 修改后，每次随机访问数组元素都多了一次减法运算，对于CPU就多了一次减法指令。 两个操作 数组的插入操作 效率低的原因：将某个数据插入到数组中的第i个位置。为了给新来的元素腾出这个位置，需要移动后面的i~n个元素，复杂度为O(n); 改进方法：当数组是无序的，简单的方法就是将原来第i个位置上的元素放到数组最后，然后将新来的元素放到第i个位置。复杂度为O(1); 数组的删除操作 与插入操作类似，若删除第i个位置的元素，需要搬移后面的i~n个元素，才能保证内存的连续性。 复杂度：若删除开头元素，最坏复杂度为O(n)；若删除数组末尾元素，最好复杂度为O(1)；平均复杂度为O(n)。 改进方法：不要求数组中数据的连续性，就可将多次删除操作集中在一起执行。 每次删除元素时，并不真正搬移元素，而是记录下数据已被删除。当数组没有更多空间存储数据时，再执行一次真正的删除操作（做数据元素的搬移工作） 数组的访问越界问题 分析以下一段代码： 123456789int main(int argc, char* argv[])&#123; int i = 0; int arr[3] = &#123;0&#125;; for(; i&lt;=3; i++)&#123; arr[i] = 0; printf(&quot;hello world\\n&quot;); &#125; return 0;&#125; 问题 不是只打印三行“hello world”；而是无限打印 原因 数组大小为3，a[0]，a[1]，a[2]，而我们的代码 for 循环的结束条件错写为了i&lt;=3 而非 i&lt;3，所以当 i=3 时，数组 a[3] 访问越界。 根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。 注：例子中死循环的问题跟编译器分配内存和字节对齐有关。数组3个元素，加上一个变量i。4个整数刚好能满足8字节对齐，所以i的地址恰好跟在a[2]后面，导致死循环。如果数组本身有4个元素，则这里不会出现死循环。因为编译器64位操作系统下，默认会进行8字节对齐，变量i的地址就不会紧跟在数组后面了。 Key 1 . 常会问的一个面试题：数组和链表的区别？ 正确表述：链表适合插入、删除操作，时间复杂度为O(1)；数组适合随机访问数组元素(而不应该说查找)，根据下标随机访问的时间复杂度为O(1)。 明确的点：数组是适合查找，但查找的时间复杂度不为O(1)。即便是排好序的数组，用二分查找，时间复杂度也是O(nlogn)。 2 . 数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。 在这种情况下，一般都会出现莫名其妙的逻辑错误，就像上面举的那个例子，debug的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。 3 . 二维、多维数组如何寻址？ 行优先 12345int a[d1][d2][d3];int *p0 = &amp;a[0][0][0];int *p = &amp;a[i][j][k];int idx = i * (d2*d3) + j * d3 + kASSERT( p0 + idx == p); 但是我们亲爱的链表就不存在这样的问题 链表是节点的集合，节点中储存着数据并可以链接到其他节点，是不是很方便，也就是是通过这种方式我们可以链接到内存中的任何一个位置，不好意思链表真的可以为所欲为；每个节点都存储着链表其他地方的节点，因此我们非常容易的从一个节点到另一个节点，但是最灵活的还是指针，抱歉指针真的真的可以为所欲为 如何用链表实现LRU缓存淘汰算法？ 缓存 缓存定义：一种高效数据读取性能的技术，比如常见的CPU缓存、数据库缓存、浏览器缓存等。缓存在计算机软件、硬件开发中应用都很广。 缓存特点：大小有限，被用满时，需要清理一部分数据，而哪些数据应该被清理哪些应该被保留，由缓存淘汰策略决定。 缓存淘汰策略 常见的缓存淘汰策略有：FIFO（First in,First out）先进先出策略、LFU（Least Frequently Used）最少使用策略、LRU（Least Recently Used）最近最少使用策略。 三种链表 链表通过指针将一组零散的内存块串联在一起。其中内存块叫做链表的结点，记录结点地址的叫做指针。链表的第一个结点叫头结点，最后一个结点叫尾结点。 单项链表 如果链表中只含有指向后继节点的链接这样的就被叫做单链表大概 单链表的“尾结点”，它的指针并不指向下一个结点，而是指向一个空地址NULL 懒得废话直接扔动图，动态图来自visualgo 搜索（ps谷歌拓展截下来的gif图凑合看吧） 插入 删除 （ps）单链表插入和删除操作，复杂度为O(1) 循环链表 一种特殊的单链表，与单链表的区别就在于尾结点，其尾结点指向链表的头结点 相比于单链表，循环链表的优势在于从链尾到链头很方便。著名的约瑟夫问题，就适合这种数据结构。 双向链表 单链表只有一个方向，结点只有一个后继指针next指向后面的节点。双向链表有两个方向，一个后继指针next和一个前驱指针pre。 双向链表在某些情况下的插入、删除操作比单链表更高效。 例如删除操作，从链表中删除一个数据，有两种情况： 删除链表中值等于某个给定值的结点 删除给定指针指向的结点 对于第一种情况，无论单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再将其删除。 尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。 对于第二种情况，已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点。这种情况下单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要 O(1) 的时间复杂度。 以上的情况涉及到一个空间换时间的设计思想：双向链表更费内存，但仍比单链表应用更广泛。 缓存实际上就是利用了空间换时间的设计思想。 如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。 但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。 若内存空间充足，如果更加追求代码的执行速度，就选择空间复杂度相对较高，时间复杂度相对较低的算法和数据结构，例如，缓存技术。 若内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间。 数组与链表对比 时间复杂度 删除、插入：链表O(1)、数组O(n) 随机访问操作：链表O(n)、数组(1) 缓存支持 数组在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。 链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。 原因 CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取要访问的地址，而是读取一个数据块，并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。 这样就实现了比内存访问速度更快的机制，也是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的差异。 对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。 灵活性 数组大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致内存不足（out of memory）。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。 链表本身没有大小的限制，天然地支持动态扩容。 链表实现LRU缓存淘汰策略的思路 维护一个有序单链表，越靠近链表尾部的结点是越早被访问过的。当有新的数据被访问时，从链表头开始顺序遍历链表。----缓存访问的时间复杂度为O(n) 过程： 1 . 当访问的数据存储在缓存的链表中时，遍历得到数据对应的结点，将其从原位置删除，再将其插入到链表表头； 2 . 当访问的数据未出现在缓存的链表中时 1）若缓存有空闲，将该数据直接插入到链表表头。 2）若缓存被占满，则将链表尾部的数据删除，再将新数据插入到链表表头。 优化：使用散列表，记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。 思考 如何用数组实现LRU缓存淘汰策略？ 方式一：首位置保存最新访问数据，末尾位置优先清理 当访问的数据未存在于缓存的数组中时 1）缓存有空闲，将数据插入数组第一个元素位置，数组所有元素需要向后移动1个位置，新数据插入数组第一个元素位置，时间复杂度为O(n)； 2）缓存无空闲，清理数组末尾位置的元素，数组所有元素需要向后移动1个位置，新数据插入数组第一个元素位置，时间复杂度为O(n)； 当访问的数据存在于缓存的数组中时，查找到数据，将其从原位置删除，并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。 方式二：首位置优先清理，末尾位置保存最新访问数据 当访问的数据未存在于缓存的数组中时 1）缓存有空闲，直接将数据添加进数组作为当前最后一个元素，时间复杂度为O(1)； 2）缓存无空闲，清理数组首位置的元素，数组所有元素向前移动1个位置， 将新元素插入数组，时间复杂度为O(n)； 当访问的数据存在于缓存的数组中时，查找到数据，将其从原位置删除，并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。 优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。 如何通过单链表实现“判断某个字符串是否为回文字符串”？ 比如 “123454321” 1 . 前提：字符串以单个字符的形式存储在单链表中。 2 . 遍历链表，判断字符个数是否为奇数，若为偶数，则不是。 3 . 将链表中的字符倒序存储一份在另一个链表中。 4 . 同步遍历2个链表，比较对应的字符是否相等，若相等，则是回文字符串，否则，不是。 大概就那么多吧 讲…讲完了？？？？代码呢 不…不会写啊，是的讲了那么多然而并没有会，代码该不会还是不会 是的没错要用指针那就不会了呢，一点都不会了呢，没商量呢，不会就是不会呢 但是一点点还是可以的 就我会的稍微说一下，是的这就是我全部是知识储备了 理解指针或引用的含义 有些语言有指针概念，比如C语言；有些语言没有指针，取而代之的是引用，比如Java、Python。不管“指针”还是“引用”，都是一个意思，指存储所指对象的内存地址。 指针含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用） 示例： 1p—&gt;next = q; 表示p节点的后继next指针存储了q节点的内存地址 1p—&gt;next = p—&gt;next—&gt;next; 表示p节点的后继next指针存储了p节点的下下个节点的内存地址。 警惕指针丢失和内存泄漏 示例： 单链表的插入，希望在节点a和相邻节点b之间插入节点x，假设当前指针p指向节点a，则造成指针丢失和内存泄漏的代码： 12p-&gt;next = x;x-&gt;next = p-&gt;next 导致将x自身赋值给了x-&gt;next，自己指向自己。 对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。 所以，插入结点时，一定要注意操作的顺序。上面代码的正确写法是：两句代码顺序调换。 同理，删除链表时，也一定要手动释放内存空间，否则，也会出现内存泄漏问题。 Python语言不需手动释放，它的解释器的存储管理系统会自动回收不用的存储。 利用哨兵（头结点）简化实现难度 哨兵含义： 链表中的哨兵节点是解决边界问题的，不参与业务逻辑。如果我们引入哨兵节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有哨兵节点的链表就称为不带头链表。 示例： 不带头结点时： 对于单链表的插入操作 1 . 如果在p节点后插入一个新节点，只需2行代码即可搞定： 12new_node—&gt;next = p—&gt;next;p—&gt;next = new_node; 2 . 如果向空链表中插入一个新结点，则代码就不同： 123if(head == null)&#123; head = new_node;&#125; 对于单链表的删除操作 1 . 如果要删除节点p的后继节点，只需1行代码即可搞定： 1p—&gt;next = p—&gt;next—&gt;next; 2 . 如果删除的是链表的最后一个节点（链表中只剩下这个节点），则代码如下： 123if(head—&gt;next == null)&#123; head = null;&#125; 以上示例可以看出，不带头结点时，单链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点作特殊处理。 带头结点时： 哨兵节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。 这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的实现逻辑。 留意边界条件处理 常用的检查链表代码是否正确的边界条件： 1 . 如果链表为空时，代码是否能正常工作？ 2 . 如果链表只包含一个节点时，代码是否能正常工作？ 3 . 如果链表只包含两个节点时，代码是否能正常工作？ 4 . 代码逻辑在处理头尾节点时是否能正常工作？ 没了","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"},{"name":"算法","slug":"算法","permalink":"https://blog.youmingsama.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"链表写不出来咋整啊","slug":"bug的炼金工坊/链表写不出来咋整啊","date":"2020-03-05T00:00:00.000Z","updated":"2020-03-13T00:00:00.000Z","comments":true,"path":"posts/4f36d243/","link":"","permalink":"https://blog.youmingsama.cn/posts/4f36d243/","excerpt":"","text":"链表写不出来咋整啊 链表已经学了三四天，它不是那种学不会，他就是那种很特别的，你懂吧，单链表：这不还是挺简单的吗，双链表：哦吼有点难度了啊，循环链表：，马嘞个…马马虎虎啊。跳跃链表：…。自组织链表：啥玩意啊？？？稀疏表：老子不学了还不行吗，标准模板库中的链表：对不起大爷，俺错了，饶了俺吧.所以知识不牢固；链表分分钟教你做人 嘛毕竟不能一口吞个坦克，不过想想的确链表挺揪心的。俺们组的大佬人家说了，深刻的理解和令人胆寒的代码量必然带来的不仅仅是质的变化。道理谁都懂但但做到很难！！！！今天打算好好梳理一下。 单链表 这个我之前就已经吧搜索，插入，删除，以及一些常见的概念说的很清楚了大概【？】 ，我看实现单链表的详细清单有3页这就已经很扯淡了，所以这里的只说一些简单的实现。 单链表结构 我们设计一个简单的单链表结构，如下： 1234struct ListNode &#123;int value; struct ListNode *next;&#125;;typedef struct ListNode * list; phead为单链表的头指针，它指向表中的第一个节点，头结点的数据可以不存储然后信息，也可以设计成存储线性表长度等附加信息。 打印单链表 首先，我们可以利用链表打印数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct ListNode &#123; int data; struct ListNode *next; &#125;;typedef struct ListNode * list;ListNode *creat(int n)&#123; int i; ListNode *phead, *p1, *p2; /*phead用来标记链表，p1总是用来指向新分配的内存空间， p2总是指向尾结点，并通过p2来链入新分配的结点*/ int a; phead = NULL; p2 = NULL; for (i = 1; i &lt;= n; i++) &#123; p1 = (ListNode *)malloc(sizeof(ListNode)); /*动态分配内存空间，并数据转换为(struct LNode)类型*/ printf(&quot;请输入链表中的第%d个数：&quot;, i); cin&gt;&gt;a; p1-&gt;data = a; if (phead == NULL)/*指定链表的头指针*/ &#123; phead = p1; p2 = p1; &#125; else &#123; p2-&gt;next = p1; p2 = p1; &#125; p2-&gt;next = NULL;/*尾结点的后继指针为NULL(空)*/ &#125; return phead;/*返回链表的头指针*/&#125;int main()&#123; int n; ListNode *q; printf(&quot;请输入链表的长度：\\n&quot;); cin&gt;&gt;n; q = creat(n);/*链表的头指针(head)来标记整个链表*/ printf(&quot;链表中的数据：\\n&quot;); while (q)/*直到结点q为NULL结束循环*/ &#123; printf(&quot;%d &quot;, q-&gt;data);/*输出结点中的值*/ q = q-&gt;next;/*指向下一个结点*/ &#125; system(&quot;pause&quot;); return 0;&#125; 注释很很很很很清楚了，就不解释了 我这边还有我第一次写的一个demo，和这个意思也是一样的 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;struct Node&#123;int data;struct Node* next;&#125;;Node*creat(int n)&#123; struct Node* head, *p1,*p2; head=(struct Node*)malloc(sizeof(struct Node)); p1=head; for(int i=0;i&lt;n;i++)&#123; p2=(struct Node*)malloc(sizeof(struct Node)); p2-&gt;data=i+1; p1-&gt;next=p2; p1=p2; &#125; p2-&gt;next=nullptr; return head-&gt;next;&#125;int main()&#123; int n; Node *q; printf(&quot;请输入链表的长度：\\n&quot;); cin&gt;&gt;n; q = creat(n); printf(&quot;链表中的数据：\\n&quot;); while (q) &#123; printf(&quot;%d &quot;, q-&gt;data); q = q-&gt;next; &#125; system(&quot;pause&quot;); return 0;&#125; 单链表排序 下面实现稍微复杂的一些的链表操作，比如单链表的排序，单独排序功能实现常见的就有插入排序，冒泡排序，简单排序，快速排序，这里我们简单实现一些插入排序好了。 1234567891011121314151617181920212223242526272829303132333435363738void sort(list linklist)&#123; /*如果链表没有元素，或者只有一个元素就直接返回*/ if((linklist -&gt; next == NULL) || (linklist -&gt; next -&gt; next == NULL)) &#123; return; &#125; ListNode * phead, * p1, * prep1, * p2, * prep2, * temp; phead = linklist; prep1 = phead -&gt; next; p1 = prep1 -&gt; next; //prep1和p1是否需要手动后移 bool flag; while(p1 != NULL) &#123; flag = true; temp = p1; //由于是单向链表，所以只能从头部开始检索 for(prep2 = head, p2 = prep2 -&gt; next; p2 != p1; prep2 = prep2 -&gt; next, p2 = p2 -&gt; next) &#123; //发现第一个较大值 if(p2 -&gt; data &gt; p1 -&gt; data) &#123; p1 = p1 -&gt; next; prep1 -&gt; next = p1; prep2 -&gt; next = temp; temp -&gt; next = p2; flag = false; break; &#125; &#125; //手动后移prep1和p1 if(flag) &#123; prep1 = prep1 -&gt; next; p1 = p1 -&gt; next; &#125; &#125; &#125; 以上的操作都不是很难那我们再试试反转 单链表翻转 123456789101112131415161718192021ListNode reverse(list linklist)//两两节点之间不断交换&#123; ListNode *phead； phead = linklist; /*如果为空直接返回*/ if(phead == NULL || phead-&gt;next == NULL) return phead; //定义俩个辅助指针变量 ListNode pre = NULL; ListNode next = NULL; //开始进行翻转 while(phead != NULL)&#123; //让辅助指针next指向下一个节点，如果是第一次进入就是指向头指针下一跳 next = phead-&gt;next; //让当前节点指向pre phead-&gt;next = pre; //进行调换 pre = phead; //并让头节点指向下一跳 phead = next; &#125; //返回pre就是新生成的头结点 return pre;&#125; emmmmm至于剩下的插入，删除，还有封装等我会了在填坑吧！！！就酱 我回来填坑啦 大概算是首次填坑？？？？？ 大概重新写了一遍又有了新的感悟吧，这算不算填坑啊【苦恼】，有时间废话还不如直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt; stdio.h&gt; #include &lt; stdlib.h&gt; typedef int ElemType; //////////////////////////////////////////// //定义结点类型 typedef struct Node &#123; ElemType data; //单链表中的数据域 struct Node *next; //单链表的指针域 &#125;Node,*LinkedList; //////////////////////////////////////////// //单链表的初始化 LinkedList LinkedListInit() &#123; Node *L; L = new Node; //申请结点空间 if(L == nullptr) //判断是否有足够的内存空间 printf(&quot;申请内存空间失败/n&quot;); L-&gt;next = nullptr; //将next设置为NULL,初始长度为0的单链表 &#125; //////////////////////////////////////////// //单链表的建立1，头插法建立单链表 LinkedList LinkedListCreatH() &#123; Node *L; L = new Node; //申请头结点空间 L-&gt;next = nullptr; //初始化一个空链表 ElemType x; //x为链表数据域中的数据 while(scanf(&quot;%d&quot;,&amp;x) != EOF) &#123; Node *p; p = new Node; //申请新的结点 p-&gt;data = x; //结点数据域赋值 p-&gt;next = L-&gt;next; //将结点插入到表头L--&gt;|2|--&gt;|1|--&gt;NULL L-&gt;next = p; &#125; return L; &#125; //////////////////////////////////////////// //单链表的建立2，尾插法建立单链表 LinkedList LinkedListCreatT() &#123; Node *L; L = new Node; //申请头结点空间 L-&gt;next = nullptr; //初始化一个空链表 Node *r; r = L; //r始终指向终端结点，开始时指向头结点 ElemType x; //x为链表数据域中的数据 while(scanf(&quot;%d&quot;,&amp;x) != EOF) &#123; Node *p; p = new Node; //申请新的结点 p-&gt;data = x; //结点数据域赋值 r-&gt;next = p; //将结点插入到表头L--&gt;|1|--&gt;|2|--&gt;NULL r = p; &#125; r-&gt;next = nullptr; return L; &#125; //////////////////////////////////////////// //单链表的插入，在链表的第i个位置插入x的元素 LinkedList LinkedListInsert(LinkedList L,int i,ElemType x) &#123; Node *pre; //pre为前驱结点 pre = L; int tempi = 0; for (tempi = 1; tempi &lt; i; tempi++) pre = pre-&gt;next; //查找第i个位置的前驱结点 Node *p; //插入的结点为p p = new Node; p-&gt;data = x; p-&gt;next = pre-&gt;next; pre-&gt;next = p; return L; &#125; //////////////////////////////////////////// //单链表的删除，在链表中删除值为x的元素 LinkedList LinkedListDelete(LinkedList L,ElemType x) &#123; Node *p,*pre; //pre为前驱结点，p为查找的结点。 p = L-&gt;next; while(p-&gt;data != x) //查找值为x的元素 &#123; pre = p; p = p-&gt;next; &#125; pre-&gt;next = p-&gt;next; //删除操作，将其前驱next指向其后继。 free(p); return L; &#125; ///////////////////////////////////////////// int main() &#123; LinkedList list,start; printf(&quot;请输入单链表的数据：&quot;); list = LinkedListCreatH(); for(start = list-&gt;next; start != nullptr; start = start-&gt;next) printf(&quot;%d &quot;,start-&gt;data); printf(&quot;/n&quot;); printf(&quot;请输入单链表的数据：&quot;); list = LinkedListCreatT(); for(start = list-&gt;next; start != nullptr; start = start-&gt;next) printf(&quot;%d &quot;,start-&gt;data); printf(&quot;/n&quot;); int i; ElemType x; printf(&quot;请输入插入数据的位置：&quot;); scanf(&quot;%d&quot;,&amp;i); printf(&quot;请输入插入数据的值：&quot;); scanf(&quot;%d&quot;,&amp;x); LinkedListInsert(list,i,x); for(start = list-&gt;next; start != nullptr; start = start-&gt;next) printf(&quot;%d &quot;,start-&gt;data); printf(&quot;/n&quot;); printf(&quot;请输入要删除的元素的值：&quot;); scanf(&quot;%d&quot;,&amp;x); LinkedListDelete(list,x); for(start = list-&gt;next; start != nullptr; start = start-&gt;next) printf(&quot;%d &quot;,start-&gt;data); printf(&quot;/n&quot;); return 0; &#125; 话说与时代落后的老爷爷终于用上了nullptr【雾】","categories":[{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"},{"name":"算法","slug":"算法","permalink":"https://blog.youmingsama.cn/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"print*,\"hello world!!!\"","slug":"print-hello-world","permalink":"https://blog.youmingsama.cn/categories/print-hello-world/"},{"name":"摸鱼大师","slug":"摸鱼大师","permalink":"https://blog.youmingsama.cn/categories/%E6%91%B8%E9%B1%BC%E5%A4%A7%E5%B8%88/"},{"name":"文学","slug":"文学","permalink":"https://blog.youmingsama.cn/categories/%E6%96%87%E5%AD%A6/"},{"name":"bug的炼金工坊","slug":"bug的炼金工坊","permalink":"https://blog.youmingsama.cn/categories/bug%E7%9A%84%E7%82%BC%E9%87%91%E5%B7%A5%E5%9D%8A/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://blog.youmingsama.cn/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"Roman","slug":"Roman","permalink":"https://blog.youmingsama.cn/categories/Roman/"},{"name":"呐！","slug":"呐！","permalink":"https://blog.youmingsama.cn/categories/%E5%91%90%EF%BC%81/"},{"name":"游戏","slug":"游戏","permalink":"https://blog.youmingsama.cn/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.youmingsama.cn/tags/rust/"},{"name":"待定捏","slug":"待定捏","permalink":"https://blog.youmingsama.cn/tags/%E5%BE%85%E5%AE%9A%E6%8D%8F/"},{"name":"含泪入手","slug":"含泪入手","permalink":"https://blog.youmingsama.cn/tags/%E5%90%AB%E6%B3%AA%E5%85%A5%E6%89%8B/"},{"name":"水月雨","slug":"水月雨","permalink":"https://blog.youmingsama.cn/tags/%E6%B0%B4%E6%9C%88%E9%9B%A8/"},{"name":"文学","slug":"文学","permalink":"https://blog.youmingsama.cn/tags/%E6%96%87%E5%AD%A6/"},{"name":"翻车","slug":"翻车","permalink":"https://blog.youmingsama.cn/tags/%E7%BF%BB%E8%BD%A6/"},{"name":"谷歌","slug":"谷歌","permalink":"https://blog.youmingsama.cn/tags/%E8%B0%B7%E6%AD%8C/"},{"name":"data structure","slug":"data-structure","permalink":"https://blog.youmingsama.cn/tags/data-structure/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://blog.youmingsama.cn/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"不知道在讲啥","slug":"不知道在讲啥","permalink":"https://blog.youmingsama.cn/tags/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%9C%A8%E8%AE%B2%E5%95%A5/"},{"name":"cloudflare","slug":"cloudflare","permalink":"https://blog.youmingsama.cn/tags/cloudflare/"},{"name":"http","slug":"http","permalink":"https://blog.youmingsama.cn/tags/http/"},{"name":"算法","slug":"算法","permalink":"https://blog.youmingsama.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"蒟蒻弱弱弱弱弱","slug":"蒟蒻弱弱弱弱弱","permalink":"https://blog.youmingsama.cn/tags/%E8%92%9F%E8%92%BB%E5%BC%B1%E5%BC%B1%E5%BC%B1%E5%BC%B1%E5%BC%B1/"},{"name":"歌歌","slug":"歌歌","permalink":"https://blog.youmingsama.cn/tags/%E6%AD%8C%E6%AD%8C/"},{"name":"物语系列","slug":"物语系列","permalink":"https://blog.youmingsama.cn/tags/%E7%89%A9%E8%AF%AD%E7%B3%BB%E5%88%97/"},{"name":"jpg","slug":"jpg","permalink":"https://blog.youmingsama.cn/tags/jpg/"},{"name":"游戏","slug":"游戏","permalink":"https://blog.youmingsama.cn/tags/%E6%B8%B8%E6%88%8F/"},{"name":"java!!!","slug":"java","permalink":"https://blog.youmingsama.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.youmingsama.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"golang","slug":"golang","permalink":"https://blog.youmingsama.cn/tags/golang/"},{"name":"code","slug":"code","permalink":"https://blog.youmingsama.cn/tags/code/"},{"name":"算法啦","slug":"算法啦","permalink":"https://blog.youmingsama.cn/tags/%E7%AE%97%E6%B3%95%E5%95%A6/"},{"name":"buggggg","slug":"buggggg","permalink":"https://blog.youmingsama.cn/tags/buggggg/"},{"name":"网络安全","slug":"网络安全","permalink":"https://blog.youmingsama.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]}